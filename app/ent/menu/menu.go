
// Code generated by ent, DO NOT EDIT.



	

package menu




import (
	"context"
	"errors"
	"fmt"
	"math"
	"strings"
	"sync"
	"time"
		"placio-app/ent/predicate"
	"entgo.io/ent"
	"entgo.io/ent/dialect"
			"database/sql/driver"
			"entgo.io/ent/dialect/sql"
			"entgo.io/ent/dialect/sql/sqlgraph"
			"entgo.io/ent/dialect/sql/sqljson"
			"entgo.io/ent/schema/field"

)


const (
	// Label holds the string label denoting the menu type in the database.
	Label = "menu"
		// FieldID holds the string denoting the id field in the database.
		FieldID = "id"
		// FieldName holds the string denoting the name field in the database.
		FieldName = "name"
		// FieldDeletedAt holds the string denoting the deleted_at field in the database.
		FieldDeletedAt = "deleted_at"
		// FieldIsDeleted holds the string denoting the is_deleted field in the database.
		FieldIsDeleted = "is_deleted"
		// FieldDescription holds the string denoting the description field in the database.
		FieldDescription = "description"
		// FieldOptions holds the string denoting the options field in the database.
		FieldOptions = "options"
		// FieldFoodType holds the string denoting the foodtype field in the database.
		FieldFoodType = "food_type"
		// FieldMenuItemType holds the string denoting the menuitemtype field in the database.
		FieldMenuItemType = "menu_item_type"
		// FieldDrinkType holds the string denoting the drinktype field in the database.
		FieldDrinkType = "drink_type"
		// FieldDietaryType holds the string denoting the dietarytype field in the database.
		FieldDietaryType = "dietary_type"
		// FieldIsAvailable holds the string denoting the is_available field in the database.
		FieldIsAvailable = "is_available"
		// FieldUpdatedAt holds the string denoting the updated_at field in the database.
		FieldUpdatedAt = "updated_at"
		// EdgePlace holds the string denoting the place edge name in mutations.
		EdgePlace = "place"
		// EdgeCategories holds the string denoting the categories edge name in mutations.
		EdgeCategories = "categories"
		// EdgeMenuItems holds the string denoting the menu_items edge name in mutations.
		EdgeMenuItems = "menu_items"
		// EdgeMedia holds the string denoting the media edge name in mutations.
		EdgeMedia = "media"
		// EdgeCreatedBy holds the string denoting the created_by edge name in mutations.
		EdgeCreatedBy = "created_by"
		// EdgeUpdatedBy holds the string denoting the updated_by edge name in mutations.
		EdgeUpdatedBy = "updated_by"
	// Table holds the table name of the menu in the database.
	Table = "menus"
		// PlaceTable is the table that holds the place relation/edge. The primary key declared below.
		PlaceTable = "place_menus"
			// PlaceInverseTable is the table name for the Place entity.
			// It exists in this package in order to avoid circular dependency with the "place" package.
			PlaceInverseTable = "places"
		// CategoriesTable is the table that holds the categories relation/edge. The primary key declared below.
		CategoriesTable = "menu_categories"
			// CategoriesInverseTable is the table name for the Category entity.
			// It exists in this package in order to avoid circular dependency with the "category" package.
			CategoriesInverseTable = "categories"
		// MenuItemsTable is the table that holds the menu_items relation/edge. The primary key declared below.
		MenuItemsTable = "menu_menu_items"
			// MenuItemsInverseTable is the table name for the MenuItem entity.
			// It exists in this package in order to avoid circular dependency with the "menuitem" package.
			MenuItemsInverseTable = "menu_items"
		// MediaTable is the table that holds the media relation/edge. The primary key declared below.
		MediaTable = "menu_media"
			// MediaInverseTable is the table name for the Media entity.
			// It exists in this package in order to avoid circular dependency with the "media" package.
			MediaInverseTable = "media"
		// CreatedByTable is the table that holds the created_by relation/edge. The primary key declared below.
		CreatedByTable = "user_created_menus"
			// CreatedByInverseTable is the table name for the User entity.
			// It exists in this package in order to avoid circular dependency with the "user" package.
			CreatedByInverseTable = "users"
		// UpdatedByTable is the table that holds the updated_by relation/edge. The primary key declared below.
		UpdatedByTable = "user_updated_menus"
			// UpdatedByInverseTable is the table name for the User entity.
			// It exists in this package in order to avoid circular dependency with the "user" package.
			UpdatedByInverseTable = "users"

)



	
	// Columns holds all SQL columns for menu fields.
	var Columns = []string{
			FieldID,
			FieldName,
			FieldDeletedAt,
			FieldIsDeleted,
			FieldDescription,
			FieldOptions,
			FieldFoodType,
			FieldMenuItemType,
			FieldDrinkType,
			FieldDietaryType,
			FieldIsAvailable,
			FieldUpdatedAt,
	}
	
	

	
		var (
					// PlacePrimaryKey and PlaceColumn2 are the table columns denoting the
					// primary key for the place relation (M2M).
					PlacePrimaryKey = []string{"place_id", "menu_id"}
					// CategoriesPrimaryKey and CategoriesColumn2 are the table columns denoting the
					// primary key for the categories relation (M2M).
					CategoriesPrimaryKey = []string{"menu_id", "category_id"}
					// MenuItemsPrimaryKey and MenuItemsColumn2 are the table columns denoting the
					// primary key for the menu_items relation (M2M).
					MenuItemsPrimaryKey = []string{"menu_id", "menu_item_id"}
					// MediaPrimaryKey and MediaColumn2 are the table columns denoting the
					// primary key for the media relation (M2M).
					MediaPrimaryKey = []string{"menu_id", "media_id"}
					// CreatedByPrimaryKey and CreatedByColumn2 are the table columns denoting the
					// primary key for the created_by relation (M2M).
					CreatedByPrimaryKey = []string{"user_id", "menu_id"}
					// UpdatedByPrimaryKey and UpdatedByColumn2 are the table columns denoting the
					// primary key for the updated_by relation (M2M).
					UpdatedByPrimaryKey = []string{"user_id", "menu_id"}
		)
	





	
// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}









	var (
				// DefaultIsDeleted holds the default value on creation for the "is_deleted" field.
				DefaultIsDeleted bool
				// DefaultIsAvailable holds the default value on creation for the "is_available" field.
				DefaultIsAvailable bool
				// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
				DefaultUpdatedAt time.Time
				// IDValidator is a validator for the "id" field. It is called by the builders before save.
				IDValidator func (string) error
	)




	
	
	
		
		
		// FoodType defines the type for the "foodType" enum field.
		type FoodType string

		// FoodType values.
		const (
				FoodTypeLocal FoodType = "local"
				FoodTypeIntercontinental FoodType = "intercontinental"
				FoodTypeNational FoodType = "national"
				FoodTypeRegional FoodType = "regional"
				FoodTypeContinental FoodType = "continental"
		)

		func (ft FoodType) String() string {
			return string(ft)
		}
	


	
	// FoodTypeValidator is a validator for the "foodType" field enum values. It is called by the builders before save.
	func FoodTypeValidator(ft FoodType) error {
		switch ft {
			case FoodTypeLocal,FoodTypeIntercontinental,FoodTypeNational,FoodTypeRegional,FoodTypeContinental:
				return nil
			default:
				return fmt.Errorf("menu: invalid enum value for foodType field: %q", ft)
		}
	}

	
	
	
		
		
		// MenuItemType defines the type for the "menuItemType" enum field.
		type MenuItemType string

		// MenuItemType values.
		const (
				MenuItemTypeFood MenuItemType = "food"
				MenuItemTypeDrink MenuItemType = "drink"
		)

		func (mit MenuItemType) String() string {
			return string(mit)
		}
	


	
	// MenuItemTypeValidator is a validator for the "menuItemType" field enum values. It is called by the builders before save.
	func MenuItemTypeValidator(mit MenuItemType) error {
		switch mit {
			case MenuItemTypeFood,MenuItemTypeDrink:
				return nil
			default:
				return fmt.Errorf("menu: invalid enum value for menuItemType field: %q", mit)
		}
	}

	
	
	
		
		
		// DrinkType defines the type for the "drinkType" enum field.
		type DrinkType string

		// DrinkType values.
		const (
				DrinkTypeAlcoholic DrinkType = "alcoholic"
				DrinkTypeNonAlcoholic DrinkType = "non-alcoholic"
				DrinkTypeBoth DrinkType = "both"
		)

		func (dt DrinkType) String() string {
			return string(dt)
		}
	


	
	// DrinkTypeValidator is a validator for the "drinkType" field enum values. It is called by the builders before save.
	func DrinkTypeValidator(dt DrinkType) error {
		switch dt {
			case DrinkTypeAlcoholic,DrinkTypeNonAlcoholic,DrinkTypeBoth:
				return nil
			default:
				return fmt.Errorf("menu: invalid enum value for drinkType field: %q", dt)
		}
	}

	
	
	
		
		
		// DietaryType defines the type for the "dietaryType" enum field.
		type DietaryType string

		// DietaryType values.
		const (
				DietaryTypeVegan DietaryType = "vegan"
				DietaryTypeVegetarian DietaryType = "vegetarian"
				DietaryTypeNonVegetarian DietaryType = "non-vegetarian"
				DietaryTypeBoth DietaryType = "both"
		)

		func (dt DietaryType) String() string {
			return string(dt)
		}
	


	
	// DietaryTypeValidator is a validator for the "dietaryType" field enum values. It is called by the builders before save.
	func DietaryTypeValidator(dt DietaryType) error {
		switch dt {
			case DietaryTypeVegan,DietaryTypeVegetarian,DietaryTypeNonVegetarian,DietaryTypeBoth:
				return nil
			default:
				return fmt.Errorf("menu: invalid enum value for dietaryType field: %q", dt)
		}
	}



// OrderOption defines the ordering options for the Menu queries.
type OrderOption func(*sql.Selector)

	
	
		// ByID orders the results by the id field.
		func ByID(opts ...sql.OrderTermOption) OrderOption {
			return sql.OrderByField(FieldID, opts...).ToFunc()
		}
	
			// ByName orders the results by the name field.
			func ByName(opts ...sql.OrderTermOption) OrderOption {
				return sql.OrderByField(FieldName, opts...).ToFunc()
			}
			// ByDeletedAt orders the results by the deleted_at field.
			func ByDeletedAt(opts ...sql.OrderTermOption) OrderOption {
				return sql.OrderByField(FieldDeletedAt, opts...).ToFunc()
			}
			// ByIsDeleted orders the results by the is_deleted field.
			func ByIsDeleted(opts ...sql.OrderTermOption) OrderOption {
				return sql.OrderByField(FieldIsDeleted, opts...).ToFunc()
			}
			// ByDescription orders the results by the description field.
			func ByDescription(opts ...sql.OrderTermOption) OrderOption {
				return sql.OrderByField(FieldDescription, opts...).ToFunc()
			}
			// ByOptions orders the results by the options field.
			func ByOptions(opts ...sql.OrderTermOption) OrderOption {
				return sql.OrderByField(FieldOptions, opts...).ToFunc()
			}
			// ByFoodType orders the results by the foodType field.
			func ByFoodType(opts ...sql.OrderTermOption) OrderOption {
				return sql.OrderByField(FieldFoodType, opts...).ToFunc()
			}
			// ByMenuItemType orders the results by the menuItemType field.
			func ByMenuItemType(opts ...sql.OrderTermOption) OrderOption {
				return sql.OrderByField(FieldMenuItemType, opts...).ToFunc()
			}
			// ByDrinkType orders the results by the drinkType field.
			func ByDrinkType(opts ...sql.OrderTermOption) OrderOption {
				return sql.OrderByField(FieldDrinkType, opts...).ToFunc()
			}
			// ByDietaryType orders the results by the dietaryType field.
			func ByDietaryType(opts ...sql.OrderTermOption) OrderOption {
				return sql.OrderByField(FieldDietaryType, opts...).ToFunc()
			}
			// ByIsAvailable orders the results by the is_available field.
			func ByIsAvailable(opts ...sql.OrderTermOption) OrderOption {
				return sql.OrderByField(FieldIsAvailable, opts...).ToFunc()
			}
			// ByUpdatedAt orders the results by the updated_at field.
			func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
				return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
			}
			// ByPlaceCount orders the results by place count.
			func ByPlaceCount(opts ...sql.OrderTermOption) OrderOption {
				return func(s *sql.Selector) {
					sqlgraph.OrderByNeighborsCount(s, newPlaceStep(), opts...)
				}
			}

			// ByPlace orders the results by place terms.
			func ByPlace(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
				return func(s *sql.Selector) {
					sqlgraph.OrderByNeighborTerms(s, newPlaceStep(), append([]sql.OrderTerm{term}, terms...)...)
				}
			}
			// ByCategoriesCount orders the results by categories count.
			func ByCategoriesCount(opts ...sql.OrderTermOption) OrderOption {
				return func(s *sql.Selector) {
					sqlgraph.OrderByNeighborsCount(s, newCategoriesStep(), opts...)
				}
			}

			// ByCategories orders the results by categories terms.
			func ByCategories(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
				return func(s *sql.Selector) {
					sqlgraph.OrderByNeighborTerms(s, newCategoriesStep(), append([]sql.OrderTerm{term}, terms...)...)
				}
			}
			// ByMenuItemsCount orders the results by menu_items count.
			func ByMenuItemsCount(opts ...sql.OrderTermOption) OrderOption {
				return func(s *sql.Selector) {
					sqlgraph.OrderByNeighborsCount(s, newMenuItemsStep(), opts...)
				}
			}

			// ByMenuItems orders the results by menu_items terms.
			func ByMenuItems(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
				return func(s *sql.Selector) {
					sqlgraph.OrderByNeighborTerms(s, newMenuItemsStep(), append([]sql.OrderTerm{term}, terms...)...)
				}
			}
			// ByMediaCount orders the results by media count.
			func ByMediaCount(opts ...sql.OrderTermOption) OrderOption {
				return func(s *sql.Selector) {
					sqlgraph.OrderByNeighborsCount(s, newMediaStep(), opts...)
				}
			}

			// ByMedia orders the results by media terms.
			func ByMedia(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
				return func(s *sql.Selector) {
					sqlgraph.OrderByNeighborTerms(s, newMediaStep(), append([]sql.OrderTerm{term}, terms...)...)
				}
			}
			// ByCreatedByCount orders the results by created_by count.
			func ByCreatedByCount(opts ...sql.OrderTermOption) OrderOption {
				return func(s *sql.Selector) {
					sqlgraph.OrderByNeighborsCount(s, newCreatedByStep(), opts...)
				}
			}

			// ByCreatedBy orders the results by created_by terms.
			func ByCreatedBy(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
				return func(s *sql.Selector) {
					sqlgraph.OrderByNeighborTerms(s, newCreatedByStep(), append([]sql.OrderTerm{term}, terms...)...)
				}
			}
			// ByUpdatedByCount orders the results by updated_by count.
			func ByUpdatedByCount(opts ...sql.OrderTermOption) OrderOption {
				return func(s *sql.Selector) {
					sqlgraph.OrderByNeighborsCount(s, newUpdatedByStep(), opts...)
				}
			}

			// ByUpdatedBy orders the results by updated_by terms.
			func ByUpdatedBy(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
				return func(s *sql.Selector) {
					sqlgraph.OrderByNeighborTerms(s, newUpdatedByStep(), append([]sql.OrderTerm{term}, terms...)...)
				}
			}
		func newPlaceStep() *sqlgraph.Step {
			return sqlgraph.NewStep(
					sqlgraph.From(Table, FieldID),
						sqlgraph.To(PlaceInverseTable, FieldID),
				sqlgraph.Edge(sqlgraph.M2M, true, PlaceTable,PlacePrimaryKey...),
			)
		}
		func newCategoriesStep() *sqlgraph.Step {
			return sqlgraph.NewStep(
					sqlgraph.From(Table, FieldID),
						sqlgraph.To(CategoriesInverseTable, FieldID),
				sqlgraph.Edge(sqlgraph.M2M, false, CategoriesTable,CategoriesPrimaryKey...),
			)
		}
		func newMenuItemsStep() *sqlgraph.Step {
			return sqlgraph.NewStep(
					sqlgraph.From(Table, FieldID),
						sqlgraph.To(MenuItemsInverseTable, FieldID),
				sqlgraph.Edge(sqlgraph.M2M, false, MenuItemsTable,MenuItemsPrimaryKey...),
			)
		}
		func newMediaStep() *sqlgraph.Step {
			return sqlgraph.NewStep(
					sqlgraph.From(Table, FieldID),
						sqlgraph.To(MediaInverseTable, FieldID),
				sqlgraph.Edge(sqlgraph.M2M, false, MediaTable,MediaPrimaryKey...),
			)
		}
		func newCreatedByStep() *sqlgraph.Step {
			return sqlgraph.NewStep(
					sqlgraph.From(Table, FieldID),
						sqlgraph.To(CreatedByInverseTable, FieldID),
				sqlgraph.Edge(sqlgraph.M2M, true, CreatedByTable,CreatedByPrimaryKey...),
			)
		}
		func newUpdatedByStep() *sqlgraph.Step {
			return sqlgraph.NewStep(
					sqlgraph.From(Table, FieldID),
						sqlgraph.To(UpdatedByInverseTable, FieldID),
				sqlgraph.Edge(sqlgraph.M2M, true, UpdatedByTable,UpdatedByPrimaryKey...),
			)
		}







