



// Code generated by ent, DO NOT EDIT.



package ent



	
import (
	"context"
	"errors"
	"fmt"
	"math"
	"strings"
	"sync"
	"time"
		"placio-app/ent/predicate"
	"entgo.io/ent"
	"entgo.io/ent/dialect"
			"database/sql/driver"
			"entgo.io/ent/dialect/sql"
			"entgo.io/ent/dialect/sql/sqlgraph"
			"entgo.io/ent/dialect/sql/sqljson"
			"entgo.io/ent/schema/field"
			 "placio-app/ent/review"
			 "placio-app/ent/user"
			 "placio-app/ent/business"
			 "placio-app/ent/place"
			 "placio-app/ent/event"
			 "placio-app/ent/media"
			 "placio-app/ent/comment"
			 "placio-app/ent/like"

)








// ReviewUpdate is the builder for updating Review entities.
type ReviewUpdate struct {
	config
	hooks []Hook
	mutation *ReviewMutation
}

// Where appends a list predicates to the ReviewUpdate builder.
func (ru *ReviewUpdate) Where(ps ...predicate.Review) *ReviewUpdate {
	ru.mutation.Where(ps...)
	return ru
}


	





	
	
	


	
	
	// SetScore sets the "score" field.
	func (ru *ReviewUpdate) SetScore(f float64) *ReviewUpdate {
			ru.mutation.ResetScore()
		ru.mutation.SetScore(f)
		return ru
	}

	
	
	
	
	
	
		// SetNillableScore sets the "score" field if the given value is not nil.
		func (ru *ReviewUpdate) SetNillableScore(f *float64) *ReviewUpdate {
			if f != nil {
				ru.SetScore(*f)
			}
			return ru
		}
	

	
		// AddScore adds f to the "score" field.
		func (ru *ReviewUpdate) AddScore(f float64) *ReviewUpdate {
			ru.mutation.AddScore(f)
			return ru
		}
	

	

	

	
	
	// SetContent sets the "content" field.
	func (ru *ReviewUpdate) SetContent(s string) *ReviewUpdate {
		ru.mutation.SetContent(s)
		return ru
	}

	
	
	
	
	
	
		// SetNillableContent sets the "content" field if the given value is not nil.
		func (ru *ReviewUpdate) SetNillableContent(s *string) *ReviewUpdate {
			if s != nil {
				ru.SetContent(*s)
			}
			return ru
		}
	

	

	

	

	
	
	// SetCreatedAt sets the "createdAt" field.
	func (ru *ReviewUpdate) SetCreatedAt(t time.Time) *ReviewUpdate {
		ru.mutation.SetCreatedAt(t)
		return ru
	}

	
	
	
	
	
	
		// SetNillableCreatedAt sets the "createdAt" field if the given value is not nil.
		func (ru *ReviewUpdate) SetNillableCreatedAt(t *time.Time) *ReviewUpdate {
			if t != nil {
				ru.SetCreatedAt(*t)
			}
			return ru
		}
	

	

	

	

	
	
	// SetLikeCount sets the "likeCount" field.
	func (ru *ReviewUpdate) SetLikeCount(i int) *ReviewUpdate {
			ru.mutation.ResetLikeCount()
		ru.mutation.SetLikeCount(i)
		return ru
	}

	
	
	
	
	
	
		// SetNillableLikeCount sets the "likeCount" field if the given value is not nil.
		func (ru *ReviewUpdate) SetNillableLikeCount(i *int) *ReviewUpdate {
			if i != nil {
				ru.SetLikeCount(*i)
			}
			return ru
		}
	

	
		// AddLikeCount adds i to the "likeCount" field.
		func (ru *ReviewUpdate) AddLikeCount(i int) *ReviewUpdate {
			ru.mutation.AddLikeCount(i)
			return ru
		}
	

	

	

	
	
	// SetDislikeCount sets the "dislikeCount" field.
	func (ru *ReviewUpdate) SetDislikeCount(i int) *ReviewUpdate {
			ru.mutation.ResetDislikeCount()
		ru.mutation.SetDislikeCount(i)
		return ru
	}

	
	
	
	
	
	
		// SetNillableDislikeCount sets the "dislikeCount" field if the given value is not nil.
		func (ru *ReviewUpdate) SetNillableDislikeCount(i *int) *ReviewUpdate {
			if i != nil {
				ru.SetDislikeCount(*i)
			}
			return ru
		}
	

	
		// AddDislikeCount adds i to the "dislikeCount" field.
		func (ru *ReviewUpdate) AddDislikeCount(i int) *ReviewUpdate {
			ru.mutation.AddDislikeCount(i)
			return ru
		}
	

	

	

	
	
	// SetFlag sets the "flag" field.
	func (ru *ReviewUpdate) SetFlag(s string) *ReviewUpdate {
		ru.mutation.SetFlag(s)
		return ru
	}

	
	
	
	
	
	
		// SetNillableFlag sets the "flag" field if the given value is not nil.
		func (ru *ReviewUpdate) SetNillableFlag(s *string) *ReviewUpdate {
			if s != nil {
				ru.SetFlag(*s)
			}
			return ru
		}
	

	

	

	



	
	
	
	
	
		// SetUserID sets the "user" edge to the User entity by ID.
		func (ru *ReviewUpdate) SetUserID(id string) *ReviewUpdate {
			ru.mutation.SetUserID(id)
			return ru
		}
	
	
	
	
	
	// SetUser sets the "user" edge to the User entity.
	func (ru *ReviewUpdate) SetUser(u *User) *ReviewUpdate {
		return ru.SetUserID(u.ID)
	}

	
	
	
	
	
		// SetBusinessID sets the "business" edge to the Business entity by ID.
		func (ru *ReviewUpdate) SetBusinessID(id string) *ReviewUpdate {
			ru.mutation.SetBusinessID(id)
			return ru
		}
	
	
		
		// SetNillableBusinessID sets the "business" edge to the Business entity by ID if the given value is not nil.
		func (ru *ReviewUpdate) SetNillableBusinessID(id *string) *ReviewUpdate {
			if id != nil {
				ru = ru.SetBusinessID(*id)
			}
			return ru
		}
	
	
	
	
	// SetBusiness sets the "business" edge to the Business entity.
	func (ru *ReviewUpdate) SetBusiness(b *Business) *ReviewUpdate {
		return ru.SetBusinessID(b.ID)
	}

	
	
	
	
	
		// SetPlaceID sets the "place" edge to the Place entity by ID.
		func (ru *ReviewUpdate) SetPlaceID(id string) *ReviewUpdate {
			ru.mutation.SetPlaceID(id)
			return ru
		}
	
	
		
		// SetNillablePlaceID sets the "place" edge to the Place entity by ID if the given value is not nil.
		func (ru *ReviewUpdate) SetNillablePlaceID(id *string) *ReviewUpdate {
			if id != nil {
				ru = ru.SetPlaceID(*id)
			}
			return ru
		}
	
	
	
	
	// SetPlace sets the "place" edge to the Place entity.
	func (ru *ReviewUpdate) SetPlace(p *Place) *ReviewUpdate {
		return ru.SetPlaceID(p.ID)
	}

	
	
	
	
	
		// SetEventID sets the "event" edge to the Event entity by ID.
		func (ru *ReviewUpdate) SetEventID(id string) *ReviewUpdate {
			ru.mutation.SetEventID(id)
			return ru
		}
	
	
		
		// SetNillableEventID sets the "event" edge to the Event entity by ID if the given value is not nil.
		func (ru *ReviewUpdate) SetNillableEventID(id *string) *ReviewUpdate {
			if id != nil {
				ru = ru.SetEventID(*id)
			}
			return ru
		}
	
	
	
	
	// SetEvent sets the "event" edge to the Event entity.
	func (ru *ReviewUpdate) SetEvent(e *Event) *ReviewUpdate {
		return ru.SetEventID(e.ID)
	}

	
	
	
	
	
		// AddMediaIDs adds the "medias" edge to the Media entity by IDs.
		func (ru *ReviewUpdate) AddMediaIDs(ids ... string) *ReviewUpdate {
			ru.mutation.AddMediaIDs(ids ...)
			return ru
		}
	
	
	
	
	
	// AddMedias adds the "medias" edges to the Media entity.
	func (ru *ReviewUpdate) AddMedias(m ...*Media) *ReviewUpdate {
		ids := make([]string, len(m))
			for i := range m {
				ids[i] = m[i].ID
			}
			return ru.AddMediaIDs(ids...)
	}

	
	
	
	
	
		// AddCommentIDs adds the "comments" edge to the Comment entity by IDs.
		func (ru *ReviewUpdate) AddCommentIDs(ids ... string) *ReviewUpdate {
			ru.mutation.AddCommentIDs(ids ...)
			return ru
		}
	
	
	
	
	
	// AddComments adds the "comments" edges to the Comment entity.
	func (ru *ReviewUpdate) AddComments(c ...*Comment) *ReviewUpdate {
		ids := make([]string, len(c))
			for i := range c {
				ids[i] = c[i].ID
			}
			return ru.AddCommentIDs(ids...)
	}

	
	
	
	
	
		// AddLikeIDs adds the "likes" edge to the Like entity by IDs.
		func (ru *ReviewUpdate) AddLikeIDs(ids ... string) *ReviewUpdate {
			ru.mutation.AddLikeIDs(ids ...)
			return ru
		}
	
	
	
	
	
	// AddLikes adds the "likes" edges to the Like entity.
	func (ru *ReviewUpdate) AddLikes(l ...*Like) *ReviewUpdate {
		ids := make([]string, len(l))
			for i := range l {
				ids[i] = l[i].ID
			}
			return ru.AddLikeIDs(ids...)
	}


// Mutation returns the ReviewMutation object of the builder.
func (ru *ReviewUpdate) Mutation() *ReviewMutation {
	return ru.mutation
}





	





	
	
	// ClearUser clears the "user" edge to the User entity.
	func (ru *ReviewUpdate) ClearUser() *ReviewUpdate {
		ru.mutation.ClearUser()
		return ru
	}
	

	
	
	// ClearBusiness clears the "business" edge to the Business entity.
	func (ru *ReviewUpdate) ClearBusiness() *ReviewUpdate {
		ru.mutation.ClearBusiness()
		return ru
	}
	

	
	
	// ClearPlace clears the "place" edge to the Place entity.
	func (ru *ReviewUpdate) ClearPlace() *ReviewUpdate {
		ru.mutation.ClearPlace()
		return ru
	}
	

	
	
	// ClearEvent clears the "event" edge to the Event entity.
	func (ru *ReviewUpdate) ClearEvent() *ReviewUpdate {
		ru.mutation.ClearEvent()
		return ru
	}
	

	
	
	// ClearMedias clears all "medias" edges to the Media entity.
	func (ru *ReviewUpdate) ClearMedias() *ReviewUpdate {
		ru.mutation.ClearMedias()
		return ru
	}
	
		
		
		
		
		// RemoveMediaIDs removes the "medias" edge to Media entities by IDs.
		func (ru *ReviewUpdate) RemoveMediaIDs(ids ...string) *ReviewUpdate {
			ru.mutation.RemoveMediaIDs(ids...)
			return ru
		}
		
		// RemoveMedias removes "medias" edges to Media entities.
		func (ru *ReviewUpdate) RemoveMedias(m ...*Media) *ReviewUpdate {
			ids := make([]string, len(m))
			for i := range m {
				ids[i] = m[i].ID
			}
			return ru.RemoveMediaIDs(ids...)
		}
	

	
	
	// ClearComments clears all "comments" edges to the Comment entity.
	func (ru *ReviewUpdate) ClearComments() *ReviewUpdate {
		ru.mutation.ClearComments()
		return ru
	}
	
		
		
		
		
		// RemoveCommentIDs removes the "comments" edge to Comment entities by IDs.
		func (ru *ReviewUpdate) RemoveCommentIDs(ids ...string) *ReviewUpdate {
			ru.mutation.RemoveCommentIDs(ids...)
			return ru
		}
		
		// RemoveComments removes "comments" edges to Comment entities.
		func (ru *ReviewUpdate) RemoveComments(c ...*Comment) *ReviewUpdate {
			ids := make([]string, len(c))
			for i := range c {
				ids[i] = c[i].ID
			}
			return ru.RemoveCommentIDs(ids...)
		}
	

	
	
	// ClearLikes clears all "likes" edges to the Like entity.
	func (ru *ReviewUpdate) ClearLikes() *ReviewUpdate {
		ru.mutation.ClearLikes()
		return ru
	}
	
		
		
		
		
		// RemoveLikeIDs removes the "likes" edge to Like entities by IDs.
		func (ru *ReviewUpdate) RemoveLikeIDs(ids ...string) *ReviewUpdate {
			ru.mutation.RemoveLikeIDs(ids...)
			return ru
		}
		
		// RemoveLikes removes "likes" edges to Like entities.
		func (ru *ReviewUpdate) RemoveLikes(l ...*Like) *ReviewUpdate {
			ids := make([]string, len(l))
			for i := range l {
				ids[i] = l[i].ID
			}
			return ru.RemoveLikeIDs(ids...)
		}
	




// Save executes the query and returns the number of nodes affected by the update operation.
func (ru *ReviewUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, ru.sqlSave, ru.mutation, ru.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ru *ReviewUpdate) SaveX(ctx context.Context) int {
	affected, err := ru.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (ru *ReviewUpdate) Exec(ctx context.Context) error {
	_, err := ru.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ru *ReviewUpdate) ExecX(ctx context.Context) {
	if err := ru.Exec(ctx); err != nil {
		panic(err)
	}
}


	









	// check runs all checks and user-defined validators on the builder.
	func (ru *ReviewUpdate) check() error {
				if v, ok := ru.mutation.Score(); ok {
					if err := review.ScoreValidator(v); err != nil {
						return &ValidationError{Name: "score", err: fmt.Errorf(`ent: validator failed for field "Review.score": %w`, err)}
					}
				}
				if _, ok := ru.mutation.UserID(); ru.mutation.UserCleared() && !ok {
					return errors.New(`ent: clearing a required unique edge "Review.user"`)
				}
		return nil
	}






	
	





    


func (ru *ReviewUpdate) sqlSave(ctx context.Context) (n int, err error) {
		if err := ru.check(); err != nil {
			return n, err
		}
	_spec := sqlgraph.NewUpdateSpec(review.Table, review.Columns,sqlgraph.NewFieldSpec(review.FieldID, field.TypeString))
	if ps := ru.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
				if value, ok := ru.mutation.Score(); ok {
						_spec.SetField(review.FieldScore, field.TypeFloat64, value)
				}
					if value, ok := ru.mutation.AddedScore(); ok {
							_spec.AddField(review.FieldScore, field.TypeFloat64, value)
					}
				if value, ok := ru.mutation.Content(); ok {
						_spec.SetField(review.FieldContent, field.TypeString, value)
				}
				if value, ok := ru.mutation.CreatedAt(); ok {
						_spec.SetField(review.FieldCreatedAt, field.TypeTime, value)
				}
				if value, ok := ru.mutation.LikeCount(); ok {
						_spec.SetField(review.FieldLikeCount, field.TypeInt, value)
				}
					if value, ok := ru.mutation.AddedLikeCount(); ok {
							_spec.AddField(review.FieldLikeCount, field.TypeInt, value)
					}
				if value, ok := ru.mutation.DislikeCount(); ok {
						_spec.SetField(review.FieldDislikeCount, field.TypeInt, value)
				}
					if value, ok := ru.mutation.AddedDislikeCount(); ok {
							_spec.AddField(review.FieldDislikeCount, field.TypeInt, value)
					}
				if value, ok := ru.mutation.Flag(); ok {
						_spec.SetField(review.FieldFlag, field.TypeString, value)
				}
		if ru.mutation.UserCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: true,
		Table: review.UserTable,
		Columns: []string{ review.UserColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
		if nodes := ru.mutation.UserIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: true,
		Table: review.UserTable,
		Columns: []string{ review.UserColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if ru.mutation.BusinessCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: false,
		Table: review.BusinessTable,
		Columns: []string{ review.BusinessColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(business.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
		if nodes := ru.mutation.BusinessIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: false,
		Table: review.BusinessTable,
		Columns: []string{ review.BusinessColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(business.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if ru.mutation.PlaceCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: false,
		Table: review.PlaceTable,
		Columns: []string{ review.PlaceColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(place.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
		if nodes := ru.mutation.PlaceIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: false,
		Table: review.PlaceTable,
		Columns: []string{ review.PlaceColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(place.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if ru.mutation.EventCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: false,
		Table: review.EventTable,
		Columns: []string{ review.EventColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(event.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
		if nodes := ru.mutation.EventIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: false,
		Table: review.EventTable,
		Columns: []string{ review.EventColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(event.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if ru.mutation.MediasCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.MediasTable,
		Columns: []string{ review.MediasColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(media.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := ru.mutation.RemovedMediasIDs(); len(nodes) > 0 && !ru.mutation.MediasCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.MediasTable,
		Columns: []string{ review.MediasColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(media.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := ru.mutation.MediasIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.MediasTable,
		Columns: []string{ review.MediasColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(media.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if ru.mutation.CommentsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.CommentsTable,
		Columns: []string{ review.CommentsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(comment.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := ru.mutation.RemovedCommentsIDs(); len(nodes) > 0 && !ru.mutation.CommentsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.CommentsTable,
		Columns: []string{ review.CommentsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(comment.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := ru.mutation.CommentsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.CommentsTable,
		Columns: []string{ review.CommentsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(comment.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if ru.mutation.LikesCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.LikesTable,
		Columns: []string{ review.LikesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(like.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := ru.mutation.RemovedLikesIDs(); len(nodes) > 0 && !ru.mutation.LikesCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.LikesTable,
		Columns: []string{ review.LikesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(like.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := ru.mutation.LikesIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.LikesTable,
		Columns: []string{ review.LikesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(like.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if n, err = sqlgraph.UpdateNodes(ctx, ru.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{ review.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	ru.mutation.done = true
	return n, nil
}







// ReviewUpdateOne is the builder for updating a single Review entity.
type ReviewUpdateOne struct {
	config
	fields []string
	hooks []Hook
	mutation *ReviewMutation

}


	





	
	
	


	
	
	// SetScore sets the "score" field.
	func (ruo *ReviewUpdateOne) SetScore(f float64) *ReviewUpdateOne {
			ruo.mutation.ResetScore()
		ruo.mutation.SetScore(f)
		return ruo
	}

	
	
	
	
	
	
		// SetNillableScore sets the "score" field if the given value is not nil.
		func (ruo *ReviewUpdateOne) SetNillableScore(f *float64) *ReviewUpdateOne {
			if f != nil {
				ruo.SetScore(*f)
			}
			return ruo
		}
	

	
		// AddScore adds f to the "score" field.
		func (ruo *ReviewUpdateOne) AddScore(f float64) *ReviewUpdateOne {
			ruo.mutation.AddScore(f)
			return ruo
		}
	

	

	

	
	
	// SetContent sets the "content" field.
	func (ruo *ReviewUpdateOne) SetContent(s string) *ReviewUpdateOne {
		ruo.mutation.SetContent(s)
		return ruo
	}

	
	
	
	
	
	
		// SetNillableContent sets the "content" field if the given value is not nil.
		func (ruo *ReviewUpdateOne) SetNillableContent(s *string) *ReviewUpdateOne {
			if s != nil {
				ruo.SetContent(*s)
			}
			return ruo
		}
	

	

	

	

	
	
	// SetCreatedAt sets the "createdAt" field.
	func (ruo *ReviewUpdateOne) SetCreatedAt(t time.Time) *ReviewUpdateOne {
		ruo.mutation.SetCreatedAt(t)
		return ruo
	}

	
	
	
	
	
	
		// SetNillableCreatedAt sets the "createdAt" field if the given value is not nil.
		func (ruo *ReviewUpdateOne) SetNillableCreatedAt(t *time.Time) *ReviewUpdateOne {
			if t != nil {
				ruo.SetCreatedAt(*t)
			}
			return ruo
		}
	

	

	

	

	
	
	// SetLikeCount sets the "likeCount" field.
	func (ruo *ReviewUpdateOne) SetLikeCount(i int) *ReviewUpdateOne {
			ruo.mutation.ResetLikeCount()
		ruo.mutation.SetLikeCount(i)
		return ruo
	}

	
	
	
	
	
	
		// SetNillableLikeCount sets the "likeCount" field if the given value is not nil.
		func (ruo *ReviewUpdateOne) SetNillableLikeCount(i *int) *ReviewUpdateOne {
			if i != nil {
				ruo.SetLikeCount(*i)
			}
			return ruo
		}
	

	
		// AddLikeCount adds i to the "likeCount" field.
		func (ruo *ReviewUpdateOne) AddLikeCount(i int) *ReviewUpdateOne {
			ruo.mutation.AddLikeCount(i)
			return ruo
		}
	

	

	

	
	
	// SetDislikeCount sets the "dislikeCount" field.
	func (ruo *ReviewUpdateOne) SetDislikeCount(i int) *ReviewUpdateOne {
			ruo.mutation.ResetDislikeCount()
		ruo.mutation.SetDislikeCount(i)
		return ruo
	}

	
	
	
	
	
	
		// SetNillableDislikeCount sets the "dislikeCount" field if the given value is not nil.
		func (ruo *ReviewUpdateOne) SetNillableDislikeCount(i *int) *ReviewUpdateOne {
			if i != nil {
				ruo.SetDislikeCount(*i)
			}
			return ruo
		}
	

	
		// AddDislikeCount adds i to the "dislikeCount" field.
		func (ruo *ReviewUpdateOne) AddDislikeCount(i int) *ReviewUpdateOne {
			ruo.mutation.AddDislikeCount(i)
			return ruo
		}
	

	

	

	
	
	// SetFlag sets the "flag" field.
	func (ruo *ReviewUpdateOne) SetFlag(s string) *ReviewUpdateOne {
		ruo.mutation.SetFlag(s)
		return ruo
	}

	
	
	
	
	
	
		// SetNillableFlag sets the "flag" field if the given value is not nil.
		func (ruo *ReviewUpdateOne) SetNillableFlag(s *string) *ReviewUpdateOne {
			if s != nil {
				ruo.SetFlag(*s)
			}
			return ruo
		}
	

	

	

	



	
	
	
	
	
		// SetUserID sets the "user" edge to the User entity by ID.
		func (ruo *ReviewUpdateOne) SetUserID(id string) *ReviewUpdateOne {
			ruo.mutation.SetUserID(id)
			return ruo
		}
	
	
	
	
	
	// SetUser sets the "user" edge to the User entity.
	func (ruo *ReviewUpdateOne) SetUser(u *User) *ReviewUpdateOne {
		return ruo.SetUserID(u.ID)
	}

	
	
	
	
	
		// SetBusinessID sets the "business" edge to the Business entity by ID.
		func (ruo *ReviewUpdateOne) SetBusinessID(id string) *ReviewUpdateOne {
			ruo.mutation.SetBusinessID(id)
			return ruo
		}
	
	
		
		// SetNillableBusinessID sets the "business" edge to the Business entity by ID if the given value is not nil.
		func (ruo *ReviewUpdateOne) SetNillableBusinessID(id *string) *ReviewUpdateOne {
			if id != nil {
				ruo = ruo.SetBusinessID(*id)
			}
			return ruo
		}
	
	
	
	
	// SetBusiness sets the "business" edge to the Business entity.
	func (ruo *ReviewUpdateOne) SetBusiness(b *Business) *ReviewUpdateOne {
		return ruo.SetBusinessID(b.ID)
	}

	
	
	
	
	
		// SetPlaceID sets the "place" edge to the Place entity by ID.
		func (ruo *ReviewUpdateOne) SetPlaceID(id string) *ReviewUpdateOne {
			ruo.mutation.SetPlaceID(id)
			return ruo
		}
	
	
		
		// SetNillablePlaceID sets the "place" edge to the Place entity by ID if the given value is not nil.
		func (ruo *ReviewUpdateOne) SetNillablePlaceID(id *string) *ReviewUpdateOne {
			if id != nil {
				ruo = ruo.SetPlaceID(*id)
			}
			return ruo
		}
	
	
	
	
	// SetPlace sets the "place" edge to the Place entity.
	func (ruo *ReviewUpdateOne) SetPlace(p *Place) *ReviewUpdateOne {
		return ruo.SetPlaceID(p.ID)
	}

	
	
	
	
	
		// SetEventID sets the "event" edge to the Event entity by ID.
		func (ruo *ReviewUpdateOne) SetEventID(id string) *ReviewUpdateOne {
			ruo.mutation.SetEventID(id)
			return ruo
		}
	
	
		
		// SetNillableEventID sets the "event" edge to the Event entity by ID if the given value is not nil.
		func (ruo *ReviewUpdateOne) SetNillableEventID(id *string) *ReviewUpdateOne {
			if id != nil {
				ruo = ruo.SetEventID(*id)
			}
			return ruo
		}
	
	
	
	
	// SetEvent sets the "event" edge to the Event entity.
	func (ruo *ReviewUpdateOne) SetEvent(e *Event) *ReviewUpdateOne {
		return ruo.SetEventID(e.ID)
	}

	
	
	
	
	
		// AddMediaIDs adds the "medias" edge to the Media entity by IDs.
		func (ruo *ReviewUpdateOne) AddMediaIDs(ids ... string) *ReviewUpdateOne {
			ruo.mutation.AddMediaIDs(ids ...)
			return ruo
		}
	
	
	
	
	
	// AddMedias adds the "medias" edges to the Media entity.
	func (ruo *ReviewUpdateOne) AddMedias(m ...*Media) *ReviewUpdateOne {
		ids := make([]string, len(m))
			for i := range m {
				ids[i] = m[i].ID
			}
			return ruo.AddMediaIDs(ids...)
	}

	
	
	
	
	
		// AddCommentIDs adds the "comments" edge to the Comment entity by IDs.
		func (ruo *ReviewUpdateOne) AddCommentIDs(ids ... string) *ReviewUpdateOne {
			ruo.mutation.AddCommentIDs(ids ...)
			return ruo
		}
	
	
	
	
	
	// AddComments adds the "comments" edges to the Comment entity.
	func (ruo *ReviewUpdateOne) AddComments(c ...*Comment) *ReviewUpdateOne {
		ids := make([]string, len(c))
			for i := range c {
				ids[i] = c[i].ID
			}
			return ruo.AddCommentIDs(ids...)
	}

	
	
	
	
	
		// AddLikeIDs adds the "likes" edge to the Like entity by IDs.
		func (ruo *ReviewUpdateOne) AddLikeIDs(ids ... string) *ReviewUpdateOne {
			ruo.mutation.AddLikeIDs(ids ...)
			return ruo
		}
	
	
	
	
	
	// AddLikes adds the "likes" edges to the Like entity.
	func (ruo *ReviewUpdateOne) AddLikes(l ...*Like) *ReviewUpdateOne {
		ids := make([]string, len(l))
			for i := range l {
				ids[i] = l[i].ID
			}
			return ruo.AddLikeIDs(ids...)
	}


// Mutation returns the ReviewMutation object of the builder.
func (ruo *ReviewUpdateOne) Mutation() *ReviewMutation {
	return ruo.mutation
}






	





	
	
	// ClearUser clears the "user" edge to the User entity.
	func (ruo *ReviewUpdateOne) ClearUser() *ReviewUpdateOne {
		ruo.mutation.ClearUser()
		return ruo
	}
	

	
	
	// ClearBusiness clears the "business" edge to the Business entity.
	func (ruo *ReviewUpdateOne) ClearBusiness() *ReviewUpdateOne {
		ruo.mutation.ClearBusiness()
		return ruo
	}
	

	
	
	// ClearPlace clears the "place" edge to the Place entity.
	func (ruo *ReviewUpdateOne) ClearPlace() *ReviewUpdateOne {
		ruo.mutation.ClearPlace()
		return ruo
	}
	

	
	
	// ClearEvent clears the "event" edge to the Event entity.
	func (ruo *ReviewUpdateOne) ClearEvent() *ReviewUpdateOne {
		ruo.mutation.ClearEvent()
		return ruo
	}
	

	
	
	// ClearMedias clears all "medias" edges to the Media entity.
	func (ruo *ReviewUpdateOne) ClearMedias() *ReviewUpdateOne {
		ruo.mutation.ClearMedias()
		return ruo
	}
	
		
		
		
		
		// RemoveMediaIDs removes the "medias" edge to Media entities by IDs.
		func (ruo *ReviewUpdateOne) RemoveMediaIDs(ids ...string) *ReviewUpdateOne {
			ruo.mutation.RemoveMediaIDs(ids...)
			return ruo
		}
		
		// RemoveMedias removes "medias" edges to Media entities.
		func (ruo *ReviewUpdateOne) RemoveMedias(m ...*Media) *ReviewUpdateOne {
			ids := make([]string, len(m))
			for i := range m {
				ids[i] = m[i].ID
			}
			return ruo.RemoveMediaIDs(ids...)
		}
	

	
	
	// ClearComments clears all "comments" edges to the Comment entity.
	func (ruo *ReviewUpdateOne) ClearComments() *ReviewUpdateOne {
		ruo.mutation.ClearComments()
		return ruo
	}
	
		
		
		
		
		// RemoveCommentIDs removes the "comments" edge to Comment entities by IDs.
		func (ruo *ReviewUpdateOne) RemoveCommentIDs(ids ...string) *ReviewUpdateOne {
			ruo.mutation.RemoveCommentIDs(ids...)
			return ruo
		}
		
		// RemoveComments removes "comments" edges to Comment entities.
		func (ruo *ReviewUpdateOne) RemoveComments(c ...*Comment) *ReviewUpdateOne {
			ids := make([]string, len(c))
			for i := range c {
				ids[i] = c[i].ID
			}
			return ruo.RemoveCommentIDs(ids...)
		}
	

	
	
	// ClearLikes clears all "likes" edges to the Like entity.
	func (ruo *ReviewUpdateOne) ClearLikes() *ReviewUpdateOne {
		ruo.mutation.ClearLikes()
		return ruo
	}
	
		
		
		
		
		// RemoveLikeIDs removes the "likes" edge to Like entities by IDs.
		func (ruo *ReviewUpdateOne) RemoveLikeIDs(ids ...string) *ReviewUpdateOne {
			ruo.mutation.RemoveLikeIDs(ids...)
			return ruo
		}
		
		// RemoveLikes removes "likes" edges to Like entities.
		func (ruo *ReviewUpdateOne) RemoveLikes(l ...*Like) *ReviewUpdateOne {
			ids := make([]string, len(l))
			for i := range l {
				ids[i] = l[i].ID
			}
			return ruo.RemoveLikeIDs(ids...)
		}
	




// Where appends a list predicates to the ReviewUpdate builder.
func (ruo *ReviewUpdateOne) Where(ps ...predicate.Review) *ReviewUpdateOne {
	ruo.mutation.Where(ps...)
	return ruo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (ruo *ReviewUpdateOne) Select(field string, fields ...string) *ReviewUpdateOne {
	ruo.fields = append([]string{field}, fields...)
	return ruo
}

// Save executes the query and returns the updated Review entity.
func (ruo *ReviewUpdateOne ) Save(ctx context.Context) (*Review, error) {
	return withHooks(ctx, ruo.sqlSave, ruo.mutation, ruo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ruo *ReviewUpdateOne) SaveX(ctx context.Context) *Review {
	node, err := ruo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (ruo *ReviewUpdateOne) Exec(ctx context.Context) error {
	_, err := ruo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ruo *ReviewUpdateOne) ExecX(ctx context.Context) {
	if err := ruo.Exec(ctx); err != nil {
		panic(err)
	}
}


	









	// check runs all checks and user-defined validators on the builder.
	func (ruo *ReviewUpdateOne) check() error {
				if v, ok := ruo.mutation.Score(); ok {
					if err := review.ScoreValidator(v); err != nil {
						return &ValidationError{Name: "score", err: fmt.Errorf(`ent: validator failed for field "Review.score": %w`, err)}
					}
				}
				if _, ok := ruo.mutation.UserID(); ruo.mutation.UserCleared() && !ok {
					return errors.New(`ent: clearing a required unique edge "Review.user"`)
				}
		return nil
	}






	
	





    


func (ruo *ReviewUpdateOne) sqlSave(ctx context.Context) (_node *Review, err error) {
		if err := ruo.check(); err != nil {
			return _node, err
		}
	_spec := sqlgraph.NewUpdateSpec(review.Table, review.Columns,sqlgraph.NewFieldSpec(review.FieldID, field.TypeString))
			id, ok := ruo.mutation.ID()
			if !ok {
				return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Review.id" for update`)}
			}
			_spec.Node.ID.Value = id
			if fields := ruo.fields; len(fields) > 0 {
				_spec.Node.Columns = make([]string, 0, len(fields))
				_spec.Node.Columns = append(_spec.Node.Columns, review.FieldID)
				for _, f := range fields {
					if !review.ValidColumn(f) {
						return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
					}
					if f != review.FieldID {
						_spec.Node.Columns = append(_spec.Node.Columns, f)
					}
				}
			}
	if ps := ruo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
				if value, ok := ruo.mutation.Score(); ok {
						_spec.SetField(review.FieldScore, field.TypeFloat64, value)
				}
					if value, ok := ruo.mutation.AddedScore(); ok {
							_spec.AddField(review.FieldScore, field.TypeFloat64, value)
					}
				if value, ok := ruo.mutation.Content(); ok {
						_spec.SetField(review.FieldContent, field.TypeString, value)
				}
				if value, ok := ruo.mutation.CreatedAt(); ok {
						_spec.SetField(review.FieldCreatedAt, field.TypeTime, value)
				}
				if value, ok := ruo.mutation.LikeCount(); ok {
						_spec.SetField(review.FieldLikeCount, field.TypeInt, value)
				}
					if value, ok := ruo.mutation.AddedLikeCount(); ok {
							_spec.AddField(review.FieldLikeCount, field.TypeInt, value)
					}
				if value, ok := ruo.mutation.DislikeCount(); ok {
						_spec.SetField(review.FieldDislikeCount, field.TypeInt, value)
				}
					if value, ok := ruo.mutation.AddedDislikeCount(); ok {
							_spec.AddField(review.FieldDislikeCount, field.TypeInt, value)
					}
				if value, ok := ruo.mutation.Flag(); ok {
						_spec.SetField(review.FieldFlag, field.TypeString, value)
				}
		if ruo.mutation.UserCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: true,
		Table: review.UserTable,
		Columns: []string{ review.UserColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
		if nodes := ruo.mutation.UserIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: true,
		Table: review.UserTable,
		Columns: []string{ review.UserColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if ruo.mutation.BusinessCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: false,
		Table: review.BusinessTable,
		Columns: []string{ review.BusinessColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(business.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
		if nodes := ruo.mutation.BusinessIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: false,
		Table: review.BusinessTable,
		Columns: []string{ review.BusinessColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(business.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if ruo.mutation.PlaceCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: false,
		Table: review.PlaceTable,
		Columns: []string{ review.PlaceColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(place.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
		if nodes := ruo.mutation.PlaceIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: false,
		Table: review.PlaceTable,
		Columns: []string{ review.PlaceColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(place.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if ruo.mutation.EventCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: false,
		Table: review.EventTable,
		Columns: []string{ review.EventColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(event.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
		if nodes := ruo.mutation.EventIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2O,
		Inverse: false,
		Table: review.EventTable,
		Columns: []string{ review.EventColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(event.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if ruo.mutation.MediasCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.MediasTable,
		Columns: []string{ review.MediasColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(media.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := ruo.mutation.RemovedMediasIDs(); len(nodes) > 0 && !ruo.mutation.MediasCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.MediasTable,
		Columns: []string{ review.MediasColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(media.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := ruo.mutation.MediasIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.MediasTable,
		Columns: []string{ review.MediasColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(media.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if ruo.mutation.CommentsCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.CommentsTable,
		Columns: []string{ review.CommentsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(comment.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := ruo.mutation.RemovedCommentsIDs(); len(nodes) > 0 && !ruo.mutation.CommentsCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.CommentsTable,
		Columns: []string{ review.CommentsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(comment.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := ruo.mutation.CommentsIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.CommentsTable,
		Columns: []string{ review.CommentsColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(comment.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if ruo.mutation.LikesCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.LikesTable,
		Columns: []string{ review.LikesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(like.FieldID, field.TypeString),
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := ruo.mutation.RemovedLikesIDs(); len(nodes) > 0 && !ruo.mutation.LikesCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.LikesTable,
		Columns: []string{ review.LikesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(like.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := ruo.mutation.LikesIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.O2M,
		Inverse: false,
		Table: review.LikesTable,
		Columns: []string{ review.LikesColumn },
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: sqlgraph.NewFieldSpec(like.FieldID, field.TypeString),
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		_node = &Review{config: ruo.config}
		_spec.Assign = _node.assignValues
		_spec.ScanValues = _node.scanValues
		if err = sqlgraph.UpdateNode(ctx, ruo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{ review.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	ruo.mutation.done = true
	return _node, nil
}



