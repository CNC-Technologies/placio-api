// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"placio-app/ent/accountsettings"
	"placio-app/ent/amenity"
	"placio-app/ent/booking"
	"placio-app/ent/business"
	"placio-app/ent/businessfollowbusiness"
	"placio-app/ent/businessfollowuser"
	"placio-app/ent/category"
	"placio-app/ent/categoryassignment"
	"placio-app/ent/comment"
	"placio-app/ent/event"
	"placio-app/ent/help"
	"placio-app/ent/like"
	"placio-app/ent/media"
	"placio-app/ent/menu"
	"placio-app/ent/place"
	"placio-app/ent/post"
	"placio-app/ent/predicate"
	"placio-app/ent/reservation"
	"placio-app/ent/review"
	"placio-app/ent/room"
	"placio-app/ent/ticket"
	"placio-app/ent/ticketoption"
	"placio-app/ent/user"
	"placio-app/ent/userbusiness"
	"placio-app/ent/userfollowbusiness"
	"placio-app/ent/userfollowuser"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/auth0/go-auth0/management"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccountSettings        = "AccountSettings"
	TypeAmenity                = "Amenity"
	TypeBooking                = "Booking"
	TypeBusiness               = "Business"
	TypeBusinessFollowBusiness = "BusinessFollowBusiness"
	TypeBusinessFollowUser     = "BusinessFollowUser"
	TypeCategory               = "Category"
	TypeCategoryAssignment     = "CategoryAssignment"
	TypeChat                   = "Chat"
	TypeComment                = "Comment"
	TypeEvent                  = "Event"
	TypeHelp                   = "Help"
	TypeLike                   = "Like"
	TypeMedia                  = "Media"
	TypeMenu                   = "Menu"
	TypeOrder                  = "Order"
	TypePayment                = "Payment"
	TypePlace                  = "Place"
	TypePost                   = "Post"
	TypeRating                 = "Rating"
	TypeReaction               = "Reaction"
	TypeReservation            = "Reservation"
	TypeReview                 = "Review"
	TypeRoom                   = "Room"
	TypeTicket                 = "Ticket"
	TypeTicketOption           = "TicketOption"
	TypeUser                   = "User"
	TypeUserBusiness           = "UserBusiness"
	TypeUserFollowBusiness     = "UserFollowBusiness"
	TypeUserFollowUser         = "UserFollowUser"
)

// AccountSettingsMutation represents an operation that mutates the AccountSettings nodes in the graph.
type AccountSettingsMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	_TwoFactorAuthentication *bool
	_BlockedUsers            *[]string
	append_BlockedUsers      []string
	_MutedUsers              *[]string
	append_MutedUsers        []string
	clearedFields            map[string]struct{}
	business_account         *string
	clearedbusiness_account  bool
	done                     bool
	oldValue                 func(context.Context) (*AccountSettings, error)
	predicates               []predicate.AccountSettings
}

var _ ent.Mutation = (*AccountSettingsMutation)(nil)

// accountsettingsOption allows management of the mutation configuration using functional options.
type accountsettingsOption func(*AccountSettingsMutation)

// newAccountSettingsMutation creates new mutation for the AccountSettings entity.
func newAccountSettingsMutation(c config, op Op, opts ...accountsettingsOption) *AccountSettingsMutation {
	m := &AccountSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountSettingsID sets the ID field of the mutation.
func withAccountSettingsID(id string) accountsettingsOption {
	return func(m *AccountSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountSettings
		)
		m.oldValue = func(ctx context.Context) (*AccountSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountSettings sets the old AccountSettings of the mutation.
func withAccountSettings(node *AccountSettings) accountsettingsOption {
	return func(m *AccountSettingsMutation) {
		m.oldValue = func(context.Context) (*AccountSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountSettings entities.
func (m *AccountSettingsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountSettingsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountSettingsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTwoFactorAuthentication sets the "TwoFactorAuthentication" field.
func (m *AccountSettingsMutation) SetTwoFactorAuthentication(b bool) {
	m._TwoFactorAuthentication = &b
}

// TwoFactorAuthentication returns the value of the "TwoFactorAuthentication" field in the mutation.
func (m *AccountSettingsMutation) TwoFactorAuthentication() (r bool, exists bool) {
	v := m._TwoFactorAuthentication
	if v == nil {
		return
	}
	return *v, true
}

// OldTwoFactorAuthentication returns the old "TwoFactorAuthentication" field's value of the AccountSettings entity.
// If the AccountSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSettingsMutation) OldTwoFactorAuthentication(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwoFactorAuthentication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwoFactorAuthentication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwoFactorAuthentication: %w", err)
	}
	return oldValue.TwoFactorAuthentication, nil
}

// ResetTwoFactorAuthentication resets all changes to the "TwoFactorAuthentication" field.
func (m *AccountSettingsMutation) ResetTwoFactorAuthentication() {
	m._TwoFactorAuthentication = nil
}

// SetBlockedUsers sets the "BlockedUsers" field.
func (m *AccountSettingsMutation) SetBlockedUsers(s []string) {
	m._BlockedUsers = &s
	m.append_BlockedUsers = nil
}

// BlockedUsers returns the value of the "BlockedUsers" field in the mutation.
func (m *AccountSettingsMutation) BlockedUsers() (r []string, exists bool) {
	v := m._BlockedUsers
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockedUsers returns the old "BlockedUsers" field's value of the AccountSettings entity.
// If the AccountSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSettingsMutation) OldBlockedUsers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockedUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockedUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockedUsers: %w", err)
	}
	return oldValue.BlockedUsers, nil
}

// AppendBlockedUsers adds s to the "BlockedUsers" field.
func (m *AccountSettingsMutation) AppendBlockedUsers(s []string) {
	m.append_BlockedUsers = append(m.append_BlockedUsers, s...)
}

// AppendedBlockedUsers returns the list of values that were appended to the "BlockedUsers" field in this mutation.
func (m *AccountSettingsMutation) AppendedBlockedUsers() ([]string, bool) {
	if len(m.append_BlockedUsers) == 0 {
		return nil, false
	}
	return m.append_BlockedUsers, true
}

// ResetBlockedUsers resets all changes to the "BlockedUsers" field.
func (m *AccountSettingsMutation) ResetBlockedUsers() {
	m._BlockedUsers = nil
	m.append_BlockedUsers = nil
}

// SetMutedUsers sets the "MutedUsers" field.
func (m *AccountSettingsMutation) SetMutedUsers(s []string) {
	m._MutedUsers = &s
	m.append_MutedUsers = nil
}

// MutedUsers returns the value of the "MutedUsers" field in the mutation.
func (m *AccountSettingsMutation) MutedUsers() (r []string, exists bool) {
	v := m._MutedUsers
	if v == nil {
		return
	}
	return *v, true
}

// OldMutedUsers returns the old "MutedUsers" field's value of the AccountSettings entity.
// If the AccountSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSettingsMutation) OldMutedUsers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMutedUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMutedUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMutedUsers: %w", err)
	}
	return oldValue.MutedUsers, nil
}

// AppendMutedUsers adds s to the "MutedUsers" field.
func (m *AccountSettingsMutation) AppendMutedUsers(s []string) {
	m.append_MutedUsers = append(m.append_MutedUsers, s...)
}

// AppendedMutedUsers returns the list of values that were appended to the "MutedUsers" field in this mutation.
func (m *AccountSettingsMutation) AppendedMutedUsers() ([]string, bool) {
	if len(m.append_MutedUsers) == 0 {
		return nil, false
	}
	return m.append_MutedUsers, true
}

// ResetMutedUsers resets all changes to the "MutedUsers" field.
func (m *AccountSettingsMutation) ResetMutedUsers() {
	m._MutedUsers = nil
	m.append_MutedUsers = nil
}

// SetBusinessAccountID sets the "business_account" edge to the Business entity by id.
func (m *AccountSettingsMutation) SetBusinessAccountID(id string) {
	m.business_account = &id
}

// ClearBusinessAccount clears the "business_account" edge to the Business entity.
func (m *AccountSettingsMutation) ClearBusinessAccount() {
	m.clearedbusiness_account = true
}

// BusinessAccountCleared reports if the "business_account" edge to the Business entity was cleared.
func (m *AccountSettingsMutation) BusinessAccountCleared() bool {
	return m.clearedbusiness_account
}

// BusinessAccountID returns the "business_account" edge ID in the mutation.
func (m *AccountSettingsMutation) BusinessAccountID() (id string, exists bool) {
	if m.business_account != nil {
		return *m.business_account, true
	}
	return
}

// BusinessAccountIDs returns the "business_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessAccountID instead. It exists only for internal usage by the builders.
func (m *AccountSettingsMutation) BusinessAccountIDs() (ids []string) {
	if id := m.business_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessAccount resets all changes to the "business_account" edge.
func (m *AccountSettingsMutation) ResetBusinessAccount() {
	m.business_account = nil
	m.clearedbusiness_account = false
}

// Where appends a list predicates to the AccountSettingsMutation builder.
func (m *AccountSettingsMutation) Where(ps ...predicate.AccountSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountSettings).
func (m *AccountSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountSettingsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._TwoFactorAuthentication != nil {
		fields = append(fields, accountsettings.FieldTwoFactorAuthentication)
	}
	if m._BlockedUsers != nil {
		fields = append(fields, accountsettings.FieldBlockedUsers)
	}
	if m._MutedUsers != nil {
		fields = append(fields, accountsettings.FieldMutedUsers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountsettings.FieldTwoFactorAuthentication:
		return m.TwoFactorAuthentication()
	case accountsettings.FieldBlockedUsers:
		return m.BlockedUsers()
	case accountsettings.FieldMutedUsers:
		return m.MutedUsers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountsettings.FieldTwoFactorAuthentication:
		return m.OldTwoFactorAuthentication(ctx)
	case accountsettings.FieldBlockedUsers:
		return m.OldBlockedUsers(ctx)
	case accountsettings.FieldMutedUsers:
		return m.OldMutedUsers(ctx)
	}
	return nil, fmt.Errorf("unknown AccountSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountsettings.FieldTwoFactorAuthentication:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwoFactorAuthentication(v)
		return nil
	case accountsettings.FieldBlockedUsers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockedUsers(v)
		return nil
	case accountsettings.FieldMutedUsers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMutedUsers(v)
		return nil
	}
	return fmt.Errorf("unknown AccountSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccountSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountSettingsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountSettingsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountSettingsMutation) ResetField(name string) error {
	switch name {
	case accountsettings.FieldTwoFactorAuthentication:
		m.ResetTwoFactorAuthentication()
		return nil
	case accountsettings.FieldBlockedUsers:
		m.ResetBlockedUsers()
		return nil
	case accountsettings.FieldMutedUsers:
		m.ResetMutedUsers()
		return nil
	}
	return fmt.Errorf("unknown AccountSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.business_account != nil {
		edges = append(edges, accountsettings.EdgeBusinessAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountSettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountsettings.EdgeBusinessAccount:
		if id := m.business_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbusiness_account {
		edges = append(edges, accountsettings.EdgeBusinessAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountSettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case accountsettings.EdgeBusinessAccount:
		return m.clearedbusiness_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountSettingsMutation) ClearEdge(name string) error {
	switch name {
	case accountsettings.EdgeBusinessAccount:
		m.ClearBusinessAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountSettingsMutation) ResetEdge(name string) error {
	switch name {
	case accountsettings.EdgeBusinessAccount:
		m.ResetBusinessAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountSettings edge %s", name)
}

// AmenityMutation represents an operation that mutates the Amenity nodes in the graph.
type AmenityMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	icon          *string
	clearedFields map[string]struct{}
	places        map[string]struct{}
	removedplaces map[string]struct{}
	clearedplaces bool
	done          bool
	oldValue      func(context.Context) (*Amenity, error)
	predicates    []predicate.Amenity
}

var _ ent.Mutation = (*AmenityMutation)(nil)

// amenityOption allows management of the mutation configuration using functional options.
type amenityOption func(*AmenityMutation)

// newAmenityMutation creates new mutation for the Amenity entity.
func newAmenityMutation(c config, op Op, opts ...amenityOption) *AmenityMutation {
	m := &AmenityMutation{
		config:        c,
		op:            op,
		typ:           TypeAmenity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAmenityID sets the ID field of the mutation.
func withAmenityID(id string) amenityOption {
	return func(m *AmenityMutation) {
		var (
			err   error
			once  sync.Once
			value *Amenity
		)
		m.oldValue = func(ctx context.Context) (*Amenity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Amenity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAmenity sets the old Amenity of the mutation.
func withAmenity(node *Amenity) amenityOption {
	return func(m *AmenityMutation) {
		m.oldValue = func(context.Context) (*Amenity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AmenityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AmenityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Amenity entities.
func (m *AmenityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AmenityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AmenityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Amenity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AmenityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AmenityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Amenity entity.
// If the Amenity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmenityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AmenityMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *AmenityMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *AmenityMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Amenity entity.
// If the Amenity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmenityMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *AmenityMutation) ResetIcon() {
	m.icon = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *AmenityMutation) AddPlaceIDs(ids ...string) {
	if m.places == nil {
		m.places = make(map[string]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *AmenityMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the Place entity was cleared.
func (m *AmenityMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *AmenityMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *AmenityMutation) RemovedPlacesIDs() (ids []string) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *AmenityMutation) PlacesIDs() (ids []string) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *AmenityMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// Where appends a list predicates to the AmenityMutation builder.
func (m *AmenityMutation) Where(ps ...predicate.Amenity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AmenityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AmenityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Amenity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AmenityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AmenityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Amenity).
func (m *AmenityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AmenityMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, amenity.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, amenity.FieldIcon)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AmenityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case amenity.FieldName:
		return m.Name()
	case amenity.FieldIcon:
		return m.Icon()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AmenityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case amenity.FieldName:
		return m.OldName(ctx)
	case amenity.FieldIcon:
		return m.OldIcon(ctx)
	}
	return nil, fmt.Errorf("unknown Amenity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmenityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case amenity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case amenity.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	}
	return fmt.Errorf("unknown Amenity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AmenityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AmenityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmenityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Amenity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AmenityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AmenityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AmenityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Amenity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AmenityMutation) ResetField(name string) error {
	switch name {
	case amenity.FieldName:
		m.ResetName()
		return nil
	case amenity.FieldIcon:
		m.ResetIcon()
		return nil
	}
	return fmt.Errorf("unknown Amenity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AmenityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.places != nil {
		edges = append(edges, amenity.EdgePlaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AmenityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case amenity.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AmenityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplaces != nil {
		edges = append(edges, amenity.EdgePlaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AmenityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case amenity.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AmenityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplaces {
		edges = append(edges, amenity.EdgePlaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AmenityMutation) EdgeCleared(name string) bool {
	switch name {
	case amenity.EdgePlaces:
		return m.clearedplaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AmenityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Amenity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AmenityMutation) ResetEdge(name string) error {
	switch name {
	case amenity.EdgePlaces:
		m.ResetPlaces()
		return nil
	}
	return fmt.Errorf("unknown Amenity edge %s", name)
}

// BookingMutation represents an operation that mutates the Booking nodes in the graph.
type BookingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	startDate     *time.Time
	endDate       *time.Time
	status        *string
	bookingDate   *time.Time
	clearedFields map[string]struct{}
	room          *string
	clearedroom   bool
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Booking, error)
	predicates    []predicate.Booking
}

var _ ent.Mutation = (*BookingMutation)(nil)

// bookingOption allows management of the mutation configuration using functional options.
type bookingOption func(*BookingMutation)

// newBookingMutation creates new mutation for the Booking entity.
func newBookingMutation(c config, op Op, opts ...bookingOption) *BookingMutation {
	m := &BookingMutation{
		config:        c,
		op:            op,
		typ:           TypeBooking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingID sets the ID field of the mutation.
func withBookingID(id string) bookingOption {
	return func(m *BookingMutation) {
		var (
			err   error
			once  sync.Once
			value *Booking
		)
		m.oldValue = func(ctx context.Context) (*Booking, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Booking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBooking sets the old Booking of the mutation.
func withBooking(node *Booking) bookingOption {
	return func(m *BookingMutation) {
		m.oldValue = func(context.Context) (*Booking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Booking entities.
func (m *BookingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Booking.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartDate sets the "startDate" field.
func (m *BookingMutation) SetStartDate(t time.Time) {
	m.startDate = &t
}

// StartDate returns the value of the "startDate" field in the mutation.
func (m *BookingMutation) StartDate() (r time.Time, exists bool) {
	v := m.startDate
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "startDate" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "startDate" field.
func (m *BookingMutation) ResetStartDate() {
	m.startDate = nil
}

// SetEndDate sets the "endDate" field.
func (m *BookingMutation) SetEndDate(t time.Time) {
	m.endDate = &t
}

// EndDate returns the value of the "endDate" field in the mutation.
func (m *BookingMutation) EndDate() (r time.Time, exists bool) {
	v := m.endDate
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "endDate" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "endDate" field.
func (m *BookingMutation) ResetEndDate() {
	m.endDate = nil
}

// SetStatus sets the "status" field.
func (m *BookingMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *BookingMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BookingMutation) ResetStatus() {
	m.status = nil
}

// SetBookingDate sets the "bookingDate" field.
func (m *BookingMutation) SetBookingDate(t time.Time) {
	m.bookingDate = &t
}

// BookingDate returns the value of the "bookingDate" field in the mutation.
func (m *BookingMutation) BookingDate() (r time.Time, exists bool) {
	v := m.bookingDate
	if v == nil {
		return
	}
	return *v, true
}

// OldBookingDate returns the old "bookingDate" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldBookingDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookingDate: %w", err)
	}
	return oldValue.BookingDate, nil
}

// ResetBookingDate resets all changes to the "bookingDate" field.
func (m *BookingMutation) ResetBookingDate() {
	m.bookingDate = nil
}

// SetRoomID sets the "room" edge to the Room entity by id.
func (m *BookingMutation) SetRoomID(id string) {
	m.room = &id
}

// ClearRoom clears the "room" edge to the Room entity.
func (m *BookingMutation) ClearRoom() {
	m.clearedroom = true
}

// RoomCleared reports if the "room" edge to the Room entity was cleared.
func (m *BookingMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomID returns the "room" edge ID in the mutation.
func (m *BookingMutation) RoomID() (id string, exists bool) {
	if m.room != nil {
		return *m.room, true
	}
	return
}

// RoomIDs returns the "room" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) RoomIDs() (ids []string) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom resets all changes to the "room" edge.
func (m *BookingMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *BookingMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *BookingMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BookingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *BookingMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BookingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the BookingMutation builder.
func (m *BookingMutation) Where(ps ...predicate.Booking) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Booking, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Booking).
func (m *BookingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookingMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.startDate != nil {
		fields = append(fields, booking.FieldStartDate)
	}
	if m.endDate != nil {
		fields = append(fields, booking.FieldEndDate)
	}
	if m.status != nil {
		fields = append(fields, booking.FieldStatus)
	}
	if m.bookingDate != nil {
		fields = append(fields, booking.FieldBookingDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldStartDate:
		return m.StartDate()
	case booking.FieldEndDate:
		return m.EndDate()
	case booking.FieldStatus:
		return m.Status()
	case booking.FieldBookingDate:
		return m.BookingDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case booking.FieldStartDate:
		return m.OldStartDate(ctx)
	case booking.FieldEndDate:
		return m.OldEndDate(ctx)
	case booking.FieldStatus:
		return m.OldStatus(ctx)
	case booking.FieldBookingDate:
		return m.OldBookingDate(ctx)
	}
	return nil, fmt.Errorf("unknown Booking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case booking.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case booking.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case booking.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case booking.FieldBookingDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookingDate(v)
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Booking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Booking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookingMutation) ResetField(name string) error {
	switch name {
	case booking.FieldStartDate:
		m.ResetStartDate()
		return nil
	case booking.FieldEndDate:
		m.ResetEndDate()
		return nil
	case booking.FieldStatus:
		m.ResetStatus()
		return nil
	case booking.FieldBookingDate:
		m.ResetBookingDate()
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.room != nil {
		edges = append(edges, booking.EdgeRoom)
	}
	if m.user != nil {
		edges = append(edges, booking.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case booking.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroom {
		edges = append(edges, booking.EdgeRoom)
	}
	if m.cleareduser {
		edges = append(edges, booking.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookingMutation) EdgeCleared(name string) bool {
	switch name {
	case booking.EdgeRoom:
		return m.clearedroom
	case booking.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookingMutation) ClearEdge(name string) error {
	switch name {
	case booking.EdgeRoom:
		m.ClearRoom()
		return nil
	case booking.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Booking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookingMutation) ResetEdge(name string) error {
	switch name {
	case booking.EdgeRoom:
		m.ResetRoom()
		return nil
	case booking.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Booking edge %s", name)
}

// BusinessMutation represents an operation that mutates the Business nodes in the graph.
type BusinessMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	name                             *string
	search_text                      *string
	relevance_score                  *float64
	addrelevance_score               *float64
	clearedFields                    map[string]struct{}
	userBusinesses                   map[string]struct{}
	removeduserBusinesses            map[string]struct{}
	cleareduserBusinesses            bool
	business_account_settings        *string
	clearedbusiness_account_settings bool
	posts                            map[string]struct{}
	removedposts                     map[string]struct{}
	clearedposts                     bool
	followedUsers                    map[string]struct{}
	removedfollowedUsers             map[string]struct{}
	clearedfollowedUsers             bool
	followerUsers                    map[string]struct{}
	removedfollowerUsers             map[string]struct{}
	clearedfollowerUsers             bool
	followedBusinesses               map[string]struct{}
	removedfollowedBusinesses        map[string]struct{}
	clearedfollowedBusinesses        bool
	followerBusinesses               map[string]struct{}
	removedfollowerBusinesses        map[string]struct{}
	clearedfollowerBusinesses        bool
	places                           map[string]struct{}
	removedplaces                    map[string]struct{}
	clearedplaces                    bool
	categories                       map[string]struct{}
	removedcategories                map[string]struct{}
	clearedcategories                bool
	categoryAssignments              map[string]struct{}
	removedcategoryAssignments       map[string]struct{}
	clearedcategoryAssignments       bool
	done                             bool
	oldValue                         func(context.Context) (*Business, error)
	predicates                       []predicate.Business
}

var _ ent.Mutation = (*BusinessMutation)(nil)

// businessOption allows management of the mutation configuration using functional options.
type businessOption func(*BusinessMutation)

// newBusinessMutation creates new mutation for the Business entity.
func newBusinessMutation(c config, op Op, opts ...businessOption) *BusinessMutation {
	m := &BusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessID sets the ID field of the mutation.
func withBusinessID(id string) businessOption {
	return func(m *BusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *Business
		)
		m.oldValue = func(ctx context.Context) (*Business, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Business.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusiness sets the old Business of the mutation.
func withBusiness(node *Business) businessOption {
	return func(m *BusinessMutation) {
		m.oldValue = func(context.Context) (*Business, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Business entities.
func (m *BusinessMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Business.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BusinessMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BusinessMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BusinessMutation) ResetName() {
	m.name = nil
}

// SetSearchText sets the "search_text" field.
func (m *BusinessMutation) SetSearchText(s string) {
	m.search_text = &s
}

// SearchText returns the value of the "search_text" field in the mutation.
func (m *BusinessMutation) SearchText() (r string, exists bool) {
	v := m.search_text
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchText returns the old "search_text" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldSearchText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchText: %w", err)
	}
	return oldValue.SearchText, nil
}

// ClearSearchText clears the value of the "search_text" field.
func (m *BusinessMutation) ClearSearchText() {
	m.search_text = nil
	m.clearedFields[business.FieldSearchText] = struct{}{}
}

// SearchTextCleared returns if the "search_text" field was cleared in this mutation.
func (m *BusinessMutation) SearchTextCleared() bool {
	_, ok := m.clearedFields[business.FieldSearchText]
	return ok
}

// ResetSearchText resets all changes to the "search_text" field.
func (m *BusinessMutation) ResetSearchText() {
	m.search_text = nil
	delete(m.clearedFields, business.FieldSearchText)
}

// SetRelevanceScore sets the "relevance_score" field.
func (m *BusinessMutation) SetRelevanceScore(f float64) {
	m.relevance_score = &f
	m.addrelevance_score = nil
}

// RelevanceScore returns the value of the "relevance_score" field in the mutation.
func (m *BusinessMutation) RelevanceScore() (r float64, exists bool) {
	v := m.relevance_score
	if v == nil {
		return
	}
	return *v, true
}

// OldRelevanceScore returns the old "relevance_score" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldRelevanceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelevanceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelevanceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelevanceScore: %w", err)
	}
	return oldValue.RelevanceScore, nil
}

// AddRelevanceScore adds f to the "relevance_score" field.
func (m *BusinessMutation) AddRelevanceScore(f float64) {
	if m.addrelevance_score != nil {
		*m.addrelevance_score += f
	} else {
		m.addrelevance_score = &f
	}
}

// AddedRelevanceScore returns the value that was added to the "relevance_score" field in this mutation.
func (m *BusinessMutation) AddedRelevanceScore() (r float64, exists bool) {
	v := m.addrelevance_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelevanceScore clears the value of the "relevance_score" field.
func (m *BusinessMutation) ClearRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	m.clearedFields[business.FieldRelevanceScore] = struct{}{}
}

// RelevanceScoreCleared returns if the "relevance_score" field was cleared in this mutation.
func (m *BusinessMutation) RelevanceScoreCleared() bool {
	_, ok := m.clearedFields[business.FieldRelevanceScore]
	return ok
}

// ResetRelevanceScore resets all changes to the "relevance_score" field.
func (m *BusinessMutation) ResetRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	delete(m.clearedFields, business.FieldRelevanceScore)
}

// AddUserBusinessIDs adds the "userBusinesses" edge to the UserBusiness entity by ids.
func (m *BusinessMutation) AddUserBusinessIDs(ids ...string) {
	if m.userBusinesses == nil {
		m.userBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		m.userBusinesses[ids[i]] = struct{}{}
	}
}

// ClearUserBusinesses clears the "userBusinesses" edge to the UserBusiness entity.
func (m *BusinessMutation) ClearUserBusinesses() {
	m.cleareduserBusinesses = true
}

// UserBusinessesCleared reports if the "userBusinesses" edge to the UserBusiness entity was cleared.
func (m *BusinessMutation) UserBusinessesCleared() bool {
	return m.cleareduserBusinesses
}

// RemoveUserBusinessIDs removes the "userBusinesses" edge to the UserBusiness entity by IDs.
func (m *BusinessMutation) RemoveUserBusinessIDs(ids ...string) {
	if m.removeduserBusinesses == nil {
		m.removeduserBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.userBusinesses, ids[i])
		m.removeduserBusinesses[ids[i]] = struct{}{}
	}
}

// RemovedUserBusinesses returns the removed IDs of the "userBusinesses" edge to the UserBusiness entity.
func (m *BusinessMutation) RemovedUserBusinessesIDs() (ids []string) {
	for id := range m.removeduserBusinesses {
		ids = append(ids, id)
	}
	return
}

// UserBusinessesIDs returns the "userBusinesses" edge IDs in the mutation.
func (m *BusinessMutation) UserBusinessesIDs() (ids []string) {
	for id := range m.userBusinesses {
		ids = append(ids, id)
	}
	return
}

// ResetUserBusinesses resets all changes to the "userBusinesses" edge.
func (m *BusinessMutation) ResetUserBusinesses() {
	m.userBusinesses = nil
	m.cleareduserBusinesses = false
	m.removeduserBusinesses = nil
}

// SetBusinessAccountSettingsID sets the "business_account_settings" edge to the AccountSettings entity by id.
func (m *BusinessMutation) SetBusinessAccountSettingsID(id string) {
	m.business_account_settings = &id
}

// ClearBusinessAccountSettings clears the "business_account_settings" edge to the AccountSettings entity.
func (m *BusinessMutation) ClearBusinessAccountSettings() {
	m.clearedbusiness_account_settings = true
}

// BusinessAccountSettingsCleared reports if the "business_account_settings" edge to the AccountSettings entity was cleared.
func (m *BusinessMutation) BusinessAccountSettingsCleared() bool {
	return m.clearedbusiness_account_settings
}

// BusinessAccountSettingsID returns the "business_account_settings" edge ID in the mutation.
func (m *BusinessMutation) BusinessAccountSettingsID() (id string, exists bool) {
	if m.business_account_settings != nil {
		return *m.business_account_settings, true
	}
	return
}

// BusinessAccountSettingsIDs returns the "business_account_settings" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessAccountSettingsID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) BusinessAccountSettingsIDs() (ids []string) {
	if id := m.business_account_settings; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessAccountSettings resets all changes to the "business_account_settings" edge.
func (m *BusinessMutation) ResetBusinessAccountSettings() {
	m.business_account_settings = nil
	m.clearedbusiness_account_settings = false
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *BusinessMutation) AddPostIDs(ids ...string) {
	if m.posts == nil {
		m.posts = make(map[string]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *BusinessMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *BusinessMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *BusinessMutation) RemovePostIDs(ids ...string) {
	if m.removedposts == nil {
		m.removedposts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *BusinessMutation) RemovedPostsIDs() (ids []string) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *BusinessMutation) PostsIDs() (ids []string) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *BusinessMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddFollowedUserIDs adds the "followedUsers" edge to the BusinessFollowUser entity by ids.
func (m *BusinessMutation) AddFollowedUserIDs(ids ...string) {
	if m.followedUsers == nil {
		m.followedUsers = make(map[string]struct{})
	}
	for i := range ids {
		m.followedUsers[ids[i]] = struct{}{}
	}
}

// ClearFollowedUsers clears the "followedUsers" edge to the BusinessFollowUser entity.
func (m *BusinessMutation) ClearFollowedUsers() {
	m.clearedfollowedUsers = true
}

// FollowedUsersCleared reports if the "followedUsers" edge to the BusinessFollowUser entity was cleared.
func (m *BusinessMutation) FollowedUsersCleared() bool {
	return m.clearedfollowedUsers
}

// RemoveFollowedUserIDs removes the "followedUsers" edge to the BusinessFollowUser entity by IDs.
func (m *BusinessMutation) RemoveFollowedUserIDs(ids ...string) {
	if m.removedfollowedUsers == nil {
		m.removedfollowedUsers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followedUsers, ids[i])
		m.removedfollowedUsers[ids[i]] = struct{}{}
	}
}

// RemovedFollowedUsers returns the removed IDs of the "followedUsers" edge to the BusinessFollowUser entity.
func (m *BusinessMutation) RemovedFollowedUsersIDs() (ids []string) {
	for id := range m.removedfollowedUsers {
		ids = append(ids, id)
	}
	return
}

// FollowedUsersIDs returns the "followedUsers" edge IDs in the mutation.
func (m *BusinessMutation) FollowedUsersIDs() (ids []string) {
	for id := range m.followedUsers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedUsers resets all changes to the "followedUsers" edge.
func (m *BusinessMutation) ResetFollowedUsers() {
	m.followedUsers = nil
	m.clearedfollowedUsers = false
	m.removedfollowedUsers = nil
}

// AddFollowerUserIDs adds the "followerUsers" edge to the UserFollowBusiness entity by ids.
func (m *BusinessMutation) AddFollowerUserIDs(ids ...string) {
	if m.followerUsers == nil {
		m.followerUsers = make(map[string]struct{})
	}
	for i := range ids {
		m.followerUsers[ids[i]] = struct{}{}
	}
}

// ClearFollowerUsers clears the "followerUsers" edge to the UserFollowBusiness entity.
func (m *BusinessMutation) ClearFollowerUsers() {
	m.clearedfollowerUsers = true
}

// FollowerUsersCleared reports if the "followerUsers" edge to the UserFollowBusiness entity was cleared.
func (m *BusinessMutation) FollowerUsersCleared() bool {
	return m.clearedfollowerUsers
}

// RemoveFollowerUserIDs removes the "followerUsers" edge to the UserFollowBusiness entity by IDs.
func (m *BusinessMutation) RemoveFollowerUserIDs(ids ...string) {
	if m.removedfollowerUsers == nil {
		m.removedfollowerUsers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followerUsers, ids[i])
		m.removedfollowerUsers[ids[i]] = struct{}{}
	}
}

// RemovedFollowerUsers returns the removed IDs of the "followerUsers" edge to the UserFollowBusiness entity.
func (m *BusinessMutation) RemovedFollowerUsersIDs() (ids []string) {
	for id := range m.removedfollowerUsers {
		ids = append(ids, id)
	}
	return
}

// FollowerUsersIDs returns the "followerUsers" edge IDs in the mutation.
func (m *BusinessMutation) FollowerUsersIDs() (ids []string) {
	for id := range m.followerUsers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowerUsers resets all changes to the "followerUsers" edge.
func (m *BusinessMutation) ResetFollowerUsers() {
	m.followerUsers = nil
	m.clearedfollowerUsers = false
	m.removedfollowerUsers = nil
}

// AddFollowedBusinessIDs adds the "followedBusinesses" edge to the BusinessFollowBusiness entity by ids.
func (m *BusinessMutation) AddFollowedBusinessIDs(ids ...string) {
	if m.followedBusinesses == nil {
		m.followedBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		m.followedBusinesses[ids[i]] = struct{}{}
	}
}

// ClearFollowedBusinesses clears the "followedBusinesses" edge to the BusinessFollowBusiness entity.
func (m *BusinessMutation) ClearFollowedBusinesses() {
	m.clearedfollowedBusinesses = true
}

// FollowedBusinessesCleared reports if the "followedBusinesses" edge to the BusinessFollowBusiness entity was cleared.
func (m *BusinessMutation) FollowedBusinessesCleared() bool {
	return m.clearedfollowedBusinesses
}

// RemoveFollowedBusinessIDs removes the "followedBusinesses" edge to the BusinessFollowBusiness entity by IDs.
func (m *BusinessMutation) RemoveFollowedBusinessIDs(ids ...string) {
	if m.removedfollowedBusinesses == nil {
		m.removedfollowedBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followedBusinesses, ids[i])
		m.removedfollowedBusinesses[ids[i]] = struct{}{}
	}
}

// RemovedFollowedBusinesses returns the removed IDs of the "followedBusinesses" edge to the BusinessFollowBusiness entity.
func (m *BusinessMutation) RemovedFollowedBusinessesIDs() (ids []string) {
	for id := range m.removedfollowedBusinesses {
		ids = append(ids, id)
	}
	return
}

// FollowedBusinessesIDs returns the "followedBusinesses" edge IDs in the mutation.
func (m *BusinessMutation) FollowedBusinessesIDs() (ids []string) {
	for id := range m.followedBusinesses {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedBusinesses resets all changes to the "followedBusinesses" edge.
func (m *BusinessMutation) ResetFollowedBusinesses() {
	m.followedBusinesses = nil
	m.clearedfollowedBusinesses = false
	m.removedfollowedBusinesses = nil
}

// AddFollowerBusinessIDs adds the "followerBusinesses" edge to the BusinessFollowBusiness entity by ids.
func (m *BusinessMutation) AddFollowerBusinessIDs(ids ...string) {
	if m.followerBusinesses == nil {
		m.followerBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		m.followerBusinesses[ids[i]] = struct{}{}
	}
}

// ClearFollowerBusinesses clears the "followerBusinesses" edge to the BusinessFollowBusiness entity.
func (m *BusinessMutation) ClearFollowerBusinesses() {
	m.clearedfollowerBusinesses = true
}

// FollowerBusinessesCleared reports if the "followerBusinesses" edge to the BusinessFollowBusiness entity was cleared.
func (m *BusinessMutation) FollowerBusinessesCleared() bool {
	return m.clearedfollowerBusinesses
}

// RemoveFollowerBusinessIDs removes the "followerBusinesses" edge to the BusinessFollowBusiness entity by IDs.
func (m *BusinessMutation) RemoveFollowerBusinessIDs(ids ...string) {
	if m.removedfollowerBusinesses == nil {
		m.removedfollowerBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followerBusinesses, ids[i])
		m.removedfollowerBusinesses[ids[i]] = struct{}{}
	}
}

// RemovedFollowerBusinesses returns the removed IDs of the "followerBusinesses" edge to the BusinessFollowBusiness entity.
func (m *BusinessMutation) RemovedFollowerBusinessesIDs() (ids []string) {
	for id := range m.removedfollowerBusinesses {
		ids = append(ids, id)
	}
	return
}

// FollowerBusinessesIDs returns the "followerBusinesses" edge IDs in the mutation.
func (m *BusinessMutation) FollowerBusinessesIDs() (ids []string) {
	for id := range m.followerBusinesses {
		ids = append(ids, id)
	}
	return
}

// ResetFollowerBusinesses resets all changes to the "followerBusinesses" edge.
func (m *BusinessMutation) ResetFollowerBusinesses() {
	m.followerBusinesses = nil
	m.clearedfollowerBusinesses = false
	m.removedfollowerBusinesses = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *BusinessMutation) AddPlaceIDs(ids ...string) {
	if m.places == nil {
		m.places = make(map[string]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *BusinessMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the Place entity was cleared.
func (m *BusinessMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *BusinessMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *BusinessMutation) RemovedPlacesIDs() (ids []string) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *BusinessMutation) PlacesIDs() (ids []string) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *BusinessMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *BusinessMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *BusinessMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *BusinessMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *BusinessMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *BusinessMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *BusinessMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *BusinessMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddCategoryAssignmentIDs adds the "categoryAssignments" edge to the CategoryAssignment entity by ids.
func (m *BusinessMutation) AddCategoryAssignmentIDs(ids ...string) {
	if m.categoryAssignments == nil {
		m.categoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		m.categoryAssignments[ids[i]] = struct{}{}
	}
}

// ClearCategoryAssignments clears the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *BusinessMutation) ClearCategoryAssignments() {
	m.clearedcategoryAssignments = true
}

// CategoryAssignmentsCleared reports if the "categoryAssignments" edge to the CategoryAssignment entity was cleared.
func (m *BusinessMutation) CategoryAssignmentsCleared() bool {
	return m.clearedcategoryAssignments
}

// RemoveCategoryAssignmentIDs removes the "categoryAssignments" edge to the CategoryAssignment entity by IDs.
func (m *BusinessMutation) RemoveCategoryAssignmentIDs(ids ...string) {
	if m.removedcategoryAssignments == nil {
		m.removedcategoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categoryAssignments, ids[i])
		m.removedcategoryAssignments[ids[i]] = struct{}{}
	}
}

// RemovedCategoryAssignments returns the removed IDs of the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *BusinessMutation) RemovedCategoryAssignmentsIDs() (ids []string) {
	for id := range m.removedcategoryAssignments {
		ids = append(ids, id)
	}
	return
}

// CategoryAssignmentsIDs returns the "categoryAssignments" edge IDs in the mutation.
func (m *BusinessMutation) CategoryAssignmentsIDs() (ids []string) {
	for id := range m.categoryAssignments {
		ids = append(ids, id)
	}
	return
}

// ResetCategoryAssignments resets all changes to the "categoryAssignments" edge.
func (m *BusinessMutation) ResetCategoryAssignments() {
	m.categoryAssignments = nil
	m.clearedcategoryAssignments = false
	m.removedcategoryAssignments = nil
}

// Where appends a list predicates to the BusinessMutation builder.
func (m *BusinessMutation) Where(ps ...predicate.Business) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Business, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Business).
func (m *BusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, business.FieldName)
	}
	if m.search_text != nil {
		fields = append(fields, business.FieldSearchText)
	}
	if m.relevance_score != nil {
		fields = append(fields, business.FieldRelevanceScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case business.FieldName:
		return m.Name()
	case business.FieldSearchText:
		return m.SearchText()
	case business.FieldRelevanceScore:
		return m.RelevanceScore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case business.FieldName:
		return m.OldName(ctx)
	case business.FieldSearchText:
		return m.OldSearchText(ctx)
	case business.FieldRelevanceScore:
		return m.OldRelevanceScore(ctx)
	}
	return nil, fmt.Errorf("unknown Business field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case business.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case business.FieldSearchText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchText(v)
		return nil
	case business.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelevanceScore(v)
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessMutation) AddedFields() []string {
	var fields []string
	if m.addrelevance_score != nil {
		fields = append(fields, business.FieldRelevanceScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case business.FieldRelevanceScore:
		return m.AddedRelevanceScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) AddField(name string, value ent.Value) error {
	switch name {
	case business.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelevanceScore(v)
		return nil
	}
	return fmt.Errorf("unknown Business numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(business.FieldSearchText) {
		fields = append(fields, business.FieldSearchText)
	}
	if m.FieldCleared(business.FieldRelevanceScore) {
		fields = append(fields, business.FieldRelevanceScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessMutation) ClearField(name string) error {
	switch name {
	case business.FieldSearchText:
		m.ClearSearchText()
		return nil
	case business.FieldRelevanceScore:
		m.ClearRelevanceScore()
		return nil
	}
	return fmt.Errorf("unknown Business nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessMutation) ResetField(name string) error {
	switch name {
	case business.FieldName:
		m.ResetName()
		return nil
	case business.FieldSearchText:
		m.ResetSearchText()
		return nil
	case business.FieldRelevanceScore:
		m.ResetRelevanceScore()
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.userBusinesses != nil {
		edges = append(edges, business.EdgeUserBusinesses)
	}
	if m.business_account_settings != nil {
		edges = append(edges, business.EdgeBusinessAccountSettings)
	}
	if m.posts != nil {
		edges = append(edges, business.EdgePosts)
	}
	if m.followedUsers != nil {
		edges = append(edges, business.EdgeFollowedUsers)
	}
	if m.followerUsers != nil {
		edges = append(edges, business.EdgeFollowerUsers)
	}
	if m.followedBusinesses != nil {
		edges = append(edges, business.EdgeFollowedBusinesses)
	}
	if m.followerBusinesses != nil {
		edges = append(edges, business.EdgeFollowerBusinesses)
	}
	if m.places != nil {
		edges = append(edges, business.EdgePlaces)
	}
	if m.categories != nil {
		edges = append(edges, business.EdgeCategories)
	}
	if m.categoryAssignments != nil {
		edges = append(edges, business.EdgeCategoryAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case business.EdgeUserBusinesses:
		ids := make([]ent.Value, 0, len(m.userBusinesses))
		for id := range m.userBusinesses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeBusinessAccountSettings:
		if id := m.business_account_settings; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowedUsers:
		ids := make([]ent.Value, 0, len(m.followedUsers))
		for id := range m.followedUsers {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowerUsers:
		ids := make([]ent.Value, 0, len(m.followerUsers))
		for id := range m.followerUsers {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowedBusinesses:
		ids := make([]ent.Value, 0, len(m.followedBusinesses))
		for id := range m.followedBusinesses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowerBusinesses:
		ids := make([]ent.Value, 0, len(m.followerBusinesses))
		for id := range m.followerBusinesses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.categoryAssignments))
		for id := range m.categoryAssignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removeduserBusinesses != nil {
		edges = append(edges, business.EdgeUserBusinesses)
	}
	if m.removedposts != nil {
		edges = append(edges, business.EdgePosts)
	}
	if m.removedfollowedUsers != nil {
		edges = append(edges, business.EdgeFollowedUsers)
	}
	if m.removedfollowerUsers != nil {
		edges = append(edges, business.EdgeFollowerUsers)
	}
	if m.removedfollowedBusinesses != nil {
		edges = append(edges, business.EdgeFollowedBusinesses)
	}
	if m.removedfollowerBusinesses != nil {
		edges = append(edges, business.EdgeFollowerBusinesses)
	}
	if m.removedplaces != nil {
		edges = append(edges, business.EdgePlaces)
	}
	if m.removedcategories != nil {
		edges = append(edges, business.EdgeCategories)
	}
	if m.removedcategoryAssignments != nil {
		edges = append(edges, business.EdgeCategoryAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case business.EdgeUserBusinesses:
		ids := make([]ent.Value, 0, len(m.removeduserBusinesses))
		for id := range m.removeduserBusinesses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowedUsers:
		ids := make([]ent.Value, 0, len(m.removedfollowedUsers))
		for id := range m.removedfollowedUsers {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowerUsers:
		ids := make([]ent.Value, 0, len(m.removedfollowerUsers))
		for id := range m.removedfollowerUsers {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowedBusinesses:
		ids := make([]ent.Value, 0, len(m.removedfollowedBusinesses))
		for id := range m.removedfollowedBusinesses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeFollowerBusinesses:
		ids := make([]ent.Value, 0, len(m.removedfollowerBusinesses))
		for id := range m.removedfollowerBusinesses {
			ids = append(ids, id)
		}
		return ids
	case business.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case business.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.removedcategoryAssignments))
		for id := range m.removedcategoryAssignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.cleareduserBusinesses {
		edges = append(edges, business.EdgeUserBusinesses)
	}
	if m.clearedbusiness_account_settings {
		edges = append(edges, business.EdgeBusinessAccountSettings)
	}
	if m.clearedposts {
		edges = append(edges, business.EdgePosts)
	}
	if m.clearedfollowedUsers {
		edges = append(edges, business.EdgeFollowedUsers)
	}
	if m.clearedfollowerUsers {
		edges = append(edges, business.EdgeFollowerUsers)
	}
	if m.clearedfollowedBusinesses {
		edges = append(edges, business.EdgeFollowedBusinesses)
	}
	if m.clearedfollowerBusinesses {
		edges = append(edges, business.EdgeFollowerBusinesses)
	}
	if m.clearedplaces {
		edges = append(edges, business.EdgePlaces)
	}
	if m.clearedcategories {
		edges = append(edges, business.EdgeCategories)
	}
	if m.clearedcategoryAssignments {
		edges = append(edges, business.EdgeCategoryAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessMutation) EdgeCleared(name string) bool {
	switch name {
	case business.EdgeUserBusinesses:
		return m.cleareduserBusinesses
	case business.EdgeBusinessAccountSettings:
		return m.clearedbusiness_account_settings
	case business.EdgePosts:
		return m.clearedposts
	case business.EdgeFollowedUsers:
		return m.clearedfollowedUsers
	case business.EdgeFollowerUsers:
		return m.clearedfollowerUsers
	case business.EdgeFollowedBusinesses:
		return m.clearedfollowedBusinesses
	case business.EdgeFollowerBusinesses:
		return m.clearedfollowerBusinesses
	case business.EdgePlaces:
		return m.clearedplaces
	case business.EdgeCategories:
		return m.clearedcategories
	case business.EdgeCategoryAssignments:
		return m.clearedcategoryAssignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessMutation) ClearEdge(name string) error {
	switch name {
	case business.EdgeBusinessAccountSettings:
		m.ClearBusinessAccountSettings()
		return nil
	}
	return fmt.Errorf("unknown Business unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessMutation) ResetEdge(name string) error {
	switch name {
	case business.EdgeUserBusinesses:
		m.ResetUserBusinesses()
		return nil
	case business.EdgeBusinessAccountSettings:
		m.ResetBusinessAccountSettings()
		return nil
	case business.EdgePosts:
		m.ResetPosts()
		return nil
	case business.EdgeFollowedUsers:
		m.ResetFollowedUsers()
		return nil
	case business.EdgeFollowerUsers:
		m.ResetFollowerUsers()
		return nil
	case business.EdgeFollowedBusinesses:
		m.ResetFollowedBusinesses()
		return nil
	case business.EdgeFollowerBusinesses:
		m.ResetFollowerBusinesses()
		return nil
	case business.EdgePlaces:
		m.ResetPlaces()
		return nil
	case business.EdgeCategories:
		m.ResetCategories()
		return nil
	case business.EdgeCategoryAssignments:
		m.ResetCategoryAssignments()
		return nil
	}
	return fmt.Errorf("unknown Business edge %s", name)
}

// BusinessFollowBusinessMutation represents an operation that mutates the BusinessFollowBusiness nodes in the graph.
type BusinessFollowBusinessMutation struct {
	config
	op              Op
	typ             string
	id              *string
	clearedFields   map[string]struct{}
	follower        *string
	clearedfollower bool
	followed        *string
	clearedfollowed bool
	done            bool
	oldValue        func(context.Context) (*BusinessFollowBusiness, error)
	predicates      []predicate.BusinessFollowBusiness
}

var _ ent.Mutation = (*BusinessFollowBusinessMutation)(nil)

// businessfollowbusinessOption allows management of the mutation configuration using functional options.
type businessfollowbusinessOption func(*BusinessFollowBusinessMutation)

// newBusinessFollowBusinessMutation creates new mutation for the BusinessFollowBusiness entity.
func newBusinessFollowBusinessMutation(c config, op Op, opts ...businessfollowbusinessOption) *BusinessFollowBusinessMutation {
	m := &BusinessFollowBusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeBusinessFollowBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessFollowBusinessID sets the ID field of the mutation.
func withBusinessFollowBusinessID(id string) businessfollowbusinessOption {
	return func(m *BusinessFollowBusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *BusinessFollowBusiness
		)
		m.oldValue = func(ctx context.Context) (*BusinessFollowBusiness, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BusinessFollowBusiness.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusinessFollowBusiness sets the old BusinessFollowBusiness of the mutation.
func withBusinessFollowBusiness(node *BusinessFollowBusiness) businessfollowbusinessOption {
	return func(m *BusinessFollowBusinessMutation) {
		m.oldValue = func(context.Context) (*BusinessFollowBusiness, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessFollowBusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessFollowBusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessFollowBusinessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessFollowBusinessMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BusinessFollowBusiness.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFollowerID sets the "follower" edge to the Business entity by id.
func (m *BusinessFollowBusinessMutation) SetFollowerID(id string) {
	m.follower = &id
}

// ClearFollower clears the "follower" edge to the Business entity.
func (m *BusinessFollowBusinessMutation) ClearFollower() {
	m.clearedfollower = true
}

// FollowerCleared reports if the "follower" edge to the Business entity was cleared.
func (m *BusinessFollowBusinessMutation) FollowerCleared() bool {
	return m.clearedfollower
}

// FollowerID returns the "follower" edge ID in the mutation.
func (m *BusinessFollowBusinessMutation) FollowerID() (id string, exists bool) {
	if m.follower != nil {
		return *m.follower, true
	}
	return
}

// FollowerIDs returns the "follower" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowerID instead. It exists only for internal usage by the builders.
func (m *BusinessFollowBusinessMutation) FollowerIDs() (ids []string) {
	if id := m.follower; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollower resets all changes to the "follower" edge.
func (m *BusinessFollowBusinessMutation) ResetFollower() {
	m.follower = nil
	m.clearedfollower = false
}

// SetFollowedID sets the "followed" edge to the Business entity by id.
func (m *BusinessFollowBusinessMutation) SetFollowedID(id string) {
	m.followed = &id
}

// ClearFollowed clears the "followed" edge to the Business entity.
func (m *BusinessFollowBusinessMutation) ClearFollowed() {
	m.clearedfollowed = true
}

// FollowedCleared reports if the "followed" edge to the Business entity was cleared.
func (m *BusinessFollowBusinessMutation) FollowedCleared() bool {
	return m.clearedfollowed
}

// FollowedID returns the "followed" edge ID in the mutation.
func (m *BusinessFollowBusinessMutation) FollowedID() (id string, exists bool) {
	if m.followed != nil {
		return *m.followed, true
	}
	return
}

// FollowedIDs returns the "followed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowedID instead. It exists only for internal usage by the builders.
func (m *BusinessFollowBusinessMutation) FollowedIDs() (ids []string) {
	if id := m.followed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollowed resets all changes to the "followed" edge.
func (m *BusinessFollowBusinessMutation) ResetFollowed() {
	m.followed = nil
	m.clearedfollowed = false
}

// Where appends a list predicates to the BusinessFollowBusinessMutation builder.
func (m *BusinessFollowBusinessMutation) Where(ps ...predicate.BusinessFollowBusiness) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessFollowBusinessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessFollowBusinessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BusinessFollowBusiness, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessFollowBusinessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessFollowBusinessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BusinessFollowBusiness).
func (m *BusinessFollowBusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessFollowBusinessMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessFollowBusinessMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessFollowBusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown BusinessFollowBusiness field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessFollowBusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BusinessFollowBusiness field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessFollowBusinessMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessFollowBusinessMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessFollowBusinessMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown BusinessFollowBusiness numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessFollowBusinessMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessFollowBusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessFollowBusinessMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BusinessFollowBusiness nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessFollowBusinessMutation) ResetField(name string) error {
	return fmt.Errorf("unknown BusinessFollowBusiness field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessFollowBusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.follower != nil {
		edges = append(edges, businessfollowbusiness.EdgeFollower)
	}
	if m.followed != nil {
		edges = append(edges, businessfollowbusiness.EdgeFollowed)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessFollowBusinessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case businessfollowbusiness.EdgeFollower:
		if id := m.follower; id != nil {
			return []ent.Value{*id}
		}
	case businessfollowbusiness.EdgeFollowed:
		if id := m.followed; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessFollowBusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessFollowBusinessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessFollowBusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfollower {
		edges = append(edges, businessfollowbusiness.EdgeFollower)
	}
	if m.clearedfollowed {
		edges = append(edges, businessfollowbusiness.EdgeFollowed)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessFollowBusinessMutation) EdgeCleared(name string) bool {
	switch name {
	case businessfollowbusiness.EdgeFollower:
		return m.clearedfollower
	case businessfollowbusiness.EdgeFollowed:
		return m.clearedfollowed
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessFollowBusinessMutation) ClearEdge(name string) error {
	switch name {
	case businessfollowbusiness.EdgeFollower:
		m.ClearFollower()
		return nil
	case businessfollowbusiness.EdgeFollowed:
		m.ClearFollowed()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowBusiness unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessFollowBusinessMutation) ResetEdge(name string) error {
	switch name {
	case businessfollowbusiness.EdgeFollower:
		m.ResetFollower()
		return nil
	case businessfollowbusiness.EdgeFollowed:
		m.ResetFollowed()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowBusiness edge %s", name)
}

// BusinessFollowUserMutation represents an operation that mutates the BusinessFollowUser nodes in the graph.
type BusinessFollowUserMutation struct {
	config
	op              Op
	typ             string
	id              *string
	clearedFields   map[string]struct{}
	business        *string
	clearedbusiness bool
	user            *string
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*BusinessFollowUser, error)
	predicates      []predicate.BusinessFollowUser
}

var _ ent.Mutation = (*BusinessFollowUserMutation)(nil)

// businessfollowuserOption allows management of the mutation configuration using functional options.
type businessfollowuserOption func(*BusinessFollowUserMutation)

// newBusinessFollowUserMutation creates new mutation for the BusinessFollowUser entity.
func newBusinessFollowUserMutation(c config, op Op, opts ...businessfollowuserOption) *BusinessFollowUserMutation {
	m := &BusinessFollowUserMutation{
		config:        c,
		op:            op,
		typ:           TypeBusinessFollowUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessFollowUserID sets the ID field of the mutation.
func withBusinessFollowUserID(id string) businessfollowuserOption {
	return func(m *BusinessFollowUserMutation) {
		var (
			err   error
			once  sync.Once
			value *BusinessFollowUser
		)
		m.oldValue = func(ctx context.Context) (*BusinessFollowUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BusinessFollowUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusinessFollowUser sets the old BusinessFollowUser of the mutation.
func withBusinessFollowUser(node *BusinessFollowUser) businessfollowuserOption {
	return func(m *BusinessFollowUserMutation) {
		m.oldValue = func(context.Context) (*BusinessFollowUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessFollowUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessFollowUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessFollowUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessFollowUserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BusinessFollowUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *BusinessFollowUserMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *BusinessFollowUserMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *BusinessFollowUserMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *BusinessFollowUserMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *BusinessFollowUserMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *BusinessFollowUserMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *BusinessFollowUserMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *BusinessFollowUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BusinessFollowUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *BusinessFollowUserMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BusinessFollowUserMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BusinessFollowUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the BusinessFollowUserMutation builder.
func (m *BusinessFollowUserMutation) Where(ps ...predicate.BusinessFollowUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessFollowUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessFollowUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BusinessFollowUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessFollowUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessFollowUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BusinessFollowUser).
func (m *BusinessFollowUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessFollowUserMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessFollowUserMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessFollowUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown BusinessFollowUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessFollowUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BusinessFollowUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessFollowUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessFollowUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessFollowUserMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown BusinessFollowUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessFollowUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessFollowUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessFollowUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BusinessFollowUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessFollowUserMutation) ResetField(name string) error {
	return fmt.Errorf("unknown BusinessFollowUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessFollowUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business != nil {
		edges = append(edges, businessfollowuser.EdgeBusiness)
	}
	if m.user != nil {
		edges = append(edges, businessfollowuser.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessFollowUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case businessfollowuser.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case businessfollowuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessFollowUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessFollowUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessFollowUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness {
		edges = append(edges, businessfollowuser.EdgeBusiness)
	}
	if m.cleareduser {
		edges = append(edges, businessfollowuser.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessFollowUserMutation) EdgeCleared(name string) bool {
	switch name {
	case businessfollowuser.EdgeBusiness:
		return m.clearedbusiness
	case businessfollowuser.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessFollowUserMutation) ClearEdge(name string) error {
	switch name {
	case businessfollowuser.EdgeBusiness:
		m.ClearBusiness()
		return nil
	case businessfollowuser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessFollowUserMutation) ResetEdge(name string) error {
	switch name {
	case businessfollowuser.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case businessfollowuser.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown BusinessFollowUser edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	name                       *string
	image                      *string
	clearedFields              map[string]struct{}
	categoryAssignments        map[string]struct{}
	removedcategoryAssignments map[string]struct{}
	clearedcategoryAssignments bool
	done                       bool
	oldValue                   func(context.Context) (*Category, error)
	predicates                 []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id string) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetImage sets the "image" field.
func (m *CategoryMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *CategoryMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *CategoryMutation) ClearImage() {
	m.image = nil
	m.clearedFields[category.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *CategoryMutation) ImageCleared() bool {
	_, ok := m.clearedFields[category.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *CategoryMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, category.FieldImage)
}

// AddCategoryAssignmentIDs adds the "categoryAssignments" edge to the CategoryAssignment entity by ids.
func (m *CategoryMutation) AddCategoryAssignmentIDs(ids ...string) {
	if m.categoryAssignments == nil {
		m.categoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		m.categoryAssignments[ids[i]] = struct{}{}
	}
}

// ClearCategoryAssignments clears the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *CategoryMutation) ClearCategoryAssignments() {
	m.clearedcategoryAssignments = true
}

// CategoryAssignmentsCleared reports if the "categoryAssignments" edge to the CategoryAssignment entity was cleared.
func (m *CategoryMutation) CategoryAssignmentsCleared() bool {
	return m.clearedcategoryAssignments
}

// RemoveCategoryAssignmentIDs removes the "categoryAssignments" edge to the CategoryAssignment entity by IDs.
func (m *CategoryMutation) RemoveCategoryAssignmentIDs(ids ...string) {
	if m.removedcategoryAssignments == nil {
		m.removedcategoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categoryAssignments, ids[i])
		m.removedcategoryAssignments[ids[i]] = struct{}{}
	}
}

// RemovedCategoryAssignments returns the removed IDs of the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *CategoryMutation) RemovedCategoryAssignmentsIDs() (ids []string) {
	for id := range m.removedcategoryAssignments {
		ids = append(ids, id)
	}
	return
}

// CategoryAssignmentsIDs returns the "categoryAssignments" edge IDs in the mutation.
func (m *CategoryMutation) CategoryAssignmentsIDs() (ids []string) {
	for id := range m.categoryAssignments {
		ids = append(ids, id)
	}
	return
}

// ResetCategoryAssignments resets all changes to the "categoryAssignments" edge.
func (m *CategoryMutation) ResetCategoryAssignments() {
	m.categoryAssignments = nil
	m.clearedcategoryAssignments = false
	m.removedcategoryAssignments = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.image != nil {
		fields = append(fields, category.FieldImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldImage:
		return m.Image()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldImage:
		return m.OldImage(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldImage) {
		fields = append(fields, category.FieldImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.categoryAssignments != nil {
		edges = append(edges, category.EdgeCategoryAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.categoryAssignments))
		for id := range m.categoryAssignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcategoryAssignments != nil {
		edges = append(edges, category.EdgeCategoryAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.removedcategoryAssignments))
		for id := range m.removedcategoryAssignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcategoryAssignments {
		edges = append(edges, category.EdgeCategoryAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeCategoryAssignments:
		return m.clearedcategoryAssignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeCategoryAssignments:
		m.ResetCategoryAssignments()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CategoryAssignmentMutation represents an operation that mutates the CategoryAssignment nodes in the graph.
type CategoryAssignmentMutation struct {
	config
	op              Op
	typ             string
	id              *string
	entity_type     *string
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	business        *string
	clearedbusiness bool
	place           *string
	clearedplace    bool
	category        *string
	clearedcategory bool
	done            bool
	oldValue        func(context.Context) (*CategoryAssignment, error)
	predicates      []predicate.CategoryAssignment
}

var _ ent.Mutation = (*CategoryAssignmentMutation)(nil)

// categoryassignmentOption allows management of the mutation configuration using functional options.
type categoryassignmentOption func(*CategoryAssignmentMutation)

// newCategoryAssignmentMutation creates new mutation for the CategoryAssignment entity.
func newCategoryAssignmentMutation(c config, op Op, opts ...categoryassignmentOption) *CategoryAssignmentMutation {
	m := &CategoryAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeCategoryAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryAssignmentID sets the ID field of the mutation.
func withCategoryAssignmentID(id string) categoryassignmentOption {
	return func(m *CategoryAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *CategoryAssignment
		)
		m.oldValue = func(ctx context.Context) (*CategoryAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CategoryAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategoryAssignment sets the old CategoryAssignment of the mutation.
func withCategoryAssignment(node *CategoryAssignment) categoryassignmentOption {
	return func(m *CategoryAssignmentMutation) {
		m.oldValue = func(context.Context) (*CategoryAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryAssignmentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryAssignmentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CategoryAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntityID sets the "entity_id" field.
func (m *CategoryAssignmentMutation) SetEntityID(s string) {
	m.user = &s
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *CategoryAssignmentMutation) EntityID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the CategoryAssignment entity.
// If the CategoryAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryAssignmentMutation) OldEntityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ClearEntityID clears the value of the "entity_id" field.
func (m *CategoryAssignmentMutation) ClearEntityID() {
	m.user = nil
	m.clearedFields[categoryassignment.FieldEntityID] = struct{}{}
}

// EntityIDCleared returns if the "entity_id" field was cleared in this mutation.
func (m *CategoryAssignmentMutation) EntityIDCleared() bool {
	_, ok := m.clearedFields[categoryassignment.FieldEntityID]
	return ok
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *CategoryAssignmentMutation) ResetEntityID() {
	m.user = nil
	delete(m.clearedFields, categoryassignment.FieldEntityID)
}

// SetEntityType sets the "entity_type" field.
func (m *CategoryAssignmentMutation) SetEntityType(s string) {
	m.entity_type = &s
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *CategoryAssignmentMutation) EntityType() (r string, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the CategoryAssignment entity.
// If the CategoryAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryAssignmentMutation) OldEntityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ClearEntityType clears the value of the "entity_type" field.
func (m *CategoryAssignmentMutation) ClearEntityType() {
	m.entity_type = nil
	m.clearedFields[categoryassignment.FieldEntityType] = struct{}{}
}

// EntityTypeCleared returns if the "entity_type" field was cleared in this mutation.
func (m *CategoryAssignmentMutation) EntityTypeCleared() bool {
	_, ok := m.clearedFields[categoryassignment.FieldEntityType]
	return ok
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *CategoryAssignmentMutation) ResetEntityType() {
	m.entity_type = nil
	delete(m.clearedFields, categoryassignment.FieldEntityType)
}

// SetCategoryID sets the "category_id" field.
func (m *CategoryAssignmentMutation) SetCategoryID(s string) {
	m.category = &s
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *CategoryAssignmentMutation) CategoryID() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the CategoryAssignment entity.
// If the CategoryAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryAssignmentMutation) OldCategoryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *CategoryAssignmentMutation) ClearCategoryID() {
	m.category = nil
	m.clearedFields[categoryassignment.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *CategoryAssignmentMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[categoryassignment.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *CategoryAssignmentMutation) ResetCategoryID() {
	m.category = nil
	delete(m.clearedFields, categoryassignment.FieldCategoryID)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CategoryAssignmentMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CategoryAssignmentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CategoryAssignmentMutation) UserCleared() bool {
	return m.EntityIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CategoryAssignmentMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CategoryAssignmentMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CategoryAssignmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *CategoryAssignmentMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *CategoryAssignmentMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *CategoryAssignmentMutation) BusinessCleared() bool {
	return m.EntityIDCleared() || m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *CategoryAssignmentMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *CategoryAssignmentMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *CategoryAssignmentMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *CategoryAssignmentMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *CategoryAssignmentMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *CategoryAssignmentMutation) PlaceCleared() bool {
	return m.EntityIDCleared() || m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *CategoryAssignmentMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *CategoryAssignmentMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *CategoryAssignmentMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *CategoryAssignmentMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *CategoryAssignmentMutation) CategoryCleared() bool {
	return m.CategoryIDCleared() || m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *CategoryAssignmentMutation) CategoryIDs() (ids []string) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *CategoryAssignmentMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// Where appends a list predicates to the CategoryAssignmentMutation builder.
func (m *CategoryAssignmentMutation) Where(ps ...predicate.CategoryAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CategoryAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CategoryAssignment).
func (m *CategoryAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, categoryassignment.FieldEntityID)
	}
	if m.entity_type != nil {
		fields = append(fields, categoryassignment.FieldEntityType)
	}
	if m.category != nil {
		fields = append(fields, categoryassignment.FieldCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case categoryassignment.FieldEntityID:
		return m.EntityID()
	case categoryassignment.FieldEntityType:
		return m.EntityType()
	case categoryassignment.FieldCategoryID:
		return m.CategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case categoryassignment.FieldEntityID:
		return m.OldEntityID(ctx)
	case categoryassignment.FieldEntityType:
		return m.OldEntityType(ctx)
	case categoryassignment.FieldCategoryID:
		return m.OldCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown CategoryAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case categoryassignment.FieldEntityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case categoryassignment.FieldEntityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	case categoryassignment.FieldCategoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown CategoryAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CategoryAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(categoryassignment.FieldEntityID) {
		fields = append(fields, categoryassignment.FieldEntityID)
	}
	if m.FieldCleared(categoryassignment.FieldEntityType) {
		fields = append(fields, categoryassignment.FieldEntityType)
	}
	if m.FieldCleared(categoryassignment.FieldCategoryID) {
		fields = append(fields, categoryassignment.FieldCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryAssignmentMutation) ClearField(name string) error {
	switch name {
	case categoryassignment.FieldEntityID:
		m.ClearEntityID()
		return nil
	case categoryassignment.FieldEntityType:
		m.ClearEntityType()
		return nil
	case categoryassignment.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	}
	return fmt.Errorf("unknown CategoryAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryAssignmentMutation) ResetField(name string) error {
	switch name {
	case categoryassignment.FieldEntityID:
		m.ResetEntityID()
		return nil
	case categoryassignment.FieldEntityType:
		m.ResetEntityType()
		return nil
	case categoryassignment.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	}
	return fmt.Errorf("unknown CategoryAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, categoryassignment.EdgeUser)
	}
	if m.business != nil {
		edges = append(edges, categoryassignment.EdgeBusiness)
	}
	if m.place != nil {
		edges = append(edges, categoryassignment.EdgePlace)
	}
	if m.category != nil {
		edges = append(edges, categoryassignment.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case categoryassignment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case categoryassignment.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case categoryassignment.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	case categoryassignment.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, categoryassignment.EdgeUser)
	}
	if m.clearedbusiness {
		edges = append(edges, categoryassignment.EdgeBusiness)
	}
	if m.clearedplace {
		edges = append(edges, categoryassignment.EdgePlace)
	}
	if m.clearedcategory {
		edges = append(edges, categoryassignment.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case categoryassignment.EdgeUser:
		return m.cleareduser
	case categoryassignment.EdgeBusiness:
		return m.clearedbusiness
	case categoryassignment.EdgePlace:
		return m.clearedplace
	case categoryassignment.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case categoryassignment.EdgeUser:
		m.ClearUser()
		return nil
	case categoryassignment.EdgeBusiness:
		m.ClearBusiness()
		return nil
	case categoryassignment.EdgePlace:
		m.ClearPlace()
		return nil
	case categoryassignment.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown CategoryAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case categoryassignment.EdgeUser:
		m.ResetUser()
		return nil
	case categoryassignment.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case categoryassignment.EdgePlace:
		m.ResetPlace()
		return nil
	case categoryassignment.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown CategoryAssignment edge %s", name)
}

// ChatMutation represents an operation that mutates the Chat nodes in the graph.
type ChatMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Chat, error)
	predicates    []predicate.Chat
}

var _ ent.Mutation = (*ChatMutation)(nil)

// chatOption allows management of the mutation configuration using functional options.
type chatOption func(*ChatMutation)

// newChatMutation creates new mutation for the Chat entity.
func newChatMutation(c config, op Op, opts ...chatOption) *ChatMutation {
	m := &ChatMutation{
		config:        c,
		op:            op,
		typ:           TypeChat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChatID sets the ID field of the mutation.
func withChatID(id string) chatOption {
	return func(m *ChatMutation) {
		var (
			err   error
			once  sync.Once
			value *Chat
		)
		m.oldValue = func(ctx context.Context) (*Chat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChat sets the old Chat of the mutation.
func withChat(node *Chat) chatOption {
	return func(m *ChatMutation) {
		m.oldValue = func(context.Context) (*Chat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChatMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChatMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ChatMutation builder.
func (m *ChatMutation) Where(ps ...predicate.Chat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chat).
func (m *ChatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChatMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChatMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Chat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Chat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Chat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChatMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChatMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChatMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChatMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChatMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Chat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChatMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Chat edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op            Op
	typ           string
	id            *string
	_Content      *string
	_CreatedAt    *time.Time
	_UpdatedAt    *time.Time
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	post          *string
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*Comment, error)
	predicates    []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id string) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "Content" field.
func (m *CommentMutation) SetContent(s string) {
	m._Content = &s
}

// Content returns the value of the "Content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m._Content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "Content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "Content" field.
func (m *CommentMutation) ResetContent() {
	m._Content = nil
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *CommentMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CommentMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CommentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CommentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CommentMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *CommentMutation) SetPostID(id string) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *CommentMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *CommentMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *CommentMutation) PostID() (id string, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) PostIDs() (ids []string) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *CommentMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m._CreatedAt != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldContent:
		return m.Content()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, comment.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, comment.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, comment.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, comment.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeUser:
		return m.cleareduser
	case comment.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeUser:
		m.ClearUser()
		return nil
	case comment.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeUser:
		m.ResetUser()
		return nil
	case comment.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	name                  *string
	createdAt             *time.Time
	updatedAt             *time.Time
	clearedFields         map[string]struct{}
	tickets               map[string]struct{}
	removedtickets        map[string]struct{}
	clearedtickets        bool
	ticket_options        map[string]struct{}
	removedticket_options map[string]struct{}
	clearedticket_options bool
	done                  bool
	oldValue              func(context.Context) (*Event, error)
	predicates            []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id string) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EventMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EventMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EventMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *EventMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *EventMutation) AddTicketIDs(ids ...string) {
	if m.tickets == nil {
		m.tickets = make(map[string]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *EventMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *EventMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *EventMutation) RemoveTicketIDs(ids ...string) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *EventMutation) RemovedTicketsIDs() (ids []string) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *EventMutation) TicketsIDs() (ids []string) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *EventMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// AddTicketOptionIDs adds the "ticket_options" edge to the TicketOption entity by ids.
func (m *EventMutation) AddTicketOptionIDs(ids ...string) {
	if m.ticket_options == nil {
		m.ticket_options = make(map[string]struct{})
	}
	for i := range ids {
		m.ticket_options[ids[i]] = struct{}{}
	}
}

// ClearTicketOptions clears the "ticket_options" edge to the TicketOption entity.
func (m *EventMutation) ClearTicketOptions() {
	m.clearedticket_options = true
}

// TicketOptionsCleared reports if the "ticket_options" edge to the TicketOption entity was cleared.
func (m *EventMutation) TicketOptionsCleared() bool {
	return m.clearedticket_options
}

// RemoveTicketOptionIDs removes the "ticket_options" edge to the TicketOption entity by IDs.
func (m *EventMutation) RemoveTicketOptionIDs(ids ...string) {
	if m.removedticket_options == nil {
		m.removedticket_options = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ticket_options, ids[i])
		m.removedticket_options[ids[i]] = struct{}{}
	}
}

// RemovedTicketOptions returns the removed IDs of the "ticket_options" edge to the TicketOption entity.
func (m *EventMutation) RemovedTicketOptionsIDs() (ids []string) {
	for id := range m.removedticket_options {
		ids = append(ids, id)
	}
	return
}

// TicketOptionsIDs returns the "ticket_options" edge IDs in the mutation.
func (m *EventMutation) TicketOptionsIDs() (ids []string) {
	for id := range m.ticket_options {
		ids = append(ids, id)
	}
	return
}

// ResetTicketOptions resets all changes to the "ticket_options" edge.
func (m *EventMutation) ResetTicketOptions() {
	m.ticket_options = nil
	m.clearedticket_options = false
	m.removedticket_options = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, event.FieldName)
	}
	if m.createdAt != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldName:
		return m.Name()
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldName:
		return m.OldName(ctx)
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldName:
		m.ResetName()
		return nil
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tickets != nil {
		edges = append(edges, event.EdgeTickets)
	}
	if m.ticket_options != nil {
		edges = append(edges, event.EdgeTicketOptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeTicketOptions:
		ids := make([]ent.Value, 0, len(m.ticket_options))
		for id := range m.ticket_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtickets != nil {
		edges = append(edges, event.EdgeTickets)
	}
	if m.removedticket_options != nil {
		edges = append(edges, event.EdgeTicketOptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeTicketOptions:
		ids := make([]ent.Value, 0, len(m.removedticket_options))
		for id := range m.removedticket_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtickets {
		edges = append(edges, event.EdgeTickets)
	}
	if m.clearedticket_options {
		edges = append(edges, event.EdgeTicketOptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeTickets:
		return m.clearedtickets
	case event.EdgeTicketOptions:
		return m.clearedticket_options
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeTickets:
		m.ResetTickets()
		return nil
	case event.EdgeTicketOptions:
		m.ResetTicketOptions()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// HelpMutation represents an operation that mutates the Help nodes in the graph.
type HelpMutation struct {
	config
	op            Op
	typ           string
	id            *string
	category      *string
	subject       *string
	body          *string
	media         *string
	status        *string
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Help, error)
	predicates    []predicate.Help
}

var _ ent.Mutation = (*HelpMutation)(nil)

// helpOption allows management of the mutation configuration using functional options.
type helpOption func(*HelpMutation)

// newHelpMutation creates new mutation for the Help entity.
func newHelpMutation(c config, op Op, opts ...helpOption) *HelpMutation {
	m := &HelpMutation{
		config:        c,
		op:            op,
		typ:           TypeHelp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHelpID sets the ID field of the mutation.
func withHelpID(id string) helpOption {
	return func(m *HelpMutation) {
		var (
			err   error
			once  sync.Once
			value *Help
		)
		m.oldValue = func(ctx context.Context) (*Help, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Help.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHelp sets the old Help of the mutation.
func withHelp(node *Help) helpOption {
	return func(m *HelpMutation) {
		m.oldValue = func(context.Context) (*Help, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HelpMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HelpMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Help entities.
func (m *HelpMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HelpMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HelpMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Help.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCategory sets the "category" field.
func (m *HelpMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *HelpMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *HelpMutation) ResetCategory() {
	m.category = nil
}

// SetSubject sets the "subject" field.
func (m *HelpMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *HelpMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *HelpMutation) ResetSubject() {
	m.subject = nil
}

// SetBody sets the "body" field.
func (m *HelpMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *HelpMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *HelpMutation) ResetBody() {
	m.body = nil
}

// SetMedia sets the "media" field.
func (m *HelpMutation) SetMedia(s string) {
	m.media = &s
}

// Media returns the value of the "media" field in the mutation.
func (m *HelpMutation) Media() (r string, exists bool) {
	v := m.media
	if v == nil {
		return
	}
	return *v, true
}

// OldMedia returns the old "media" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldMedia(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMedia is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMedia requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedia: %w", err)
	}
	return oldValue.Media, nil
}

// ClearMedia clears the value of the "media" field.
func (m *HelpMutation) ClearMedia() {
	m.media = nil
	m.clearedFields[help.FieldMedia] = struct{}{}
}

// MediaCleared returns if the "media" field was cleared in this mutation.
func (m *HelpMutation) MediaCleared() bool {
	_, ok := m.clearedFields[help.FieldMedia]
	return ok
}

// ResetMedia resets all changes to the "media" field.
func (m *HelpMutation) ResetMedia() {
	m.media = nil
	delete(m.clearedFields, help.FieldMedia)
}

// SetStatus sets the "status" field.
func (m *HelpMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *HelpMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HelpMutation) ResetStatus() {
	m.status = nil
}

// SetUserID sets the "user_id" field.
func (m *HelpMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *HelpMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *HelpMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *HelpMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *HelpMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *HelpMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *HelpMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the HelpMutation builder.
func (m *HelpMutation) Where(ps ...predicate.Help) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HelpMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HelpMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Help, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HelpMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HelpMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Help).
func (m *HelpMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HelpMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.category != nil {
		fields = append(fields, help.FieldCategory)
	}
	if m.subject != nil {
		fields = append(fields, help.FieldSubject)
	}
	if m.body != nil {
		fields = append(fields, help.FieldBody)
	}
	if m.media != nil {
		fields = append(fields, help.FieldMedia)
	}
	if m.status != nil {
		fields = append(fields, help.FieldStatus)
	}
	if m.user != nil {
		fields = append(fields, help.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HelpMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case help.FieldCategory:
		return m.Category()
	case help.FieldSubject:
		return m.Subject()
	case help.FieldBody:
		return m.Body()
	case help.FieldMedia:
		return m.Media()
	case help.FieldStatus:
		return m.Status()
	case help.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HelpMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case help.FieldCategory:
		return m.OldCategory(ctx)
	case help.FieldSubject:
		return m.OldSubject(ctx)
	case help.FieldBody:
		return m.OldBody(ctx)
	case help.FieldMedia:
		return m.OldMedia(ctx)
	case help.FieldStatus:
		return m.OldStatus(ctx)
	case help.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Help field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HelpMutation) SetField(name string, value ent.Value) error {
	switch name {
	case help.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case help.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case help.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case help.FieldMedia:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedia(v)
		return nil
	case help.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case help.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Help field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HelpMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HelpMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HelpMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Help numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HelpMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(help.FieldMedia) {
		fields = append(fields, help.FieldMedia)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HelpMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HelpMutation) ClearField(name string) error {
	switch name {
	case help.FieldMedia:
		m.ClearMedia()
		return nil
	}
	return fmt.Errorf("unknown Help nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HelpMutation) ResetField(name string) error {
	switch name {
	case help.FieldCategory:
		m.ResetCategory()
		return nil
	case help.FieldSubject:
		m.ResetSubject()
		return nil
	case help.FieldBody:
		m.ResetBody()
		return nil
	case help.FieldMedia:
		m.ResetMedia()
		return nil
	case help.FieldStatus:
		m.ResetStatus()
		return nil
	case help.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Help field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HelpMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, help.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HelpMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case help.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HelpMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HelpMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HelpMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, help.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HelpMutation) EdgeCleared(name string) bool {
	switch name {
	case help.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HelpMutation) ClearEdge(name string) error {
	switch name {
	case help.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Help unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HelpMutation) ResetEdge(name string) error {
	switch name {
	case help.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Help edge %s", name)
}

// LikeMutation represents an operation that mutates the Like nodes in the graph.
type LikeMutation struct {
	config
	op            Op
	typ           string
	id            *string
	_CreatedAt    *time.Time
	_UpdatedAt    *time.Time
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	post          *string
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*Like, error)
	predicates    []predicate.Like
}

var _ ent.Mutation = (*LikeMutation)(nil)

// likeOption allows management of the mutation configuration using functional options.
type likeOption func(*LikeMutation)

// newLikeMutation creates new mutation for the Like entity.
func newLikeMutation(c config, op Op, opts ...likeOption) *LikeMutation {
	m := &LikeMutation{
		config:        c,
		op:            op,
		typ:           TypeLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLikeID sets the ID field of the mutation.
func withLikeID(id string) likeOption {
	return func(m *LikeMutation) {
		var (
			err   error
			once  sync.Once
			value *Like
		)
		m.oldValue = func(ctx context.Context) (*Like, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Like.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLike sets the old Like of the mutation.
func withLike(node *Like) likeOption {
	return func(m *LikeMutation) {
		m.oldValue = func(context.Context) (*Like, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Like entities.
func (m *LikeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LikeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LikeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Like.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *LikeMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *LikeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *LikeMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *LikeMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *LikeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *LikeMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *LikeMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *LikeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *LikeMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LikeMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *LikeMutation) SetPostID(id string) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *LikeMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *LikeMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *LikeMutation) PostID() (id string, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *LikeMutation) PostIDs() (ids []string) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *LikeMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Where appends a list predicates to the LikeMutation builder.
func (m *LikeMutation) Where(ps ...predicate.Like) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Like, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Like).
func (m *LikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LikeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._CreatedAt != nil {
		fields = append(fields, like.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, like.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case like.FieldCreatedAt:
		return m.CreatedAt()
	case like.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case like.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case like.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Like field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case like.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case like.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Like field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LikeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LikeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Like numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Like nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LikeMutation) ResetField(name string) error {
	switch name {
	case like.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case like.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Like field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, like.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, like.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case like.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case like.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, like.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, like.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LikeMutation) EdgeCleared(name string) bool {
	switch name {
	case like.EdgeUser:
		return m.cleareduser
	case like.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LikeMutation) ClearEdge(name string) error {
	switch name {
	case like.EdgeUser:
		m.ClearUser()
		return nil
	case like.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown Like unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LikeMutation) ResetEdge(name string) error {
	switch name {
	case like.EdgeUser:
		m.ResetUser()
		return nil
	case like.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown Like edge %s", name)
}

// MediaMutation represents an operation that mutates the Media nodes in the graph.
type MediaMutation struct {
	config
	op                Op
	typ               string
	id                *string
	_URL              *string
	_MediaType        *string
	_CreatedAt        *time.Time
	_UpdatedAt        *time.Time
	clearedFields     map[string]struct{}
	post              *string
	clearedpost       bool
	categories        map[string]struct{}
	removedcategories map[string]struct{}
	clearedcategories bool
	done              bool
	oldValue          func(context.Context) (*Media, error)
	predicates        []predicate.Media
}

var _ ent.Mutation = (*MediaMutation)(nil)

// mediaOption allows management of the mutation configuration using functional options.
type mediaOption func(*MediaMutation)

// newMediaMutation creates new mutation for the Media entity.
func newMediaMutation(c config, op Op, opts ...mediaOption) *MediaMutation {
	m := &MediaMutation{
		config:        c,
		op:            op,
		typ:           TypeMedia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediaID sets the ID field of the mutation.
func withMediaID(id string) mediaOption {
	return func(m *MediaMutation) {
		var (
			err   error
			once  sync.Once
			value *Media
		)
		m.oldValue = func(ctx context.Context) (*Media, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Media.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedia sets the old Media of the mutation.
func withMedia(node *Media) mediaOption {
	return func(m *MediaMutation) {
		m.oldValue = func(context.Context) (*Media, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Media entities.
func (m *MediaMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediaMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediaMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Media.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "URL" field.
func (m *MediaMutation) SetURL(s string) {
	m._URL = &s
}

// URL returns the value of the "URL" field in the mutation.
func (m *MediaMutation) URL() (r string, exists bool) {
	v := m._URL
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "URL" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "URL" field.
func (m *MediaMutation) ResetURL() {
	m._URL = nil
}

// SetMediaType sets the "MediaType" field.
func (m *MediaMutation) SetMediaType(s string) {
	m._MediaType = &s
}

// MediaType returns the value of the "MediaType" field in the mutation.
func (m *MediaMutation) MediaType() (r string, exists bool) {
	v := m._MediaType
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaType returns the old "MediaType" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldMediaType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaType: %w", err)
	}
	return oldValue.MediaType, nil
}

// ResetMediaType resets all changes to the "MediaType" field.
func (m *MediaMutation) ResetMediaType() {
	m._MediaType = nil
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *MediaMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *MediaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *MediaMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *MediaMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *MediaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *MediaMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetPostID sets the "post" edge to the Post entity by id.
func (m *MediaMutation) SetPostID(id string) {
	m.post = &id
}

// ClearPost clears the "post" edge to the Post entity.
func (m *MediaMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *MediaMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *MediaMutation) PostID() (id string, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *MediaMutation) PostIDs() (ids []string) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *MediaMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *MediaMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *MediaMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *MediaMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *MediaMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *MediaMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *MediaMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *MediaMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// Where appends a list predicates to the MediaMutation builder.
func (m *MediaMutation) Where(ps ...predicate.Media) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Media, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Media).
func (m *MediaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediaMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._URL != nil {
		fields = append(fields, media.FieldURL)
	}
	if m._MediaType != nil {
		fields = append(fields, media.FieldMediaType)
	}
	if m._CreatedAt != nil {
		fields = append(fields, media.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, media.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case media.FieldURL:
		return m.URL()
	case media.FieldMediaType:
		return m.MediaType()
	case media.FieldCreatedAt:
		return m.CreatedAt()
	case media.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case media.FieldURL:
		return m.OldURL(ctx)
	case media.FieldMediaType:
		return m.OldMediaType(ctx)
	case media.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case media.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Media field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case media.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case media.FieldMediaType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaType(v)
		return nil
	case media.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case media.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Media numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Media nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediaMutation) ResetField(name string) error {
	switch name {
	case media.FieldURL:
		m.ResetURL()
		return nil
	case media.FieldMediaType:
		m.ResetMediaType()
		return nil
	case media.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case media.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediaMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.post != nil {
		edges = append(edges, media.EdgePost)
	}
	if m.categories != nil {
		edges = append(edges, media.EdgeCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case media.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	case media.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcategories != nil {
		edges = append(edges, media.EdgeCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpost {
		edges = append(edges, media.EdgePost)
	}
	if m.clearedcategories {
		edges = append(edges, media.EdgeCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediaMutation) EdgeCleared(name string) bool {
	switch name {
	case media.EdgePost:
		return m.clearedpost
	case media.EdgeCategories:
		return m.clearedcategories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediaMutation) ClearEdge(name string) error {
	switch name {
	case media.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown Media unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediaMutation) ResetEdge(name string) error {
	switch name {
	case media.EdgePost:
		m.ResetPost()
		return nil
	case media.EdgeCategories:
		m.ResetCategories()
		return nil
	}
	return fmt.Errorf("unknown Media edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op                Op
	typ               string
	id                *string
	clearedFields     map[string]struct{}
	place             *string
	clearedplace      bool
	categories        map[string]struct{}
	removedcategories map[string]struct{}
	clearedcategories bool
	done              bool
	oldValue          func(context.Context) (*Menu, error)
	predicates        []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id string) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *MenuMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *MenuMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *MenuMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *MenuMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *MenuMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *MenuMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *MenuMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *MenuMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *MenuMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *MenuMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *MenuMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *MenuMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.place != nil {
		edges = append(edges, menu.EdgePlace)
	}
	if m.categories != nil {
		edges = append(edges, menu.EdgeCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcategories != nil {
		edges = append(edges, menu.EdgeCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplace {
		edges = append(edges, menu.EdgePlace)
	}
	if m.clearedcategories {
		edges = append(edges, menu.EdgeCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgePlace:
		return m.clearedplace
	case menu.EdgeCategories:
		return m.clearedcategories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgePlace:
		m.ClearPlace()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgePlace:
		m.ResetPlace()
		return nil
	case menu.EdgeCategories:
		m.ResetCategories()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Order, error)
	predicates    []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id string) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Order edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Payment, error)
	predicates    []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id string) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PlaceMutation represents an operation that mutates the Place nodes in the graph.
type PlaceMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	name                       *string
	_type                      *string
	description                *string
	location                   *string
	images                     *[]string
	appendimages               []string
	availability               *map[string]interface{}
	special_offers             *string
	sustainability_score       *float64
	addsustainability_score    *float64
	map_coordinates            *map[string]interface{}
	search_text                *string
	relevance_score            *float64
	addrelevance_score         *float64
	clearedFields              map[string]struct{}
	business                   *string
	clearedbusiness            bool
	reviews                    map[string]struct{}
	removedreviews             map[string]struct{}
	clearedreviews             bool
	events                     map[string]struct{}
	removedevents              map[string]struct{}
	clearedevents              bool
	amenities                  map[string]struct{}
	removedamenities           map[string]struct{}
	clearedamenities           bool
	menus                      map[string]struct{}
	removedmenus               map[string]struct{}
	clearedmenus               bool
	rooms                      map[string]struct{}
	removedrooms               map[string]struct{}
	clearedrooms               bool
	reservations               map[string]struct{}
	removedreservations        map[string]struct{}
	clearedreservations        bool
	bookings                   map[string]struct{}
	removedbookings            map[string]struct{}
	clearedbookings            bool
	categories                 map[string]struct{}
	removedcategories          map[string]struct{}
	clearedcategories          bool
	categoryAssignments        map[string]struct{}
	removedcategoryAssignments map[string]struct{}
	clearedcategoryAssignments bool
	done                       bool
	oldValue                   func(context.Context) (*Place, error)
	predicates                 []predicate.Place
}

var _ ent.Mutation = (*PlaceMutation)(nil)

// placeOption allows management of the mutation configuration using functional options.
type placeOption func(*PlaceMutation)

// newPlaceMutation creates new mutation for the Place entity.
func newPlaceMutation(c config, op Op, opts ...placeOption) *PlaceMutation {
	m := &PlaceMutation{
		config:        c,
		op:            op,
		typ:           TypePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceID sets the ID field of the mutation.
func withPlaceID(id string) placeOption {
	return func(m *PlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Place
		)
		m.oldValue = func(ctx context.Context) (*Place, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Place.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlace sets the old Place of the mutation.
func withPlace(node *Place) placeOption {
	return func(m *PlaceMutation) {
		m.oldValue = func(context.Context) (*Place, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Place entities.
func (m *PlaceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Place.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PlaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlaceMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *PlaceMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PlaceMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PlaceMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *PlaceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlaceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlaceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[place.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlaceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[place.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlaceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, place.FieldDescription)
}

// SetLocation sets the "location" field.
func (m *PlaceMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *PlaceMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *PlaceMutation) ResetLocation() {
	m.location = nil
}

// SetImages sets the "images" field.
func (m *PlaceMutation) SetImages(s []string) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *PlaceMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *PlaceMutation) AppendImages(s []string) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *PlaceMutation) AppendedImages() ([]string, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *PlaceMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[place.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *PlaceMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[place.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *PlaceMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, place.FieldImages)
}

// SetAvailability sets the "availability" field.
func (m *PlaceMutation) SetAvailability(value map[string]interface{}) {
	m.availability = &value
}

// Availability returns the value of the "availability" field in the mutation.
func (m *PlaceMutation) Availability() (r map[string]interface{}, exists bool) {
	v := m.availability
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailability returns the old "availability" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldAvailability(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailability: %w", err)
	}
	return oldValue.Availability, nil
}

// ClearAvailability clears the value of the "availability" field.
func (m *PlaceMutation) ClearAvailability() {
	m.availability = nil
	m.clearedFields[place.FieldAvailability] = struct{}{}
}

// AvailabilityCleared returns if the "availability" field was cleared in this mutation.
func (m *PlaceMutation) AvailabilityCleared() bool {
	_, ok := m.clearedFields[place.FieldAvailability]
	return ok
}

// ResetAvailability resets all changes to the "availability" field.
func (m *PlaceMutation) ResetAvailability() {
	m.availability = nil
	delete(m.clearedFields, place.FieldAvailability)
}

// SetSpecialOffers sets the "special_offers" field.
func (m *PlaceMutation) SetSpecialOffers(s string) {
	m.special_offers = &s
}

// SpecialOffers returns the value of the "special_offers" field in the mutation.
func (m *PlaceMutation) SpecialOffers() (r string, exists bool) {
	v := m.special_offers
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialOffers returns the old "special_offers" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldSpecialOffers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecialOffers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecialOffers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialOffers: %w", err)
	}
	return oldValue.SpecialOffers, nil
}

// ClearSpecialOffers clears the value of the "special_offers" field.
func (m *PlaceMutation) ClearSpecialOffers() {
	m.special_offers = nil
	m.clearedFields[place.FieldSpecialOffers] = struct{}{}
}

// SpecialOffersCleared returns if the "special_offers" field was cleared in this mutation.
func (m *PlaceMutation) SpecialOffersCleared() bool {
	_, ok := m.clearedFields[place.FieldSpecialOffers]
	return ok
}

// ResetSpecialOffers resets all changes to the "special_offers" field.
func (m *PlaceMutation) ResetSpecialOffers() {
	m.special_offers = nil
	delete(m.clearedFields, place.FieldSpecialOffers)
}

// SetSustainabilityScore sets the "sustainability_score" field.
func (m *PlaceMutation) SetSustainabilityScore(f float64) {
	m.sustainability_score = &f
	m.addsustainability_score = nil
}

// SustainabilityScore returns the value of the "sustainability_score" field in the mutation.
func (m *PlaceMutation) SustainabilityScore() (r float64, exists bool) {
	v := m.sustainability_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSustainabilityScore returns the old "sustainability_score" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldSustainabilityScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSustainabilityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSustainabilityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSustainabilityScore: %w", err)
	}
	return oldValue.SustainabilityScore, nil
}

// AddSustainabilityScore adds f to the "sustainability_score" field.
func (m *PlaceMutation) AddSustainabilityScore(f float64) {
	if m.addsustainability_score != nil {
		*m.addsustainability_score += f
	} else {
		m.addsustainability_score = &f
	}
}

// AddedSustainabilityScore returns the value that was added to the "sustainability_score" field in this mutation.
func (m *PlaceMutation) AddedSustainabilityScore() (r float64, exists bool) {
	v := m.addsustainability_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearSustainabilityScore clears the value of the "sustainability_score" field.
func (m *PlaceMutation) ClearSustainabilityScore() {
	m.sustainability_score = nil
	m.addsustainability_score = nil
	m.clearedFields[place.FieldSustainabilityScore] = struct{}{}
}

// SustainabilityScoreCleared returns if the "sustainability_score" field was cleared in this mutation.
func (m *PlaceMutation) SustainabilityScoreCleared() bool {
	_, ok := m.clearedFields[place.FieldSustainabilityScore]
	return ok
}

// ResetSustainabilityScore resets all changes to the "sustainability_score" field.
func (m *PlaceMutation) ResetSustainabilityScore() {
	m.sustainability_score = nil
	m.addsustainability_score = nil
	delete(m.clearedFields, place.FieldSustainabilityScore)
}

// SetMapCoordinates sets the "map_coordinates" field.
func (m *PlaceMutation) SetMapCoordinates(value map[string]interface{}) {
	m.map_coordinates = &value
}

// MapCoordinates returns the value of the "map_coordinates" field in the mutation.
func (m *PlaceMutation) MapCoordinates() (r map[string]interface{}, exists bool) {
	v := m.map_coordinates
	if v == nil {
		return
	}
	return *v, true
}

// OldMapCoordinates returns the old "map_coordinates" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldMapCoordinates(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMapCoordinates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMapCoordinates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMapCoordinates: %w", err)
	}
	return oldValue.MapCoordinates, nil
}

// ResetMapCoordinates resets all changes to the "map_coordinates" field.
func (m *PlaceMutation) ResetMapCoordinates() {
	m.map_coordinates = nil
}

// SetSearchText sets the "search_text" field.
func (m *PlaceMutation) SetSearchText(s string) {
	m.search_text = &s
}

// SearchText returns the value of the "search_text" field in the mutation.
func (m *PlaceMutation) SearchText() (r string, exists bool) {
	v := m.search_text
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchText returns the old "search_text" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldSearchText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchText: %w", err)
	}
	return oldValue.SearchText, nil
}

// ClearSearchText clears the value of the "search_text" field.
func (m *PlaceMutation) ClearSearchText() {
	m.search_text = nil
	m.clearedFields[place.FieldSearchText] = struct{}{}
}

// SearchTextCleared returns if the "search_text" field was cleared in this mutation.
func (m *PlaceMutation) SearchTextCleared() bool {
	_, ok := m.clearedFields[place.FieldSearchText]
	return ok
}

// ResetSearchText resets all changes to the "search_text" field.
func (m *PlaceMutation) ResetSearchText() {
	m.search_text = nil
	delete(m.clearedFields, place.FieldSearchText)
}

// SetRelevanceScore sets the "relevance_score" field.
func (m *PlaceMutation) SetRelevanceScore(f float64) {
	m.relevance_score = &f
	m.addrelevance_score = nil
}

// RelevanceScore returns the value of the "relevance_score" field in the mutation.
func (m *PlaceMutation) RelevanceScore() (r float64, exists bool) {
	v := m.relevance_score
	if v == nil {
		return
	}
	return *v, true
}

// OldRelevanceScore returns the old "relevance_score" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldRelevanceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelevanceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelevanceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelevanceScore: %w", err)
	}
	return oldValue.RelevanceScore, nil
}

// AddRelevanceScore adds f to the "relevance_score" field.
func (m *PlaceMutation) AddRelevanceScore(f float64) {
	if m.addrelevance_score != nil {
		*m.addrelevance_score += f
	} else {
		m.addrelevance_score = &f
	}
}

// AddedRelevanceScore returns the value that was added to the "relevance_score" field in this mutation.
func (m *PlaceMutation) AddedRelevanceScore() (r float64, exists bool) {
	v := m.addrelevance_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelevanceScore clears the value of the "relevance_score" field.
func (m *PlaceMutation) ClearRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	m.clearedFields[place.FieldRelevanceScore] = struct{}{}
}

// RelevanceScoreCleared returns if the "relevance_score" field was cleared in this mutation.
func (m *PlaceMutation) RelevanceScoreCleared() bool {
	_, ok := m.clearedFields[place.FieldRelevanceScore]
	return ok
}

// ResetRelevanceScore resets all changes to the "relevance_score" field.
func (m *PlaceMutation) ResetRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	delete(m.clearedFields, place.FieldRelevanceScore)
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *PlaceMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *PlaceMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *PlaceMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *PlaceMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *PlaceMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *PlaceMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// AddReviewIDs adds the "reviews" edge to the Review entity by ids.
func (m *PlaceMutation) AddReviewIDs(ids ...string) {
	if m.reviews == nil {
		m.reviews = make(map[string]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the Review entity.
func (m *PlaceMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the Review entity was cleared.
func (m *PlaceMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the Review entity by IDs.
func (m *PlaceMutation) RemoveReviewIDs(ids ...string) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the Review entity.
func (m *PlaceMutation) RemovedReviewsIDs() (ids []string) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *PlaceMutation) ReviewsIDs() (ids []string) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *PlaceMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *PlaceMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *PlaceMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *PlaceMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *PlaceMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *PlaceMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *PlaceMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *PlaceMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddAmenityIDs adds the "amenities" edge to the Amenity entity by ids.
func (m *PlaceMutation) AddAmenityIDs(ids ...string) {
	if m.amenities == nil {
		m.amenities = make(map[string]struct{})
	}
	for i := range ids {
		m.amenities[ids[i]] = struct{}{}
	}
}

// ClearAmenities clears the "amenities" edge to the Amenity entity.
func (m *PlaceMutation) ClearAmenities() {
	m.clearedamenities = true
}

// AmenitiesCleared reports if the "amenities" edge to the Amenity entity was cleared.
func (m *PlaceMutation) AmenitiesCleared() bool {
	return m.clearedamenities
}

// RemoveAmenityIDs removes the "amenities" edge to the Amenity entity by IDs.
func (m *PlaceMutation) RemoveAmenityIDs(ids ...string) {
	if m.removedamenities == nil {
		m.removedamenities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.amenities, ids[i])
		m.removedamenities[ids[i]] = struct{}{}
	}
}

// RemovedAmenities returns the removed IDs of the "amenities" edge to the Amenity entity.
func (m *PlaceMutation) RemovedAmenitiesIDs() (ids []string) {
	for id := range m.removedamenities {
		ids = append(ids, id)
	}
	return
}

// AmenitiesIDs returns the "amenities" edge IDs in the mutation.
func (m *PlaceMutation) AmenitiesIDs() (ids []string) {
	for id := range m.amenities {
		ids = append(ids, id)
	}
	return
}

// ResetAmenities resets all changes to the "amenities" edge.
func (m *PlaceMutation) ResetAmenities() {
	m.amenities = nil
	m.clearedamenities = false
	m.removedamenities = nil
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *PlaceMutation) AddMenuIDs(ids ...string) {
	if m.menus == nil {
		m.menus = make(map[string]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *PlaceMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *PlaceMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *PlaceMutation) RemoveMenuIDs(ids ...string) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *PlaceMutation) RemovedMenusIDs() (ids []string) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *PlaceMutation) MenusIDs() (ids []string) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *PlaceMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddRoomIDs adds the "rooms" edge to the Room entity by ids.
func (m *PlaceMutation) AddRoomIDs(ids ...string) {
	if m.rooms == nil {
		m.rooms = make(map[string]struct{})
	}
	for i := range ids {
		m.rooms[ids[i]] = struct{}{}
	}
}

// ClearRooms clears the "rooms" edge to the Room entity.
func (m *PlaceMutation) ClearRooms() {
	m.clearedrooms = true
}

// RoomsCleared reports if the "rooms" edge to the Room entity was cleared.
func (m *PlaceMutation) RoomsCleared() bool {
	return m.clearedrooms
}

// RemoveRoomIDs removes the "rooms" edge to the Room entity by IDs.
func (m *PlaceMutation) RemoveRoomIDs(ids ...string) {
	if m.removedrooms == nil {
		m.removedrooms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rooms, ids[i])
		m.removedrooms[ids[i]] = struct{}{}
	}
}

// RemovedRooms returns the removed IDs of the "rooms" edge to the Room entity.
func (m *PlaceMutation) RemovedRoomsIDs() (ids []string) {
	for id := range m.removedrooms {
		ids = append(ids, id)
	}
	return
}

// RoomsIDs returns the "rooms" edge IDs in the mutation.
func (m *PlaceMutation) RoomsIDs() (ids []string) {
	for id := range m.rooms {
		ids = append(ids, id)
	}
	return
}

// ResetRooms resets all changes to the "rooms" edge.
func (m *PlaceMutation) ResetRooms() {
	m.rooms = nil
	m.clearedrooms = false
	m.removedrooms = nil
}

// AddReservationIDs adds the "reservations" edge to the Reservation entity by ids.
func (m *PlaceMutation) AddReservationIDs(ids ...string) {
	if m.reservations == nil {
		m.reservations = make(map[string]struct{})
	}
	for i := range ids {
		m.reservations[ids[i]] = struct{}{}
	}
}

// ClearReservations clears the "reservations" edge to the Reservation entity.
func (m *PlaceMutation) ClearReservations() {
	m.clearedreservations = true
}

// ReservationsCleared reports if the "reservations" edge to the Reservation entity was cleared.
func (m *PlaceMutation) ReservationsCleared() bool {
	return m.clearedreservations
}

// RemoveReservationIDs removes the "reservations" edge to the Reservation entity by IDs.
func (m *PlaceMutation) RemoveReservationIDs(ids ...string) {
	if m.removedreservations == nil {
		m.removedreservations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reservations, ids[i])
		m.removedreservations[ids[i]] = struct{}{}
	}
}

// RemovedReservations returns the removed IDs of the "reservations" edge to the Reservation entity.
func (m *PlaceMutation) RemovedReservationsIDs() (ids []string) {
	for id := range m.removedreservations {
		ids = append(ids, id)
	}
	return
}

// ReservationsIDs returns the "reservations" edge IDs in the mutation.
func (m *PlaceMutation) ReservationsIDs() (ids []string) {
	for id := range m.reservations {
		ids = append(ids, id)
	}
	return
}

// ResetReservations resets all changes to the "reservations" edge.
func (m *PlaceMutation) ResetReservations() {
	m.reservations = nil
	m.clearedreservations = false
	m.removedreservations = nil
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *PlaceMutation) AddBookingIDs(ids ...string) {
	if m.bookings == nil {
		m.bookings = make(map[string]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *PlaceMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *PlaceMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *PlaceMutation) RemoveBookingIDs(ids ...string) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *PlaceMutation) RemovedBookingsIDs() (ids []string) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *PlaceMutation) BookingsIDs() (ids []string) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *PlaceMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *PlaceMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *PlaceMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *PlaceMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *PlaceMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *PlaceMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *PlaceMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *PlaceMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddCategoryAssignmentIDs adds the "categoryAssignments" edge to the CategoryAssignment entity by ids.
func (m *PlaceMutation) AddCategoryAssignmentIDs(ids ...string) {
	if m.categoryAssignments == nil {
		m.categoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		m.categoryAssignments[ids[i]] = struct{}{}
	}
}

// ClearCategoryAssignments clears the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *PlaceMutation) ClearCategoryAssignments() {
	m.clearedcategoryAssignments = true
}

// CategoryAssignmentsCleared reports if the "categoryAssignments" edge to the CategoryAssignment entity was cleared.
func (m *PlaceMutation) CategoryAssignmentsCleared() bool {
	return m.clearedcategoryAssignments
}

// RemoveCategoryAssignmentIDs removes the "categoryAssignments" edge to the CategoryAssignment entity by IDs.
func (m *PlaceMutation) RemoveCategoryAssignmentIDs(ids ...string) {
	if m.removedcategoryAssignments == nil {
		m.removedcategoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categoryAssignments, ids[i])
		m.removedcategoryAssignments[ids[i]] = struct{}{}
	}
}

// RemovedCategoryAssignments returns the removed IDs of the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *PlaceMutation) RemovedCategoryAssignmentsIDs() (ids []string) {
	for id := range m.removedcategoryAssignments {
		ids = append(ids, id)
	}
	return
}

// CategoryAssignmentsIDs returns the "categoryAssignments" edge IDs in the mutation.
func (m *PlaceMutation) CategoryAssignmentsIDs() (ids []string) {
	for id := range m.categoryAssignments {
		ids = append(ids, id)
	}
	return
}

// ResetCategoryAssignments resets all changes to the "categoryAssignments" edge.
func (m *PlaceMutation) ResetCategoryAssignments() {
	m.categoryAssignments = nil
	m.clearedcategoryAssignments = false
	m.removedcategoryAssignments = nil
}

// Where appends a list predicates to the PlaceMutation builder.
func (m *PlaceMutation) Where(ps ...predicate.Place) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Place, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Place).
func (m *PlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaceMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, place.FieldName)
	}
	if m._type != nil {
		fields = append(fields, place.FieldType)
	}
	if m.description != nil {
		fields = append(fields, place.FieldDescription)
	}
	if m.location != nil {
		fields = append(fields, place.FieldLocation)
	}
	if m.images != nil {
		fields = append(fields, place.FieldImages)
	}
	if m.availability != nil {
		fields = append(fields, place.FieldAvailability)
	}
	if m.special_offers != nil {
		fields = append(fields, place.FieldSpecialOffers)
	}
	if m.sustainability_score != nil {
		fields = append(fields, place.FieldSustainabilityScore)
	}
	if m.map_coordinates != nil {
		fields = append(fields, place.FieldMapCoordinates)
	}
	if m.search_text != nil {
		fields = append(fields, place.FieldSearchText)
	}
	if m.relevance_score != nil {
		fields = append(fields, place.FieldRelevanceScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case place.FieldName:
		return m.Name()
	case place.FieldType:
		return m.GetType()
	case place.FieldDescription:
		return m.Description()
	case place.FieldLocation:
		return m.Location()
	case place.FieldImages:
		return m.Images()
	case place.FieldAvailability:
		return m.Availability()
	case place.FieldSpecialOffers:
		return m.SpecialOffers()
	case place.FieldSustainabilityScore:
		return m.SustainabilityScore()
	case place.FieldMapCoordinates:
		return m.MapCoordinates()
	case place.FieldSearchText:
		return m.SearchText()
	case place.FieldRelevanceScore:
		return m.RelevanceScore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case place.FieldName:
		return m.OldName(ctx)
	case place.FieldType:
		return m.OldType(ctx)
	case place.FieldDescription:
		return m.OldDescription(ctx)
	case place.FieldLocation:
		return m.OldLocation(ctx)
	case place.FieldImages:
		return m.OldImages(ctx)
	case place.FieldAvailability:
		return m.OldAvailability(ctx)
	case place.FieldSpecialOffers:
		return m.OldSpecialOffers(ctx)
	case place.FieldSustainabilityScore:
		return m.OldSustainabilityScore(ctx)
	case place.FieldMapCoordinates:
		return m.OldMapCoordinates(ctx)
	case place.FieldSearchText:
		return m.OldSearchText(ctx)
	case place.FieldRelevanceScore:
		return m.OldRelevanceScore(ctx)
	}
	return nil, fmt.Errorf("unknown Place field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case place.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case place.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case place.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case place.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case place.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case place.FieldAvailability:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailability(v)
		return nil
	case place.FieldSpecialOffers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialOffers(v)
		return nil
	case place.FieldSustainabilityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSustainabilityScore(v)
		return nil
	case place.FieldMapCoordinates:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMapCoordinates(v)
		return nil
	case place.FieldSearchText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchText(v)
		return nil
	case place.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelevanceScore(v)
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaceMutation) AddedFields() []string {
	var fields []string
	if m.addsustainability_score != nil {
		fields = append(fields, place.FieldSustainabilityScore)
	}
	if m.addrelevance_score != nil {
		fields = append(fields, place.FieldRelevanceScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case place.FieldSustainabilityScore:
		return m.AddedSustainabilityScore()
	case place.FieldRelevanceScore:
		return m.AddedRelevanceScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case place.FieldSustainabilityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSustainabilityScore(v)
		return nil
	case place.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelevanceScore(v)
		return nil
	}
	return fmt.Errorf("unknown Place numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(place.FieldDescription) {
		fields = append(fields, place.FieldDescription)
	}
	if m.FieldCleared(place.FieldImages) {
		fields = append(fields, place.FieldImages)
	}
	if m.FieldCleared(place.FieldAvailability) {
		fields = append(fields, place.FieldAvailability)
	}
	if m.FieldCleared(place.FieldSpecialOffers) {
		fields = append(fields, place.FieldSpecialOffers)
	}
	if m.FieldCleared(place.FieldSustainabilityScore) {
		fields = append(fields, place.FieldSustainabilityScore)
	}
	if m.FieldCleared(place.FieldSearchText) {
		fields = append(fields, place.FieldSearchText)
	}
	if m.FieldCleared(place.FieldRelevanceScore) {
		fields = append(fields, place.FieldRelevanceScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceMutation) ClearField(name string) error {
	switch name {
	case place.FieldDescription:
		m.ClearDescription()
		return nil
	case place.FieldImages:
		m.ClearImages()
		return nil
	case place.FieldAvailability:
		m.ClearAvailability()
		return nil
	case place.FieldSpecialOffers:
		m.ClearSpecialOffers()
		return nil
	case place.FieldSustainabilityScore:
		m.ClearSustainabilityScore()
		return nil
	case place.FieldSearchText:
		m.ClearSearchText()
		return nil
	case place.FieldRelevanceScore:
		m.ClearRelevanceScore()
		return nil
	}
	return fmt.Errorf("unknown Place nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaceMutation) ResetField(name string) error {
	switch name {
	case place.FieldName:
		m.ResetName()
		return nil
	case place.FieldType:
		m.ResetType()
		return nil
	case place.FieldDescription:
		m.ResetDescription()
		return nil
	case place.FieldLocation:
		m.ResetLocation()
		return nil
	case place.FieldImages:
		m.ResetImages()
		return nil
	case place.FieldAvailability:
		m.ResetAvailability()
		return nil
	case place.FieldSpecialOffers:
		m.ResetSpecialOffers()
		return nil
	case place.FieldSustainabilityScore:
		m.ResetSustainabilityScore()
		return nil
	case place.FieldMapCoordinates:
		m.ResetMapCoordinates()
		return nil
	case place.FieldSearchText:
		m.ResetSearchText()
		return nil
	case place.FieldRelevanceScore:
		m.ResetRelevanceScore()
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.business != nil {
		edges = append(edges, place.EdgeBusiness)
	}
	if m.reviews != nil {
		edges = append(edges, place.EdgeReviews)
	}
	if m.events != nil {
		edges = append(edges, place.EdgeEvents)
	}
	if m.amenities != nil {
		edges = append(edges, place.EdgeAmenities)
	}
	if m.menus != nil {
		edges = append(edges, place.EdgeMenus)
	}
	if m.rooms != nil {
		edges = append(edges, place.EdgeRooms)
	}
	if m.reservations != nil {
		edges = append(edges, place.EdgeReservations)
	}
	if m.bookings != nil {
		edges = append(edges, place.EdgeBookings)
	}
	if m.categories != nil {
		edges = append(edges, place.EdgeCategories)
	}
	if m.categoryAssignments != nil {
		edges = append(edges, place.EdgeCategoryAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case place.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case place.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeAmenities:
		ids := make([]ent.Value, 0, len(m.amenities))
		for id := range m.amenities {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.rooms))
		for id := range m.rooms {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.reservations))
		for id := range m.reservations {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.categoryAssignments))
		for id := range m.categoryAssignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedreviews != nil {
		edges = append(edges, place.EdgeReviews)
	}
	if m.removedevents != nil {
		edges = append(edges, place.EdgeEvents)
	}
	if m.removedamenities != nil {
		edges = append(edges, place.EdgeAmenities)
	}
	if m.removedmenus != nil {
		edges = append(edges, place.EdgeMenus)
	}
	if m.removedrooms != nil {
		edges = append(edges, place.EdgeRooms)
	}
	if m.removedreservations != nil {
		edges = append(edges, place.EdgeReservations)
	}
	if m.removedbookings != nil {
		edges = append(edges, place.EdgeBookings)
	}
	if m.removedcategories != nil {
		edges = append(edges, place.EdgeCategories)
	}
	if m.removedcategoryAssignments != nil {
		edges = append(edges, place.EdgeCategoryAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case place.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeAmenities:
		ids := make([]ent.Value, 0, len(m.removedamenities))
		for id := range m.removedamenities {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.removedrooms))
		for id := range m.removedrooms {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.removedreservations))
		for id := range m.removedreservations {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case place.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.removedcategoryAssignments))
		for id := range m.removedcategoryAssignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedbusiness {
		edges = append(edges, place.EdgeBusiness)
	}
	if m.clearedreviews {
		edges = append(edges, place.EdgeReviews)
	}
	if m.clearedevents {
		edges = append(edges, place.EdgeEvents)
	}
	if m.clearedamenities {
		edges = append(edges, place.EdgeAmenities)
	}
	if m.clearedmenus {
		edges = append(edges, place.EdgeMenus)
	}
	if m.clearedrooms {
		edges = append(edges, place.EdgeRooms)
	}
	if m.clearedreservations {
		edges = append(edges, place.EdgeReservations)
	}
	if m.clearedbookings {
		edges = append(edges, place.EdgeBookings)
	}
	if m.clearedcategories {
		edges = append(edges, place.EdgeCategories)
	}
	if m.clearedcategoryAssignments {
		edges = append(edges, place.EdgeCategoryAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case place.EdgeBusiness:
		return m.clearedbusiness
	case place.EdgeReviews:
		return m.clearedreviews
	case place.EdgeEvents:
		return m.clearedevents
	case place.EdgeAmenities:
		return m.clearedamenities
	case place.EdgeMenus:
		return m.clearedmenus
	case place.EdgeRooms:
		return m.clearedrooms
	case place.EdgeReservations:
		return m.clearedreservations
	case place.EdgeBookings:
		return m.clearedbookings
	case place.EdgeCategories:
		return m.clearedcategories
	case place.EdgeCategoryAssignments:
		return m.clearedcategoryAssignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaceMutation) ClearEdge(name string) error {
	switch name {
	case place.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown Place unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaceMutation) ResetEdge(name string) error {
	switch name {
	case place.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case place.EdgeReviews:
		m.ResetReviews()
		return nil
	case place.EdgeEvents:
		m.ResetEvents()
		return nil
	case place.EdgeAmenities:
		m.ResetAmenities()
		return nil
	case place.EdgeMenus:
		m.ResetMenus()
		return nil
	case place.EdgeRooms:
		m.ResetRooms()
		return nil
	case place.EdgeReservations:
		m.ResetReservations()
		return nil
	case place.EdgeBookings:
		m.ResetBookings()
		return nil
	case place.EdgeCategories:
		m.ResetCategories()
		return nil
	case place.EdgeCategoryAssignments:
		m.ResetCategoryAssignments()
		return nil
	}
	return fmt.Errorf("unknown Place edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	_Content                *string
	_CreatedAt              *time.Time
	_UpdatedAt              *time.Time
	_Privacy                *post.Privacy
	clearedFields           map[string]struct{}
	user                    *string
	cleareduser             bool
	business_account        *string
	clearedbusiness_account bool
	medias                  map[string]struct{}
	removedmedias           map[string]struct{}
	clearedmedias           bool
	comments                map[string]struct{}
	removedcomments         map[string]struct{}
	clearedcomments         bool
	likes                   map[string]struct{}
	removedlikes            map[string]struct{}
	clearedlikes            bool
	categories              map[string]struct{}
	removedcategories       map[string]struct{}
	clearedcategories       bool
	done                    bool
	oldValue                func(context.Context) (*Post, error)
	predicates              []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id string) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "Content" field.
func (m *PostMutation) SetContent(s string) {
	m._Content = &s
}

// Content returns the value of the "Content" field in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m._Content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "Content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "Content" field.
func (m *PostMutation) ResetContent() {
	m._Content = nil
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *PostMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *PostMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetPrivacy sets the "Privacy" field.
func (m *PostMutation) SetPrivacy(po post.Privacy) {
	m._Privacy = &po
}

// Privacy returns the value of the "Privacy" field in the mutation.
func (m *PostMutation) Privacy() (r post.Privacy, exists bool) {
	v := m._Privacy
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivacy returns the old "Privacy" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPrivacy(ctx context.Context) (v post.Privacy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivacy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivacy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivacy: %w", err)
	}
	return oldValue.Privacy, nil
}

// ResetPrivacy resets all changes to the "Privacy" field.
func (m *PostMutation) ResetPrivacy() {
	m._Privacy = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PostMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PostMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PostMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PostMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PostMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PostMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBusinessAccountID sets the "business_account" edge to the Business entity by id.
func (m *PostMutation) SetBusinessAccountID(id string) {
	m.business_account = &id
}

// ClearBusinessAccount clears the "business_account" edge to the Business entity.
func (m *PostMutation) ClearBusinessAccount() {
	m.clearedbusiness_account = true
}

// BusinessAccountCleared reports if the "business_account" edge to the Business entity was cleared.
func (m *PostMutation) BusinessAccountCleared() bool {
	return m.clearedbusiness_account
}

// BusinessAccountID returns the "business_account" edge ID in the mutation.
func (m *PostMutation) BusinessAccountID() (id string, exists bool) {
	if m.business_account != nil {
		return *m.business_account, true
	}
	return
}

// BusinessAccountIDs returns the "business_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessAccountID instead. It exists only for internal usage by the builders.
func (m *PostMutation) BusinessAccountIDs() (ids []string) {
	if id := m.business_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessAccount resets all changes to the "business_account" edge.
func (m *PostMutation) ResetBusinessAccount() {
	m.business_account = nil
	m.clearedbusiness_account = false
}

// AddMediaIDs adds the "medias" edge to the Media entity by ids.
func (m *PostMutation) AddMediaIDs(ids ...string) {
	if m.medias == nil {
		m.medias = make(map[string]struct{})
	}
	for i := range ids {
		m.medias[ids[i]] = struct{}{}
	}
}

// ClearMedias clears the "medias" edge to the Media entity.
func (m *PostMutation) ClearMedias() {
	m.clearedmedias = true
}

// MediasCleared reports if the "medias" edge to the Media entity was cleared.
func (m *PostMutation) MediasCleared() bool {
	return m.clearedmedias
}

// RemoveMediaIDs removes the "medias" edge to the Media entity by IDs.
func (m *PostMutation) RemoveMediaIDs(ids ...string) {
	if m.removedmedias == nil {
		m.removedmedias = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.medias, ids[i])
		m.removedmedias[ids[i]] = struct{}{}
	}
}

// RemovedMedias returns the removed IDs of the "medias" edge to the Media entity.
func (m *PostMutation) RemovedMediasIDs() (ids []string) {
	for id := range m.removedmedias {
		ids = append(ids, id)
	}
	return
}

// MediasIDs returns the "medias" edge IDs in the mutation.
func (m *PostMutation) MediasIDs() (ids []string) {
	for id := range m.medias {
		ids = append(ids, id)
	}
	return
}

// ResetMedias resets all changes to the "medias" edge.
func (m *PostMutation) ResetMedias() {
	m.medias = nil
	m.clearedmedias = false
	m.removedmedias = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *PostMutation) AddCommentIDs(ids ...string) {
	if m.comments == nil {
		m.comments = make(map[string]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *PostMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *PostMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *PostMutation) RemoveCommentIDs(ids ...string) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *PostMutation) RemovedCommentsIDs() (ids []string) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *PostMutation) CommentsIDs() (ids []string) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *PostMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddLikeIDs adds the "likes" edge to the Like entity by ids.
func (m *PostMutation) AddLikeIDs(ids ...string) {
	if m.likes == nil {
		m.likes = make(map[string]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the Like entity.
func (m *PostMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the Like entity was cleared.
func (m *PostMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the Like entity by IDs.
func (m *PostMutation) RemoveLikeIDs(ids ...string) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the Like entity.
func (m *PostMutation) RemovedLikesIDs() (ids []string) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *PostMutation) LikesIDs() (ids []string) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *PostMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *PostMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *PostMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *PostMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *PostMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *PostMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *PostMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *PostMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m._CreatedAt != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m._Privacy != nil {
		fields = append(fields, post.FieldPrivacy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldContent:
		return m.Content()
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldPrivacy:
		return m.Privacy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldContent:
		return m.OldContent(ctx)
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case post.FieldPrivacy:
		return m.OldPrivacy(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldPrivacy:
		v, ok := value.(post.Privacy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivacy(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldPrivacy:
		m.ResetPrivacy()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.user != nil {
		edges = append(edges, post.EdgeUser)
	}
	if m.business_account != nil {
		edges = append(edges, post.EdgeBusinessAccount)
	}
	if m.medias != nil {
		edges = append(edges, post.EdgeMedias)
	}
	if m.comments != nil {
		edges = append(edges, post.EdgeComments)
	}
	if m.likes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	if m.categories != nil {
		edges = append(edges, post.EdgeCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeBusinessAccount:
		if id := m.business_account; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeMedias:
		ids := make([]ent.Value, 0, len(m.medias))
		for id := range m.medias {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedmedias != nil {
		edges = append(edges, post.EdgeMedias)
	}
	if m.removedcomments != nil {
		edges = append(edges, post.EdgeComments)
	}
	if m.removedlikes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	if m.removedcategories != nil {
		edges = append(edges, post.EdgeCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeMedias:
		ids := make([]ent.Value, 0, len(m.removedmedias))
		for id := range m.removedmedias {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareduser {
		edges = append(edges, post.EdgeUser)
	}
	if m.clearedbusiness_account {
		edges = append(edges, post.EdgeBusinessAccount)
	}
	if m.clearedmedias {
		edges = append(edges, post.EdgeMedias)
	}
	if m.clearedcomments {
		edges = append(edges, post.EdgeComments)
	}
	if m.clearedlikes {
		edges = append(edges, post.EdgeLikes)
	}
	if m.clearedcategories {
		edges = append(edges, post.EdgeCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeUser:
		return m.cleareduser
	case post.EdgeBusinessAccount:
		return m.clearedbusiness_account
	case post.EdgeMedias:
		return m.clearedmedias
	case post.EdgeComments:
		return m.clearedcomments
	case post.EdgeLikes:
		return m.clearedlikes
	case post.EdgeCategories:
		return m.clearedcategories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeUser:
		m.ClearUser()
		return nil
	case post.EdgeBusinessAccount:
		m.ClearBusinessAccount()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeUser:
		m.ResetUser()
		return nil
	case post.EdgeBusinessAccount:
		m.ResetBusinessAccount()
		return nil
	case post.EdgeMedias:
		m.ResetMedias()
		return nil
	case post.EdgeComments:
		m.ResetComments()
		return nil
	case post.EdgeLikes:
		m.ResetLikes()
		return nil
	case post.EdgeCategories:
		m.ResetCategories()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// RatingMutation represents an operation that mutates the Rating nodes in the graph.
type RatingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Rating, error)
	predicates    []predicate.Rating
}

var _ ent.Mutation = (*RatingMutation)(nil)

// ratingOption allows management of the mutation configuration using functional options.
type ratingOption func(*RatingMutation)

// newRatingMutation creates new mutation for the Rating entity.
func newRatingMutation(c config, op Op, opts ...ratingOption) *RatingMutation {
	m := &RatingMutation{
		config:        c,
		op:            op,
		typ:           TypeRating,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRatingID sets the ID field of the mutation.
func withRatingID(id string) ratingOption {
	return func(m *RatingMutation) {
		var (
			err   error
			once  sync.Once
			value *Rating
		)
		m.oldValue = func(ctx context.Context) (*Rating, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rating.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRating sets the old Rating of the mutation.
func withRating(node *Rating) ratingOption {
	return func(m *RatingMutation) {
		m.oldValue = func(context.Context) (*Rating, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RatingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RatingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RatingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RatingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rating.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the RatingMutation builder.
func (m *RatingMutation) Where(ps ...predicate.Rating) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RatingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RatingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Rating, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RatingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RatingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Rating).
func (m *RatingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RatingMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RatingMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RatingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Rating field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RatingMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Rating field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RatingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RatingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RatingMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Rating numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RatingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RatingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RatingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Rating nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RatingMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Rating field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RatingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RatingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RatingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RatingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RatingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RatingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RatingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Rating unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RatingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Rating edge %s", name)
}

// ReactionMutation represents an operation that mutates the Reaction nodes in the graph.
type ReactionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Reaction, error)
	predicates    []predicate.Reaction
}

var _ ent.Mutation = (*ReactionMutation)(nil)

// reactionOption allows management of the mutation configuration using functional options.
type reactionOption func(*ReactionMutation)

// newReactionMutation creates new mutation for the Reaction entity.
func newReactionMutation(c config, op Op, opts ...reactionOption) *ReactionMutation {
	m := &ReactionMutation{
		config:        c,
		op:            op,
		typ:           TypeReaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReactionID sets the ID field of the mutation.
func withReactionID(id string) reactionOption {
	return func(m *ReactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Reaction
		)
		m.oldValue = func(ctx context.Context) (*Reaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReaction sets the old Reaction of the mutation.
func withReaction(node *Reaction) reactionOption {
	return func(m *ReactionMutation) {
		m.oldValue = func(context.Context) (*Reaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReactionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReactionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ReactionMutation builder.
func (m *ReactionMutation) Where(ps ...predicate.Reaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reaction).
func (m *ReactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReactionMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReactionMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Reaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Reaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReactionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReactionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactionMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Reaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Reaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReactionMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Reaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReactionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReactionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReactionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Reaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReactionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Reaction edge %s", name)
}

// ReservationMutation represents an operation that mutates the Reservation nodes in the graph.
type ReservationMutation struct {
	config
	op                Op
	typ               string
	id                *string
	date              *time.Time
	time              *time.Time
	numberOfPeople    *int
	addnumberOfPeople *int
	status            *string
	clearedFields     map[string]struct{}
	place             *string
	clearedplace      bool
	user              *string
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*Reservation, error)
	predicates        []predicate.Reservation
}

var _ ent.Mutation = (*ReservationMutation)(nil)

// reservationOption allows management of the mutation configuration using functional options.
type reservationOption func(*ReservationMutation)

// newReservationMutation creates new mutation for the Reservation entity.
func newReservationMutation(c config, op Op, opts ...reservationOption) *ReservationMutation {
	m := &ReservationMutation{
		config:        c,
		op:            op,
		typ:           TypeReservation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReservationID sets the ID field of the mutation.
func withReservationID(id string) reservationOption {
	return func(m *ReservationMutation) {
		var (
			err   error
			once  sync.Once
			value *Reservation
		)
		m.oldValue = func(ctx context.Context) (*Reservation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reservation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReservation sets the old Reservation of the mutation.
func withReservation(node *Reservation) reservationOption {
	return func(m *ReservationMutation) {
		m.oldValue = func(context.Context) (*Reservation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReservationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReservationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Reservation entities.
func (m *ReservationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReservationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReservationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reservation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *ReservationMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *ReservationMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *ReservationMutation) ResetDate() {
	m.date = nil
}

// SetTime sets the "time" field.
func (m *ReservationMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *ReservationMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *ReservationMutation) ResetTime() {
	m.time = nil
}

// SetNumberOfPeople sets the "numberOfPeople" field.
func (m *ReservationMutation) SetNumberOfPeople(i int) {
	m.numberOfPeople = &i
	m.addnumberOfPeople = nil
}

// NumberOfPeople returns the value of the "numberOfPeople" field in the mutation.
func (m *ReservationMutation) NumberOfPeople() (r int, exists bool) {
	v := m.numberOfPeople
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberOfPeople returns the old "numberOfPeople" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldNumberOfPeople(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberOfPeople is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberOfPeople requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberOfPeople: %w", err)
	}
	return oldValue.NumberOfPeople, nil
}

// AddNumberOfPeople adds i to the "numberOfPeople" field.
func (m *ReservationMutation) AddNumberOfPeople(i int) {
	if m.addnumberOfPeople != nil {
		*m.addnumberOfPeople += i
	} else {
		m.addnumberOfPeople = &i
	}
}

// AddedNumberOfPeople returns the value that was added to the "numberOfPeople" field in this mutation.
func (m *ReservationMutation) AddedNumberOfPeople() (r int, exists bool) {
	v := m.addnumberOfPeople
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumberOfPeople resets all changes to the "numberOfPeople" field.
func (m *ReservationMutation) ResetNumberOfPeople() {
	m.numberOfPeople = nil
	m.addnumberOfPeople = nil
}

// SetStatus sets the "status" field.
func (m *ReservationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ReservationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReservationMutation) ResetStatus() {
	m.status = nil
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *ReservationMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *ReservationMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *ReservationMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *ReservationMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *ReservationMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *ReservationMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ReservationMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ReservationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ReservationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ReservationMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ReservationMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ReservationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ReservationMutation builder.
func (m *ReservationMutation) Where(ps ...predicate.Reservation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReservationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReservationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reservation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReservationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReservationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reservation).
func (m *ReservationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReservationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.date != nil {
		fields = append(fields, reservation.FieldDate)
	}
	if m.time != nil {
		fields = append(fields, reservation.FieldTime)
	}
	if m.numberOfPeople != nil {
		fields = append(fields, reservation.FieldNumberOfPeople)
	}
	if m.status != nil {
		fields = append(fields, reservation.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReservationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reservation.FieldDate:
		return m.Date()
	case reservation.FieldTime:
		return m.Time()
	case reservation.FieldNumberOfPeople:
		return m.NumberOfPeople()
	case reservation.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReservationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reservation.FieldDate:
		return m.OldDate(ctx)
	case reservation.FieldTime:
		return m.OldTime(ctx)
	case reservation.FieldNumberOfPeople:
		return m.OldNumberOfPeople(ctx)
	case reservation.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Reservation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReservationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reservation.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case reservation.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case reservation.FieldNumberOfPeople:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberOfPeople(v)
		return nil
	case reservation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Reservation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReservationMutation) AddedFields() []string {
	var fields []string
	if m.addnumberOfPeople != nil {
		fields = append(fields, reservation.FieldNumberOfPeople)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReservationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reservation.FieldNumberOfPeople:
		return m.AddedNumberOfPeople()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReservationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reservation.FieldNumberOfPeople:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberOfPeople(v)
		return nil
	}
	return fmt.Errorf("unknown Reservation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReservationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReservationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReservationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Reservation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReservationMutation) ResetField(name string) error {
	switch name {
	case reservation.FieldDate:
		m.ResetDate()
		return nil
	case reservation.FieldTime:
		m.ResetTime()
		return nil
	case reservation.FieldNumberOfPeople:
		m.ResetNumberOfPeople()
		return nil
	case reservation.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Reservation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReservationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.place != nil {
		edges = append(edges, reservation.EdgePlace)
	}
	if m.user != nil {
		edges = append(edges, reservation.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReservationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reservation.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	case reservation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReservationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReservationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReservationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplace {
		edges = append(edges, reservation.EdgePlace)
	}
	if m.cleareduser {
		edges = append(edges, reservation.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReservationMutation) EdgeCleared(name string) bool {
	switch name {
	case reservation.EdgePlace:
		return m.clearedplace
	case reservation.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReservationMutation) ClearEdge(name string) error {
	switch name {
	case reservation.EdgePlace:
		m.ClearPlace()
		return nil
	case reservation.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Reservation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReservationMutation) ResetEdge(name string) error {
	switch name {
	case reservation.EdgePlace:
		m.ResetPlace()
		return nil
	case reservation.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Reservation edge %s", name)
}

// ReviewMutation represents an operation that mutates the Review nodes in the graph.
type ReviewMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	rating              *float64
	addrating           *float64
	comment             *string
	images_videos       *[]string
	appendimages_videos []string
	timestamp           *time.Time
	clearedFields       map[string]struct{}
	user                *string
	cleareduser         bool
	place               *string
	clearedplace        bool
	done                bool
	oldValue            func(context.Context) (*Review, error)
	predicates          []predicate.Review
}

var _ ent.Mutation = (*ReviewMutation)(nil)

// reviewOption allows management of the mutation configuration using functional options.
type reviewOption func(*ReviewMutation)

// newReviewMutation creates new mutation for the Review entity.
func newReviewMutation(c config, op Op, opts ...reviewOption) *ReviewMutation {
	m := &ReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewID sets the ID field of the mutation.
func withReviewID(id string) reviewOption {
	return func(m *ReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Review
		)
		m.oldValue = func(ctx context.Context) (*Review, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Review.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReview sets the old Review of the mutation.
func withReview(node *Review) reviewOption {
	return func(m *ReviewMutation) {
		m.oldValue = func(context.Context) (*Review, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Review entities.
func (m *ReviewMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Review.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRating sets the "rating" field.
func (m *ReviewMutation) SetRating(f float64) {
	m.rating = &f
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *ReviewMutation) Rating() (r float64, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds f to the "rating" field.
func (m *ReviewMutation) AddRating(f float64) {
	if m.addrating != nil {
		*m.addrating += f
	} else {
		m.addrating = &f
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *ReviewMutation) AddedRating() (r float64, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *ReviewMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetComment sets the "comment" field.
func (m *ReviewMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ReviewMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *ReviewMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[review.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *ReviewMutation) CommentCleared() bool {
	_, ok := m.clearedFields[review.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *ReviewMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, review.FieldComment)
}

// SetImagesVideos sets the "images_videos" field.
func (m *ReviewMutation) SetImagesVideos(s []string) {
	m.images_videos = &s
	m.appendimages_videos = nil
}

// ImagesVideos returns the value of the "images_videos" field in the mutation.
func (m *ReviewMutation) ImagesVideos() (r []string, exists bool) {
	v := m.images_videos
	if v == nil {
		return
	}
	return *v, true
}

// OldImagesVideos returns the old "images_videos" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldImagesVideos(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImagesVideos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImagesVideos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImagesVideos: %w", err)
	}
	return oldValue.ImagesVideos, nil
}

// AppendImagesVideos adds s to the "images_videos" field.
func (m *ReviewMutation) AppendImagesVideos(s []string) {
	m.appendimages_videos = append(m.appendimages_videos, s...)
}

// AppendedImagesVideos returns the list of values that were appended to the "images_videos" field in this mutation.
func (m *ReviewMutation) AppendedImagesVideos() ([]string, bool) {
	if len(m.appendimages_videos) == 0 {
		return nil, false
	}
	return m.appendimages_videos, true
}

// ClearImagesVideos clears the value of the "images_videos" field.
func (m *ReviewMutation) ClearImagesVideos() {
	m.images_videos = nil
	m.appendimages_videos = nil
	m.clearedFields[review.FieldImagesVideos] = struct{}{}
}

// ImagesVideosCleared returns if the "images_videos" field was cleared in this mutation.
func (m *ReviewMutation) ImagesVideosCleared() bool {
	_, ok := m.clearedFields[review.FieldImagesVideos]
	return ok
}

// ResetImagesVideos resets all changes to the "images_videos" field.
func (m *ReviewMutation) ResetImagesVideos() {
	m.images_videos = nil
	m.appendimages_videos = nil
	delete(m.clearedFields, review.FieldImagesVideos)
}

// SetTimestamp sets the "timestamp" field.
func (m *ReviewMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *ReviewMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *ReviewMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ReviewMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ReviewMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ReviewMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ReviewMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ReviewMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *ReviewMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *ReviewMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *ReviewMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *ReviewMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *ReviewMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// Where appends a list predicates to the ReviewMutation builder.
func (m *ReviewMutation) Where(ps ...predicate.Review) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Review, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Review).
func (m *ReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.rating != nil {
		fields = append(fields, review.FieldRating)
	}
	if m.comment != nil {
		fields = append(fields, review.FieldComment)
	}
	if m.images_videos != nil {
		fields = append(fields, review.FieldImagesVideos)
	}
	if m.timestamp != nil {
		fields = append(fields, review.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case review.FieldRating:
		return m.Rating()
	case review.FieldComment:
		return m.Comment()
	case review.FieldImagesVideos:
		return m.ImagesVideos()
	case review.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case review.FieldRating:
		return m.OldRating(ctx)
	case review.FieldComment:
		return m.OldComment(ctx)
	case review.FieldImagesVideos:
		return m.OldImagesVideos(ctx)
	case review.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Review field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case review.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case review.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case review.FieldImagesVideos:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImagesVideos(v)
		return nil
	case review.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewMutation) AddedFields() []string {
	var fields []string
	if m.addrating != nil {
		fields = append(fields, review.FieldRating)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case review.FieldRating:
		return m.AddedRating()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case review.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	}
	return fmt.Errorf("unknown Review numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(review.FieldComment) {
		fields = append(fields, review.FieldComment)
	}
	if m.FieldCleared(review.FieldImagesVideos) {
		fields = append(fields, review.FieldImagesVideos)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewMutation) ClearField(name string) error {
	switch name {
	case review.FieldComment:
		m.ClearComment()
		return nil
	case review.FieldImagesVideos:
		m.ClearImagesVideos()
		return nil
	}
	return fmt.Errorf("unknown Review nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewMutation) ResetField(name string) error {
	switch name {
	case review.FieldRating:
		m.ResetRating()
		return nil
	case review.FieldComment:
		m.ResetComment()
		return nil
	case review.FieldImagesVideos:
		m.ResetImagesVideos()
		return nil
	case review.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, review.EdgeUser)
	}
	if m.place != nil {
		edges = append(edges, review.EdgePlace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case review.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, review.EdgeUser)
	}
	if m.clearedplace {
		edges = append(edges, review.EdgePlace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case review.EdgeUser:
		return m.cleareduser
	case review.EdgePlace:
		return m.clearedplace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewMutation) ClearEdge(name string) error {
	switch name {
	case review.EdgeUser:
		m.ClearUser()
		return nil
	case review.EdgePlace:
		m.ClearPlace()
		return nil
	}
	return fmt.Errorf("unknown Review unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewMutation) ResetEdge(name string) error {
	switch name {
	case review.EdgeUser:
		m.ResetUser()
		return nil
	case review.EdgePlace:
		m.ResetPlace()
		return nil
	}
	return fmt.Errorf("unknown Review edge %s", name)
}

// RoomMutation represents an operation that mutates the Room nodes in the graph.
type RoomMutation struct {
	config
	op              Op
	typ             string
	id              *string
	number          *string
	_type           *string
	price           *float64
	addprice        *float64
	description     *string
	availability    *bool
	image           *string
	clearedFields   map[string]struct{}
	place           *string
	clearedplace    bool
	bookings        map[string]struct{}
	removedbookings map[string]struct{}
	clearedbookings bool
	done            bool
	oldValue        func(context.Context) (*Room, error)
	predicates      []predicate.Room
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows management of the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for the Room entity.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the ID field of the mutation.
func withRoomID(id string) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Room entities.
func (m *RoomMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoomMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoomMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Room.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNumber sets the "number" field.
func (m *RoomMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *RoomMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ResetNumber resets all changes to the "number" field.
func (m *RoomMutation) ResetNumber() {
	m.number = nil
}

// SetType sets the "type" field.
func (m *RoomMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *RoomMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RoomMutation) ResetType() {
	m._type = nil
}

// SetPrice sets the "price" field.
func (m *RoomMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *RoomMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *RoomMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *RoomMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *RoomMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetDescription sets the "description" field.
func (m *RoomMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoomMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoomMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[room.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoomMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[room.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoomMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, room.FieldDescription)
}

// SetAvailability sets the "availability" field.
func (m *RoomMutation) SetAvailability(b bool) {
	m.availability = &b
}

// Availability returns the value of the "availability" field in the mutation.
func (m *RoomMutation) Availability() (r bool, exists bool) {
	v := m.availability
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailability returns the old "availability" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldAvailability(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailability: %w", err)
	}
	return oldValue.Availability, nil
}

// ResetAvailability resets all changes to the "availability" field.
func (m *RoomMutation) ResetAvailability() {
	m.availability = nil
}

// SetImage sets the "image" field.
func (m *RoomMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *RoomMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *RoomMutation) ClearImage() {
	m.image = nil
	m.clearedFields[room.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *RoomMutation) ImageCleared() bool {
	_, ok := m.clearedFields[room.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *RoomMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, room.FieldImage)
}

// SetPlaceID sets the "place" edge to the Place entity by id.
func (m *RoomMutation) SetPlaceID(id string) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the Place entity.
func (m *RoomMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the Place entity was cleared.
func (m *RoomMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *RoomMutation) PlaceID() (id string, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *RoomMutation) PlaceIDs() (ids []string) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *RoomMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *RoomMutation) AddBookingIDs(ids ...string) {
	if m.bookings == nil {
		m.bookings = make(map[string]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *RoomMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *RoomMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *RoomMutation) RemoveBookingIDs(ids ...string) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *RoomMutation) RemovedBookingsIDs() (ids []string) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *RoomMutation) BookingsIDs() (ids []string) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *RoomMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// Where appends a list predicates to the RoomMutation builder.
func (m *RoomMutation) Where(ps ...predicate.Room) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoomMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoomMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Room, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoomMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.number != nil {
		fields = append(fields, room.FieldNumber)
	}
	if m._type != nil {
		fields = append(fields, room.FieldType)
	}
	if m.price != nil {
		fields = append(fields, room.FieldPrice)
	}
	if m.description != nil {
		fields = append(fields, room.FieldDescription)
	}
	if m.availability != nil {
		fields = append(fields, room.FieldAvailability)
	}
	if m.image != nil {
		fields = append(fields, room.FieldImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldNumber:
		return m.Number()
	case room.FieldType:
		return m.GetType()
	case room.FieldPrice:
		return m.Price()
	case room.FieldDescription:
		return m.Description()
	case room.FieldAvailability:
		return m.Availability()
	case room.FieldImage:
		return m.Image()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldNumber:
		return m.OldNumber(ctx)
	case room.FieldType:
		return m.OldType(ctx)
	case room.FieldPrice:
		return m.OldPrice(ctx)
	case room.FieldDescription:
		return m.OldDescription(ctx)
	case room.FieldAvailability:
		return m.OldAvailability(ctx)
	case room.FieldImage:
		return m.OldImage(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case room.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case room.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case room.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case room.FieldAvailability:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailability(v)
		return nil
	case room.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, room.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case room.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	case room.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(room.FieldDescription) {
		fields = append(fields, room.FieldDescription)
	}
	if m.FieldCleared(room.FieldImage) {
		fields = append(fields, room.FieldImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	switch name {
	case room.FieldDescription:
		m.ClearDescription()
		return nil
	case room.FieldImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldNumber:
		m.ResetNumber()
		return nil
	case room.FieldType:
		m.ResetType()
		return nil
	case room.FieldPrice:
		m.ResetPrice()
		return nil
	case room.FieldDescription:
		m.ResetDescription()
		return nil
	case room.FieldAvailability:
		m.ResetAvailability()
		return nil
	case room.FieldImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.place != nil {
		edges = append(edges, room.EdgePlace)
	}
	if m.bookings != nil {
		edges = append(edges, room.EdgeBookings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	case room.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbookings != nil {
		edges = append(edges, room.EdgeBookings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplace {
		edges = append(edges, room.EdgePlace)
	}
	if m.clearedbookings {
		edges = append(edges, room.EdgeBookings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	case room.EdgePlace:
		return m.clearedplace
	case room.EdgeBookings:
		return m.clearedbookings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	case room.EdgePlace:
		m.ClearPlace()
		return nil
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgePlace:
		m.ResetPlace()
		return nil
	case room.EdgeBookings:
		m.ResetBookings()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// TicketMutation represents an operation that mutates the Ticket nodes in the graph.
type TicketMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	createdAt             *time.Time
	updatedAt             *time.Time
	clearedFields         map[string]struct{}
	event                 *string
	clearedevent          bool
	ticket_options        map[string]struct{}
	removedticket_options map[string]struct{}
	clearedticket_options bool
	done                  bool
	oldValue              func(context.Context) (*Ticket, error)
	predicates            []predicate.Ticket
}

var _ ent.Mutation = (*TicketMutation)(nil)

// ticketOption allows management of the mutation configuration using functional options.
type ticketOption func(*TicketMutation)

// newTicketMutation creates new mutation for the Ticket entity.
func newTicketMutation(c config, op Op, opts ...ticketOption) *TicketMutation {
	m := &TicketMutation{
		config:        c,
		op:            op,
		typ:           TypeTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketID sets the ID field of the mutation.
func withTicketID(id string) ticketOption {
	return func(m *TicketMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticket
		)
		m.oldValue = func(ctx context.Context) (*Ticket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicket sets the old Ticket of the mutation.
func withTicket(node *Ticket) ticketOption {
	return func(m *TicketMutation) {
		m.oldValue = func(context.Context) (*Ticket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ticket entities.
func (m *TicketMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *TicketMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TicketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TicketMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *TicketMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *TicketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *TicketMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *TicketMutation) SetEventID(id string) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *TicketMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *TicketMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *TicketMutation) EventID() (id string, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) EventIDs() (ids []string) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *TicketMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// AddTicketOptionIDs adds the "ticket_options" edge to the TicketOption entity by ids.
func (m *TicketMutation) AddTicketOptionIDs(ids ...string) {
	if m.ticket_options == nil {
		m.ticket_options = make(map[string]struct{})
	}
	for i := range ids {
		m.ticket_options[ids[i]] = struct{}{}
	}
}

// ClearTicketOptions clears the "ticket_options" edge to the TicketOption entity.
func (m *TicketMutation) ClearTicketOptions() {
	m.clearedticket_options = true
}

// TicketOptionsCleared reports if the "ticket_options" edge to the TicketOption entity was cleared.
func (m *TicketMutation) TicketOptionsCleared() bool {
	return m.clearedticket_options
}

// RemoveTicketOptionIDs removes the "ticket_options" edge to the TicketOption entity by IDs.
func (m *TicketMutation) RemoveTicketOptionIDs(ids ...string) {
	if m.removedticket_options == nil {
		m.removedticket_options = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ticket_options, ids[i])
		m.removedticket_options[ids[i]] = struct{}{}
	}
}

// RemovedTicketOptions returns the removed IDs of the "ticket_options" edge to the TicketOption entity.
func (m *TicketMutation) RemovedTicketOptionsIDs() (ids []string) {
	for id := range m.removedticket_options {
		ids = append(ids, id)
	}
	return
}

// TicketOptionsIDs returns the "ticket_options" edge IDs in the mutation.
func (m *TicketMutation) TicketOptionsIDs() (ids []string) {
	for id := range m.ticket_options {
		ids = append(ids, id)
	}
	return
}

// ResetTicketOptions resets all changes to the "ticket_options" edge.
func (m *TicketMutation) ResetTicketOptions() {
	m.ticket_options = nil
	m.clearedticket_options = false
	m.removedticket_options = nil
}

// Where appends a list predicates to the TicketMutation builder.
func (m *TicketMutation) Where(ps ...predicate.Ticket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ticket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ticket).
func (m *TicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.createdAt != nil {
		fields = append(fields, ticket.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, ticket.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldCreatedAt:
		return m.CreatedAt()
	case ticket.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ticket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ticket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ticket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketMutation) ResetField(name string) error {
	switch name {
	case ticket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.event != nil {
		edges = append(edges, ticket.EdgeEvent)
	}
	if m.ticket_options != nil {
		edges = append(edges, ticket.EdgeTicketOptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeTicketOptions:
		ids := make([]ent.Value, 0, len(m.ticket_options))
		for id := range m.ticket_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedticket_options != nil {
		edges = append(edges, ticket.EdgeTicketOptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeTicketOptions:
		ids := make([]ent.Value, 0, len(m.removedticket_options))
		for id := range m.removedticket_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedevent {
		edges = append(edges, ticket.EdgeEvent)
	}
	if m.clearedticket_options {
		edges = append(edges, ticket.EdgeTicketOptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketMutation) EdgeCleared(name string) bool {
	switch name {
	case ticket.EdgeEvent:
		return m.clearedevent
	case ticket.EdgeTicketOptions:
		return m.clearedticket_options
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketMutation) ClearEdge(name string) error {
	switch name {
	case ticket.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown Ticket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketMutation) ResetEdge(name string) error {
	switch name {
	case ticket.EdgeEvent:
		m.ResetEvent()
		return nil
	case ticket.EdgeTicketOptions:
		m.ResetTicketOptions()
		return nil
	}
	return fmt.Errorf("unknown Ticket edge %s", name)
}

// TicketOptionMutation represents an operation that mutates the TicketOption nodes in the graph.
type TicketOptionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	createdAt     *time.Time
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	event         *string
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*TicketOption, error)
	predicates    []predicate.TicketOption
}

var _ ent.Mutation = (*TicketOptionMutation)(nil)

// ticketoptionOption allows management of the mutation configuration using functional options.
type ticketoptionOption func(*TicketOptionMutation)

// newTicketOptionMutation creates new mutation for the TicketOption entity.
func newTicketOptionMutation(c config, op Op, opts ...ticketoptionOption) *TicketOptionMutation {
	m := &TicketOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketOptionID sets the ID field of the mutation.
func withTicketOptionID(id string) ticketoptionOption {
	return func(m *TicketOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketOption
		)
		m.oldValue = func(ctx context.Context) (*TicketOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketOption sets the old TicketOption of the mutation.
func withTicketOption(node *TicketOption) ticketoptionOption {
	return func(m *TicketOptionMutation) {
		m.oldValue = func(context.Context) (*TicketOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TicketOption entities.
func (m *TicketOptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketOptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketOptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *TicketOptionMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TicketOptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the TicketOption entity.
// If the TicketOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketOptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TicketOptionMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *TicketOptionMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *TicketOptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the TicketOption entity.
// If the TicketOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketOptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *TicketOptionMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *TicketOptionMutation) SetEventID(id string) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *TicketOptionMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *TicketOptionMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *TicketOptionMutation) EventID() (id string, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *TicketOptionMutation) EventIDs() (ids []string) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *TicketOptionMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the TicketOptionMutation builder.
func (m *TicketOptionMutation) Where(ps ...predicate.TicketOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketOption).
func (m *TicketOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketOptionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.createdAt != nil {
		fields = append(fields, ticketoption.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, ticketoption.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticketoption.FieldCreatedAt:
		return m.CreatedAt()
	case ticketoption.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticketoption.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticketoption.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TicketOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticketoption.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticketoption.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TicketOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketOptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketOptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TicketOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketOptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketOptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TicketOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketOptionMutation) ResetField(name string) error {
	switch name {
	case ticketoption.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticketoption.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TicketOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, ticketoption.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticketoption.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketOptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, ticketoption.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case ticketoption.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketOptionMutation) ClearEdge(name string) error {
	switch name {
	case ticketoption.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown TicketOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketOptionMutation) ResetEdge(name string) error {
	switch name {
	case ticketoption.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown TicketOption edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	auth0_id                   *string
	name                       *string
	picture                    *string
	cover_image                *string
	username                   *string
	website                    *string
	location                   *string
	bio                        *string
	auth0_data                 **management.User
	app_settings               *map[string]interface{}
	user_settings              *map[string]interface{}
	search_text                *string
	relevance_score            *float64
	addrelevance_score         *float64
	clearedFields              map[string]struct{}
	userBusinesses             map[string]struct{}
	removeduserBusinesses      map[string]struct{}
	cleareduserBusinesses      bool
	comments                   map[string]struct{}
	removedcomments            map[string]struct{}
	clearedcomments            bool
	likes                      map[string]struct{}
	removedlikes               map[string]struct{}
	clearedlikes               bool
	posts                      map[string]struct{}
	removedposts               map[string]struct{}
	clearedposts               bool
	followedUsers              map[string]struct{}
	removedfollowedUsers       map[string]struct{}
	clearedfollowedUsers       bool
	followerUsers              map[string]struct{}
	removedfollowerUsers       map[string]struct{}
	clearedfollowerUsers       bool
	followedBusinesses         map[string]struct{}
	removedfollowedBusinesses  map[string]struct{}
	clearedfollowedBusinesses  bool
	followerBusinesses         map[string]struct{}
	removedfollowerBusinesses  map[string]struct{}
	clearedfollowerBusinesses  bool
	reviews                    map[string]struct{}
	removedreviews             map[string]struct{}
	clearedreviews             bool
	bookings                   map[string]struct{}
	removedbookings            map[string]struct{}
	clearedbookings            bool
	reservations               map[string]struct{}
	removedreservations        map[string]struct{}
	clearedreservations        bool
	helps                      map[string]struct{}
	removedhelps               map[string]struct{}
	clearedhelps               bool
	categories                 map[string]struct{}
	removedcategories          map[string]struct{}
	clearedcategories          bool
	events                     map[string]struct{}
	removedevents              map[string]struct{}
	clearedevents              bool
	places                     map[string]struct{}
	removedplaces              map[string]struct{}
	clearedplaces              bool
	categoryAssignments        map[string]struct{}
	removedcategoryAssignments map[string]struct{}
	clearedcategoryAssignments bool
	done                       bool
	oldValue                   func(context.Context) (*User, error)
	predicates                 []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAuth0ID sets the "auth0_id" field.
func (m *UserMutation) SetAuth0ID(s string) {
	m.auth0_id = &s
}

// Auth0ID returns the value of the "auth0_id" field in the mutation.
func (m *UserMutation) Auth0ID() (r string, exists bool) {
	v := m.auth0_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuth0ID returns the old "auth0_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuth0ID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuth0ID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuth0ID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuth0ID: %w", err)
	}
	return oldValue.Auth0ID, nil
}

// ResetAuth0ID resets all changes to the "auth0_id" field.
func (m *UserMutation) ResetAuth0ID() {
	m.auth0_id = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetPicture sets the "picture" field.
func (m *UserMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the value of the "picture" field in the mutation.
func (m *UserMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPicture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *UserMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[user.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *UserMutation) PictureCleared() bool {
	_, ok := m.clearedFields[user.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *UserMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, user.FieldPicture)
}

// SetCoverImage sets the "cover_image" field.
func (m *UserMutation) SetCoverImage(s string) {
	m.cover_image = &s
}

// CoverImage returns the value of the "cover_image" field in the mutation.
func (m *UserMutation) CoverImage() (r string, exists bool) {
	v := m.cover_image
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImage returns the old "cover_image" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCoverImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImage: %w", err)
	}
	return oldValue.CoverImage, nil
}

// ClearCoverImage clears the value of the "cover_image" field.
func (m *UserMutation) ClearCoverImage() {
	m.cover_image = nil
	m.clearedFields[user.FieldCoverImage] = struct{}{}
}

// CoverImageCleared returns if the "cover_image" field was cleared in this mutation.
func (m *UserMutation) CoverImageCleared() bool {
	_, ok := m.clearedFields[user.FieldCoverImage]
	return ok
}

// ResetCoverImage resets all changes to the "cover_image" field.
func (m *UserMutation) ResetCoverImage() {
	m.cover_image = nil
	delete(m.clearedFields, user.FieldCoverImage)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetWebsite sets the "website" field.
func (m *UserMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *UserMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *UserMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[user.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *UserMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[user.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *UserMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, user.FieldWebsite)
}

// SetLocation sets the "location" field.
func (m *UserMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *UserMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *UserMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[user.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *UserMutation) LocationCleared() bool {
	_, ok := m.clearedFields[user.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *UserMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, user.FieldLocation)
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[user.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserMutation) BioCleared() bool {
	_, ok := m.clearedFields[user.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, user.FieldBio)
}

// SetAuth0Data sets the "auth0_data" field.
func (m *UserMutation) SetAuth0Data(value *management.User) {
	m.auth0_data = &value
}

// Auth0Data returns the value of the "auth0_data" field in the mutation.
func (m *UserMutation) Auth0Data() (r *management.User, exists bool) {
	v := m.auth0_data
	if v == nil {
		return
	}
	return *v, true
}

// OldAuth0Data returns the old "auth0_data" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuth0Data(ctx context.Context) (v *management.User, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuth0Data is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuth0Data requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuth0Data: %w", err)
	}
	return oldValue.Auth0Data, nil
}

// ClearAuth0Data clears the value of the "auth0_data" field.
func (m *UserMutation) ClearAuth0Data() {
	m.auth0_data = nil
	m.clearedFields[user.FieldAuth0Data] = struct{}{}
}

// Auth0DataCleared returns if the "auth0_data" field was cleared in this mutation.
func (m *UserMutation) Auth0DataCleared() bool {
	_, ok := m.clearedFields[user.FieldAuth0Data]
	return ok
}

// ResetAuth0Data resets all changes to the "auth0_data" field.
func (m *UserMutation) ResetAuth0Data() {
	m.auth0_data = nil
	delete(m.clearedFields, user.FieldAuth0Data)
}

// SetAppSettings sets the "app_settings" field.
func (m *UserMutation) SetAppSettings(value map[string]interface{}) {
	m.app_settings = &value
}

// AppSettings returns the value of the "app_settings" field in the mutation.
func (m *UserMutation) AppSettings() (r map[string]interface{}, exists bool) {
	v := m.app_settings
	if v == nil {
		return
	}
	return *v, true
}

// OldAppSettings returns the old "app_settings" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAppSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppSettings: %w", err)
	}
	return oldValue.AppSettings, nil
}

// ClearAppSettings clears the value of the "app_settings" field.
func (m *UserMutation) ClearAppSettings() {
	m.app_settings = nil
	m.clearedFields[user.FieldAppSettings] = struct{}{}
}

// AppSettingsCleared returns if the "app_settings" field was cleared in this mutation.
func (m *UserMutation) AppSettingsCleared() bool {
	_, ok := m.clearedFields[user.FieldAppSettings]
	return ok
}

// ResetAppSettings resets all changes to the "app_settings" field.
func (m *UserMutation) ResetAppSettings() {
	m.app_settings = nil
	delete(m.clearedFields, user.FieldAppSettings)
}

// SetUserSettings sets the "user_settings" field.
func (m *UserMutation) SetUserSettings(value map[string]interface{}) {
	m.user_settings = &value
}

// UserSettings returns the value of the "user_settings" field in the mutation.
func (m *UserMutation) UserSettings() (r map[string]interface{}, exists bool) {
	v := m.user_settings
	if v == nil {
		return
	}
	return *v, true
}

// OldUserSettings returns the old "user_settings" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserSettings: %w", err)
	}
	return oldValue.UserSettings, nil
}

// ClearUserSettings clears the value of the "user_settings" field.
func (m *UserMutation) ClearUserSettings() {
	m.user_settings = nil
	m.clearedFields[user.FieldUserSettings] = struct{}{}
}

// UserSettingsCleared returns if the "user_settings" field was cleared in this mutation.
func (m *UserMutation) UserSettingsCleared() bool {
	_, ok := m.clearedFields[user.FieldUserSettings]
	return ok
}

// ResetUserSettings resets all changes to the "user_settings" field.
func (m *UserMutation) ResetUserSettings() {
	m.user_settings = nil
	delete(m.clearedFields, user.FieldUserSettings)
}

// SetSearchText sets the "search_text" field.
func (m *UserMutation) SetSearchText(s string) {
	m.search_text = &s
}

// SearchText returns the value of the "search_text" field in the mutation.
func (m *UserMutation) SearchText() (r string, exists bool) {
	v := m.search_text
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchText returns the old "search_text" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSearchText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchText: %w", err)
	}
	return oldValue.SearchText, nil
}

// ClearSearchText clears the value of the "search_text" field.
func (m *UserMutation) ClearSearchText() {
	m.search_text = nil
	m.clearedFields[user.FieldSearchText] = struct{}{}
}

// SearchTextCleared returns if the "search_text" field was cleared in this mutation.
func (m *UserMutation) SearchTextCleared() bool {
	_, ok := m.clearedFields[user.FieldSearchText]
	return ok
}

// ResetSearchText resets all changes to the "search_text" field.
func (m *UserMutation) ResetSearchText() {
	m.search_text = nil
	delete(m.clearedFields, user.FieldSearchText)
}

// SetRelevanceScore sets the "relevance_score" field.
func (m *UserMutation) SetRelevanceScore(f float64) {
	m.relevance_score = &f
	m.addrelevance_score = nil
}

// RelevanceScore returns the value of the "relevance_score" field in the mutation.
func (m *UserMutation) RelevanceScore() (r float64, exists bool) {
	v := m.relevance_score
	if v == nil {
		return
	}
	return *v, true
}

// OldRelevanceScore returns the old "relevance_score" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRelevanceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelevanceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelevanceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelevanceScore: %w", err)
	}
	return oldValue.RelevanceScore, nil
}

// AddRelevanceScore adds f to the "relevance_score" field.
func (m *UserMutation) AddRelevanceScore(f float64) {
	if m.addrelevance_score != nil {
		*m.addrelevance_score += f
	} else {
		m.addrelevance_score = &f
	}
}

// AddedRelevanceScore returns the value that was added to the "relevance_score" field in this mutation.
func (m *UserMutation) AddedRelevanceScore() (r float64, exists bool) {
	v := m.addrelevance_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelevanceScore clears the value of the "relevance_score" field.
func (m *UserMutation) ClearRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	m.clearedFields[user.FieldRelevanceScore] = struct{}{}
}

// RelevanceScoreCleared returns if the "relevance_score" field was cleared in this mutation.
func (m *UserMutation) RelevanceScoreCleared() bool {
	_, ok := m.clearedFields[user.FieldRelevanceScore]
	return ok
}

// ResetRelevanceScore resets all changes to the "relevance_score" field.
func (m *UserMutation) ResetRelevanceScore() {
	m.relevance_score = nil
	m.addrelevance_score = nil
	delete(m.clearedFields, user.FieldRelevanceScore)
}

// AddUserBusinessIDs adds the "userBusinesses" edge to the UserBusiness entity by ids.
func (m *UserMutation) AddUserBusinessIDs(ids ...string) {
	if m.userBusinesses == nil {
		m.userBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		m.userBusinesses[ids[i]] = struct{}{}
	}
}

// ClearUserBusinesses clears the "userBusinesses" edge to the UserBusiness entity.
func (m *UserMutation) ClearUserBusinesses() {
	m.cleareduserBusinesses = true
}

// UserBusinessesCleared reports if the "userBusinesses" edge to the UserBusiness entity was cleared.
func (m *UserMutation) UserBusinessesCleared() bool {
	return m.cleareduserBusinesses
}

// RemoveUserBusinessIDs removes the "userBusinesses" edge to the UserBusiness entity by IDs.
func (m *UserMutation) RemoveUserBusinessIDs(ids ...string) {
	if m.removeduserBusinesses == nil {
		m.removeduserBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.userBusinesses, ids[i])
		m.removeduserBusinesses[ids[i]] = struct{}{}
	}
}

// RemovedUserBusinesses returns the removed IDs of the "userBusinesses" edge to the UserBusiness entity.
func (m *UserMutation) RemovedUserBusinessesIDs() (ids []string) {
	for id := range m.removeduserBusinesses {
		ids = append(ids, id)
	}
	return
}

// UserBusinessesIDs returns the "userBusinesses" edge IDs in the mutation.
func (m *UserMutation) UserBusinessesIDs() (ids []string) {
	for id := range m.userBusinesses {
		ids = append(ids, id)
	}
	return
}

// ResetUserBusinesses resets all changes to the "userBusinesses" edge.
func (m *UserMutation) ResetUserBusinesses() {
	m.userBusinesses = nil
	m.cleareduserBusinesses = false
	m.removeduserBusinesses = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *UserMutation) AddCommentIDs(ids ...string) {
	if m.comments == nil {
		m.comments = make(map[string]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *UserMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *UserMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveCommentIDs(ids ...string) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *UserMutation) RemovedCommentsIDs() (ids []string) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *UserMutation) CommentsIDs() (ids []string) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddLikeIDs adds the "likes" edge to the Like entity by ids.
func (m *UserMutation) AddLikeIDs(ids ...string) {
	if m.likes == nil {
		m.likes = make(map[string]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the Like entity.
func (m *UserMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the Like entity was cleared.
func (m *UserMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the Like entity by IDs.
func (m *UserMutation) RemoveLikeIDs(ids ...string) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the Like entity.
func (m *UserMutation) RemovedLikesIDs() (ids []string) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *UserMutation) LikesIDs() (ids []string) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *UserMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *UserMutation) AddPostIDs(ids ...string) {
	if m.posts == nil {
		m.posts = make(map[string]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *UserMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *UserMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *UserMutation) RemovePostIDs(ids ...string) {
	if m.removedposts == nil {
		m.removedposts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *UserMutation) RemovedPostsIDs() (ids []string) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *UserMutation) PostsIDs() (ids []string) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *UserMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddFollowedUserIDs adds the "followedUsers" edge to the UserFollowUser entity by ids.
func (m *UserMutation) AddFollowedUserIDs(ids ...string) {
	if m.followedUsers == nil {
		m.followedUsers = make(map[string]struct{})
	}
	for i := range ids {
		m.followedUsers[ids[i]] = struct{}{}
	}
}

// ClearFollowedUsers clears the "followedUsers" edge to the UserFollowUser entity.
func (m *UserMutation) ClearFollowedUsers() {
	m.clearedfollowedUsers = true
}

// FollowedUsersCleared reports if the "followedUsers" edge to the UserFollowUser entity was cleared.
func (m *UserMutation) FollowedUsersCleared() bool {
	return m.clearedfollowedUsers
}

// RemoveFollowedUserIDs removes the "followedUsers" edge to the UserFollowUser entity by IDs.
func (m *UserMutation) RemoveFollowedUserIDs(ids ...string) {
	if m.removedfollowedUsers == nil {
		m.removedfollowedUsers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followedUsers, ids[i])
		m.removedfollowedUsers[ids[i]] = struct{}{}
	}
}

// RemovedFollowedUsers returns the removed IDs of the "followedUsers" edge to the UserFollowUser entity.
func (m *UserMutation) RemovedFollowedUsersIDs() (ids []string) {
	for id := range m.removedfollowedUsers {
		ids = append(ids, id)
	}
	return
}

// FollowedUsersIDs returns the "followedUsers" edge IDs in the mutation.
func (m *UserMutation) FollowedUsersIDs() (ids []string) {
	for id := range m.followedUsers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedUsers resets all changes to the "followedUsers" edge.
func (m *UserMutation) ResetFollowedUsers() {
	m.followedUsers = nil
	m.clearedfollowedUsers = false
	m.removedfollowedUsers = nil
}

// AddFollowerUserIDs adds the "followerUsers" edge to the UserFollowUser entity by ids.
func (m *UserMutation) AddFollowerUserIDs(ids ...string) {
	if m.followerUsers == nil {
		m.followerUsers = make(map[string]struct{})
	}
	for i := range ids {
		m.followerUsers[ids[i]] = struct{}{}
	}
}

// ClearFollowerUsers clears the "followerUsers" edge to the UserFollowUser entity.
func (m *UserMutation) ClearFollowerUsers() {
	m.clearedfollowerUsers = true
}

// FollowerUsersCleared reports if the "followerUsers" edge to the UserFollowUser entity was cleared.
func (m *UserMutation) FollowerUsersCleared() bool {
	return m.clearedfollowerUsers
}

// RemoveFollowerUserIDs removes the "followerUsers" edge to the UserFollowUser entity by IDs.
func (m *UserMutation) RemoveFollowerUserIDs(ids ...string) {
	if m.removedfollowerUsers == nil {
		m.removedfollowerUsers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followerUsers, ids[i])
		m.removedfollowerUsers[ids[i]] = struct{}{}
	}
}

// RemovedFollowerUsers returns the removed IDs of the "followerUsers" edge to the UserFollowUser entity.
func (m *UserMutation) RemovedFollowerUsersIDs() (ids []string) {
	for id := range m.removedfollowerUsers {
		ids = append(ids, id)
	}
	return
}

// FollowerUsersIDs returns the "followerUsers" edge IDs in the mutation.
func (m *UserMutation) FollowerUsersIDs() (ids []string) {
	for id := range m.followerUsers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowerUsers resets all changes to the "followerUsers" edge.
func (m *UserMutation) ResetFollowerUsers() {
	m.followerUsers = nil
	m.clearedfollowerUsers = false
	m.removedfollowerUsers = nil
}

// AddFollowedBusinessIDs adds the "followedBusinesses" edge to the UserFollowBusiness entity by ids.
func (m *UserMutation) AddFollowedBusinessIDs(ids ...string) {
	if m.followedBusinesses == nil {
		m.followedBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		m.followedBusinesses[ids[i]] = struct{}{}
	}
}

// ClearFollowedBusinesses clears the "followedBusinesses" edge to the UserFollowBusiness entity.
func (m *UserMutation) ClearFollowedBusinesses() {
	m.clearedfollowedBusinesses = true
}

// FollowedBusinessesCleared reports if the "followedBusinesses" edge to the UserFollowBusiness entity was cleared.
func (m *UserMutation) FollowedBusinessesCleared() bool {
	return m.clearedfollowedBusinesses
}

// RemoveFollowedBusinessIDs removes the "followedBusinesses" edge to the UserFollowBusiness entity by IDs.
func (m *UserMutation) RemoveFollowedBusinessIDs(ids ...string) {
	if m.removedfollowedBusinesses == nil {
		m.removedfollowedBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followedBusinesses, ids[i])
		m.removedfollowedBusinesses[ids[i]] = struct{}{}
	}
}

// RemovedFollowedBusinesses returns the removed IDs of the "followedBusinesses" edge to the UserFollowBusiness entity.
func (m *UserMutation) RemovedFollowedBusinessesIDs() (ids []string) {
	for id := range m.removedfollowedBusinesses {
		ids = append(ids, id)
	}
	return
}

// FollowedBusinessesIDs returns the "followedBusinesses" edge IDs in the mutation.
func (m *UserMutation) FollowedBusinessesIDs() (ids []string) {
	for id := range m.followedBusinesses {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedBusinesses resets all changes to the "followedBusinesses" edge.
func (m *UserMutation) ResetFollowedBusinesses() {
	m.followedBusinesses = nil
	m.clearedfollowedBusinesses = false
	m.removedfollowedBusinesses = nil
}

// AddFollowerBusinessIDs adds the "followerBusinesses" edge to the BusinessFollowUser entity by ids.
func (m *UserMutation) AddFollowerBusinessIDs(ids ...string) {
	if m.followerBusinesses == nil {
		m.followerBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		m.followerBusinesses[ids[i]] = struct{}{}
	}
}

// ClearFollowerBusinesses clears the "followerBusinesses" edge to the BusinessFollowUser entity.
func (m *UserMutation) ClearFollowerBusinesses() {
	m.clearedfollowerBusinesses = true
}

// FollowerBusinessesCleared reports if the "followerBusinesses" edge to the BusinessFollowUser entity was cleared.
func (m *UserMutation) FollowerBusinessesCleared() bool {
	return m.clearedfollowerBusinesses
}

// RemoveFollowerBusinessIDs removes the "followerBusinesses" edge to the BusinessFollowUser entity by IDs.
func (m *UserMutation) RemoveFollowerBusinessIDs(ids ...string) {
	if m.removedfollowerBusinesses == nil {
		m.removedfollowerBusinesses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.followerBusinesses, ids[i])
		m.removedfollowerBusinesses[ids[i]] = struct{}{}
	}
}

// RemovedFollowerBusinesses returns the removed IDs of the "followerBusinesses" edge to the BusinessFollowUser entity.
func (m *UserMutation) RemovedFollowerBusinessesIDs() (ids []string) {
	for id := range m.removedfollowerBusinesses {
		ids = append(ids, id)
	}
	return
}

// FollowerBusinessesIDs returns the "followerBusinesses" edge IDs in the mutation.
func (m *UserMutation) FollowerBusinessesIDs() (ids []string) {
	for id := range m.followerBusinesses {
		ids = append(ids, id)
	}
	return
}

// ResetFollowerBusinesses resets all changes to the "followerBusinesses" edge.
func (m *UserMutation) ResetFollowerBusinesses() {
	m.followerBusinesses = nil
	m.clearedfollowerBusinesses = false
	m.removedfollowerBusinesses = nil
}

// AddReviewIDs adds the "reviews" edge to the Review entity by ids.
func (m *UserMutation) AddReviewIDs(ids ...string) {
	if m.reviews == nil {
		m.reviews = make(map[string]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the Review entity.
func (m *UserMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the Review entity was cleared.
func (m *UserMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the Review entity by IDs.
func (m *UserMutation) RemoveReviewIDs(ids ...string) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the Review entity.
func (m *UserMutation) RemovedReviewsIDs() (ids []string) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *UserMutation) ReviewsIDs() (ids []string) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *UserMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *UserMutation) AddBookingIDs(ids ...string) {
	if m.bookings == nil {
		m.bookings = make(map[string]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *UserMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *UserMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *UserMutation) RemoveBookingIDs(ids ...string) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *UserMutation) RemovedBookingsIDs() (ids []string) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *UserMutation) BookingsIDs() (ids []string) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *UserMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// AddReservationIDs adds the "reservations" edge to the Reservation entity by ids.
func (m *UserMutation) AddReservationIDs(ids ...string) {
	if m.reservations == nil {
		m.reservations = make(map[string]struct{})
	}
	for i := range ids {
		m.reservations[ids[i]] = struct{}{}
	}
}

// ClearReservations clears the "reservations" edge to the Reservation entity.
func (m *UserMutation) ClearReservations() {
	m.clearedreservations = true
}

// ReservationsCleared reports if the "reservations" edge to the Reservation entity was cleared.
func (m *UserMutation) ReservationsCleared() bool {
	return m.clearedreservations
}

// RemoveReservationIDs removes the "reservations" edge to the Reservation entity by IDs.
func (m *UserMutation) RemoveReservationIDs(ids ...string) {
	if m.removedreservations == nil {
		m.removedreservations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reservations, ids[i])
		m.removedreservations[ids[i]] = struct{}{}
	}
}

// RemovedReservations returns the removed IDs of the "reservations" edge to the Reservation entity.
func (m *UserMutation) RemovedReservationsIDs() (ids []string) {
	for id := range m.removedreservations {
		ids = append(ids, id)
	}
	return
}

// ReservationsIDs returns the "reservations" edge IDs in the mutation.
func (m *UserMutation) ReservationsIDs() (ids []string) {
	for id := range m.reservations {
		ids = append(ids, id)
	}
	return
}

// ResetReservations resets all changes to the "reservations" edge.
func (m *UserMutation) ResetReservations() {
	m.reservations = nil
	m.clearedreservations = false
	m.removedreservations = nil
}

// AddHelpIDs adds the "helps" edge to the Help entity by ids.
func (m *UserMutation) AddHelpIDs(ids ...string) {
	if m.helps == nil {
		m.helps = make(map[string]struct{})
	}
	for i := range ids {
		m.helps[ids[i]] = struct{}{}
	}
}

// ClearHelps clears the "helps" edge to the Help entity.
func (m *UserMutation) ClearHelps() {
	m.clearedhelps = true
}

// HelpsCleared reports if the "helps" edge to the Help entity was cleared.
func (m *UserMutation) HelpsCleared() bool {
	return m.clearedhelps
}

// RemoveHelpIDs removes the "helps" edge to the Help entity by IDs.
func (m *UserMutation) RemoveHelpIDs(ids ...string) {
	if m.removedhelps == nil {
		m.removedhelps = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.helps, ids[i])
		m.removedhelps[ids[i]] = struct{}{}
	}
}

// RemovedHelps returns the removed IDs of the "helps" edge to the Help entity.
func (m *UserMutation) RemovedHelpsIDs() (ids []string) {
	for id := range m.removedhelps {
		ids = append(ids, id)
	}
	return
}

// HelpsIDs returns the "helps" edge IDs in the mutation.
func (m *UserMutation) HelpsIDs() (ids []string) {
	for id := range m.helps {
		ids = append(ids, id)
	}
	return
}

// ResetHelps resets all changes to the "helps" edge.
func (m *UserMutation) ResetHelps() {
	m.helps = nil
	m.clearedhelps = false
	m.removedhelps = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *UserMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *UserMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *UserMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *UserMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *UserMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *UserMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *UserMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *UserMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *UserMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *UserMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *UserMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *UserMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *UserMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *UserMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *UserMutation) AddPlaceIDs(ids ...string) {
	if m.places == nil {
		m.places = make(map[string]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *UserMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the Place entity was cleared.
func (m *UserMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *UserMutation) RemovePlaceIDs(ids ...string) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *UserMutation) RemovedPlacesIDs() (ids []string) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *UserMutation) PlacesIDs() (ids []string) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *UserMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// AddCategoryAssignmentIDs adds the "categoryAssignments" edge to the CategoryAssignment entity by ids.
func (m *UserMutation) AddCategoryAssignmentIDs(ids ...string) {
	if m.categoryAssignments == nil {
		m.categoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		m.categoryAssignments[ids[i]] = struct{}{}
	}
}

// ClearCategoryAssignments clears the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *UserMutation) ClearCategoryAssignments() {
	m.clearedcategoryAssignments = true
}

// CategoryAssignmentsCleared reports if the "categoryAssignments" edge to the CategoryAssignment entity was cleared.
func (m *UserMutation) CategoryAssignmentsCleared() bool {
	return m.clearedcategoryAssignments
}

// RemoveCategoryAssignmentIDs removes the "categoryAssignments" edge to the CategoryAssignment entity by IDs.
func (m *UserMutation) RemoveCategoryAssignmentIDs(ids ...string) {
	if m.removedcategoryAssignments == nil {
		m.removedcategoryAssignments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categoryAssignments, ids[i])
		m.removedcategoryAssignments[ids[i]] = struct{}{}
	}
}

// RemovedCategoryAssignments returns the removed IDs of the "categoryAssignments" edge to the CategoryAssignment entity.
func (m *UserMutation) RemovedCategoryAssignmentsIDs() (ids []string) {
	for id := range m.removedcategoryAssignments {
		ids = append(ids, id)
	}
	return
}

// CategoryAssignmentsIDs returns the "categoryAssignments" edge IDs in the mutation.
func (m *UserMutation) CategoryAssignmentsIDs() (ids []string) {
	for id := range m.categoryAssignments {
		ids = append(ids, id)
	}
	return
}

// ResetCategoryAssignments resets all changes to the "categoryAssignments" edge.
func (m *UserMutation) ResetCategoryAssignments() {
	m.categoryAssignments = nil
	m.clearedcategoryAssignments = false
	m.removedcategoryAssignments = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.auth0_id != nil {
		fields = append(fields, user.FieldAuth0ID)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.picture != nil {
		fields = append(fields, user.FieldPicture)
	}
	if m.cover_image != nil {
		fields = append(fields, user.FieldCoverImage)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.website != nil {
		fields = append(fields, user.FieldWebsite)
	}
	if m.location != nil {
		fields = append(fields, user.FieldLocation)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.auth0_data != nil {
		fields = append(fields, user.FieldAuth0Data)
	}
	if m.app_settings != nil {
		fields = append(fields, user.FieldAppSettings)
	}
	if m.user_settings != nil {
		fields = append(fields, user.FieldUserSettings)
	}
	if m.search_text != nil {
		fields = append(fields, user.FieldSearchText)
	}
	if m.relevance_score != nil {
		fields = append(fields, user.FieldRelevanceScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAuth0ID:
		return m.Auth0ID()
	case user.FieldName:
		return m.Name()
	case user.FieldPicture:
		return m.Picture()
	case user.FieldCoverImage:
		return m.CoverImage()
	case user.FieldUsername:
		return m.Username()
	case user.FieldWebsite:
		return m.Website()
	case user.FieldLocation:
		return m.Location()
	case user.FieldBio:
		return m.Bio()
	case user.FieldAuth0Data:
		return m.Auth0Data()
	case user.FieldAppSettings:
		return m.AppSettings()
	case user.FieldUserSettings:
		return m.UserSettings()
	case user.FieldSearchText:
		return m.SearchText()
	case user.FieldRelevanceScore:
		return m.RelevanceScore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldAuth0ID:
		return m.OldAuth0ID(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldPicture:
		return m.OldPicture(ctx)
	case user.FieldCoverImage:
		return m.OldCoverImage(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldWebsite:
		return m.OldWebsite(ctx)
	case user.FieldLocation:
		return m.OldLocation(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldAuth0Data:
		return m.OldAuth0Data(ctx)
	case user.FieldAppSettings:
		return m.OldAppSettings(ctx)
	case user.FieldUserSettings:
		return m.OldUserSettings(ctx)
	case user.FieldSearchText:
		return m.OldSearchText(ctx)
	case user.FieldRelevanceScore:
		return m.OldRelevanceScore(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldAuth0ID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuth0ID(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case user.FieldCoverImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImage(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case user.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldAuth0Data:
		v, ok := value.(*management.User)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuth0Data(v)
		return nil
	case user.FieldAppSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppSettings(v)
		return nil
	case user.FieldUserSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserSettings(v)
		return nil
	case user.FieldSearchText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchText(v)
		return nil
	case user.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelevanceScore(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addrelevance_score != nil {
		fields = append(fields, user.FieldRelevanceScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldRelevanceScore:
		return m.AddedRelevanceScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldRelevanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelevanceScore(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldPicture) {
		fields = append(fields, user.FieldPicture)
	}
	if m.FieldCleared(user.FieldCoverImage) {
		fields = append(fields, user.FieldCoverImage)
	}
	if m.FieldCleared(user.FieldWebsite) {
		fields = append(fields, user.FieldWebsite)
	}
	if m.FieldCleared(user.FieldLocation) {
		fields = append(fields, user.FieldLocation)
	}
	if m.FieldCleared(user.FieldBio) {
		fields = append(fields, user.FieldBio)
	}
	if m.FieldCleared(user.FieldAuth0Data) {
		fields = append(fields, user.FieldAuth0Data)
	}
	if m.FieldCleared(user.FieldAppSettings) {
		fields = append(fields, user.FieldAppSettings)
	}
	if m.FieldCleared(user.FieldUserSettings) {
		fields = append(fields, user.FieldUserSettings)
	}
	if m.FieldCleared(user.FieldSearchText) {
		fields = append(fields, user.FieldSearchText)
	}
	if m.FieldCleared(user.FieldRelevanceScore) {
		fields = append(fields, user.FieldRelevanceScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldPicture:
		m.ClearPicture()
		return nil
	case user.FieldCoverImage:
		m.ClearCoverImage()
		return nil
	case user.FieldWebsite:
		m.ClearWebsite()
		return nil
	case user.FieldLocation:
		m.ClearLocation()
		return nil
	case user.FieldBio:
		m.ClearBio()
		return nil
	case user.FieldAuth0Data:
		m.ClearAuth0Data()
		return nil
	case user.FieldAppSettings:
		m.ClearAppSettings()
		return nil
	case user.FieldUserSettings:
		m.ClearUserSettings()
		return nil
	case user.FieldSearchText:
		m.ClearSearchText()
		return nil
	case user.FieldRelevanceScore:
		m.ClearRelevanceScore()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldAuth0ID:
		m.ResetAuth0ID()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldPicture:
		m.ResetPicture()
		return nil
	case user.FieldCoverImage:
		m.ResetCoverImage()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldWebsite:
		m.ResetWebsite()
		return nil
	case user.FieldLocation:
		m.ResetLocation()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldAuth0Data:
		m.ResetAuth0Data()
		return nil
	case user.FieldAppSettings:
		m.ResetAppSettings()
		return nil
	case user.FieldUserSettings:
		m.ResetUserSettings()
		return nil
	case user.FieldSearchText:
		m.ResetSearchText()
		return nil
	case user.FieldRelevanceScore:
		m.ResetRelevanceScore()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.userBusinesses != nil {
		edges = append(edges, user.EdgeUserBusinesses)
	}
	if m.comments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.likes != nil {
		edges = append(edges, user.EdgeLikes)
	}
	if m.posts != nil {
		edges = append(edges, user.EdgePosts)
	}
	if m.followedUsers != nil {
		edges = append(edges, user.EdgeFollowedUsers)
	}
	if m.followerUsers != nil {
		edges = append(edges, user.EdgeFollowerUsers)
	}
	if m.followedBusinesses != nil {
		edges = append(edges, user.EdgeFollowedBusinesses)
	}
	if m.followerBusinesses != nil {
		edges = append(edges, user.EdgeFollowerBusinesses)
	}
	if m.reviews != nil {
		edges = append(edges, user.EdgeReviews)
	}
	if m.bookings != nil {
		edges = append(edges, user.EdgeBookings)
	}
	if m.reservations != nil {
		edges = append(edges, user.EdgeReservations)
	}
	if m.helps != nil {
		edges = append(edges, user.EdgeHelps)
	}
	if m.categories != nil {
		edges = append(edges, user.EdgeCategories)
	}
	if m.events != nil {
		edges = append(edges, user.EdgeEvents)
	}
	if m.places != nil {
		edges = append(edges, user.EdgePlaces)
	}
	if m.categoryAssignments != nil {
		edges = append(edges, user.EdgeCategoryAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserBusinesses:
		ids := make([]ent.Value, 0, len(m.userBusinesses))
		for id := range m.userBusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowedUsers:
		ids := make([]ent.Value, 0, len(m.followedUsers))
		for id := range m.followedUsers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowerUsers:
		ids := make([]ent.Value, 0, len(m.followerUsers))
		for id := range m.followerUsers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowedBusinesses:
		ids := make([]ent.Value, 0, len(m.followedBusinesses))
		for id := range m.followedBusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowerBusinesses:
		ids := make([]ent.Value, 0, len(m.followerBusinesses))
		for id := range m.followerBusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.reservations))
		for id := range m.reservations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHelps:
		ids := make([]ent.Value, 0, len(m.helps))
		for id := range m.helps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.categoryAssignments))
		for id := range m.categoryAssignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removeduserBusinesses != nil {
		edges = append(edges, user.EdgeUserBusinesses)
	}
	if m.removedcomments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.removedlikes != nil {
		edges = append(edges, user.EdgeLikes)
	}
	if m.removedposts != nil {
		edges = append(edges, user.EdgePosts)
	}
	if m.removedfollowedUsers != nil {
		edges = append(edges, user.EdgeFollowedUsers)
	}
	if m.removedfollowerUsers != nil {
		edges = append(edges, user.EdgeFollowerUsers)
	}
	if m.removedfollowedBusinesses != nil {
		edges = append(edges, user.EdgeFollowedBusinesses)
	}
	if m.removedfollowerBusinesses != nil {
		edges = append(edges, user.EdgeFollowerBusinesses)
	}
	if m.removedreviews != nil {
		edges = append(edges, user.EdgeReviews)
	}
	if m.removedbookings != nil {
		edges = append(edges, user.EdgeBookings)
	}
	if m.removedreservations != nil {
		edges = append(edges, user.EdgeReservations)
	}
	if m.removedhelps != nil {
		edges = append(edges, user.EdgeHelps)
	}
	if m.removedcategories != nil {
		edges = append(edges, user.EdgeCategories)
	}
	if m.removedevents != nil {
		edges = append(edges, user.EdgeEvents)
	}
	if m.removedplaces != nil {
		edges = append(edges, user.EdgePlaces)
	}
	if m.removedcategoryAssignments != nil {
		edges = append(edges, user.EdgeCategoryAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserBusinesses:
		ids := make([]ent.Value, 0, len(m.removeduserBusinesses))
		for id := range m.removeduserBusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowedUsers:
		ids := make([]ent.Value, 0, len(m.removedfollowedUsers))
		for id := range m.removedfollowedUsers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowerUsers:
		ids := make([]ent.Value, 0, len(m.removedfollowerUsers))
		for id := range m.removedfollowerUsers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowedBusinesses:
		ids := make([]ent.Value, 0, len(m.removedfollowedBusinesses))
		for id := range m.removedfollowedBusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowerBusinesses:
		ids := make([]ent.Value, 0, len(m.removedfollowerBusinesses))
		for id := range m.removedfollowerBusinesses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.removedreservations))
		for id := range m.removedreservations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHelps:
		ids := make([]ent.Value, 0, len(m.removedhelps))
		for id := range m.removedhelps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCategoryAssignments:
		ids := make([]ent.Value, 0, len(m.removedcategoryAssignments))
		for id := range m.removedcategoryAssignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.cleareduserBusinesses {
		edges = append(edges, user.EdgeUserBusinesses)
	}
	if m.clearedcomments {
		edges = append(edges, user.EdgeComments)
	}
	if m.clearedlikes {
		edges = append(edges, user.EdgeLikes)
	}
	if m.clearedposts {
		edges = append(edges, user.EdgePosts)
	}
	if m.clearedfollowedUsers {
		edges = append(edges, user.EdgeFollowedUsers)
	}
	if m.clearedfollowerUsers {
		edges = append(edges, user.EdgeFollowerUsers)
	}
	if m.clearedfollowedBusinesses {
		edges = append(edges, user.EdgeFollowedBusinesses)
	}
	if m.clearedfollowerBusinesses {
		edges = append(edges, user.EdgeFollowerBusinesses)
	}
	if m.clearedreviews {
		edges = append(edges, user.EdgeReviews)
	}
	if m.clearedbookings {
		edges = append(edges, user.EdgeBookings)
	}
	if m.clearedreservations {
		edges = append(edges, user.EdgeReservations)
	}
	if m.clearedhelps {
		edges = append(edges, user.EdgeHelps)
	}
	if m.clearedcategories {
		edges = append(edges, user.EdgeCategories)
	}
	if m.clearedevents {
		edges = append(edges, user.EdgeEvents)
	}
	if m.clearedplaces {
		edges = append(edges, user.EdgePlaces)
	}
	if m.clearedcategoryAssignments {
		edges = append(edges, user.EdgeCategoryAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserBusinesses:
		return m.cleareduserBusinesses
	case user.EdgeComments:
		return m.clearedcomments
	case user.EdgeLikes:
		return m.clearedlikes
	case user.EdgePosts:
		return m.clearedposts
	case user.EdgeFollowedUsers:
		return m.clearedfollowedUsers
	case user.EdgeFollowerUsers:
		return m.clearedfollowerUsers
	case user.EdgeFollowedBusinesses:
		return m.clearedfollowedBusinesses
	case user.EdgeFollowerBusinesses:
		return m.clearedfollowerBusinesses
	case user.EdgeReviews:
		return m.clearedreviews
	case user.EdgeBookings:
		return m.clearedbookings
	case user.EdgeReservations:
		return m.clearedreservations
	case user.EdgeHelps:
		return m.clearedhelps
	case user.EdgeCategories:
		return m.clearedcategories
	case user.EdgeEvents:
		return m.clearedevents
	case user.EdgePlaces:
		return m.clearedplaces
	case user.EdgeCategoryAssignments:
		return m.clearedcategoryAssignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserBusinesses:
		m.ResetUserBusinesses()
		return nil
	case user.EdgeComments:
		m.ResetComments()
		return nil
	case user.EdgeLikes:
		m.ResetLikes()
		return nil
	case user.EdgePosts:
		m.ResetPosts()
		return nil
	case user.EdgeFollowedUsers:
		m.ResetFollowedUsers()
		return nil
	case user.EdgeFollowerUsers:
		m.ResetFollowerUsers()
		return nil
	case user.EdgeFollowedBusinesses:
		m.ResetFollowedBusinesses()
		return nil
	case user.EdgeFollowerBusinesses:
		m.ResetFollowerBusinesses()
		return nil
	case user.EdgeReviews:
		m.ResetReviews()
		return nil
	case user.EdgeBookings:
		m.ResetBookings()
		return nil
	case user.EdgeReservations:
		m.ResetReservations()
		return nil
	case user.EdgeHelps:
		m.ResetHelps()
		return nil
	case user.EdgeCategories:
		m.ResetCategories()
		return nil
	case user.EdgeEvents:
		m.ResetEvents()
		return nil
	case user.EdgePlaces:
		m.ResetPlaces()
		return nil
	case user.EdgeCategoryAssignments:
		m.ResetCategoryAssignments()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserBusinessMutation represents an operation that mutates the UserBusiness nodes in the graph.
type UserBusinessMutation struct {
	config
	op              Op
	typ             string
	id              *string
	role            *string
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	business        *string
	clearedbusiness bool
	done            bool
	oldValue        func(context.Context) (*UserBusiness, error)
	predicates      []predicate.UserBusiness
}

var _ ent.Mutation = (*UserBusinessMutation)(nil)

// userbusinessOption allows management of the mutation configuration using functional options.
type userbusinessOption func(*UserBusinessMutation)

// newUserBusinessMutation creates new mutation for the UserBusiness entity.
func newUserBusinessMutation(c config, op Op, opts ...userbusinessOption) *UserBusinessMutation {
	m := &UserBusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserBusinessID sets the ID field of the mutation.
func withUserBusinessID(id string) userbusinessOption {
	return func(m *UserBusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *UserBusiness
		)
		m.oldValue = func(ctx context.Context) (*UserBusiness, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserBusiness.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserBusiness sets the old UserBusiness of the mutation.
func withUserBusiness(node *UserBusiness) userbusinessOption {
	return func(m *UserBusinessMutation) {
		m.oldValue = func(context.Context) (*UserBusiness, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserBusiness entities.
func (m *UserBusinessMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserBusinessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserBusinessMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserBusiness.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *UserBusinessMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserBusinessMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the UserBusiness entity.
// If the UserBusiness object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBusinessMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserBusinessMutation) ResetRole() {
	m.role = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserBusinessMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserBusinessMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserBusinessMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserBusinessMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserBusinessMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserBusinessMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *UserBusinessMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *UserBusinessMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *UserBusinessMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *UserBusinessMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *UserBusinessMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *UserBusinessMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// Where appends a list predicates to the UserBusinessMutation builder.
func (m *UserBusinessMutation) Where(ps ...predicate.UserBusiness) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBusinessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBusinessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBusiness, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBusinessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBusinessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBusiness).
func (m *UserBusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBusinessMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.role != nil {
		fields = append(fields, userbusiness.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBusinessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userbusiness.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userbusiness.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown UserBusiness field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userbusiness.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown UserBusiness field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBusinessMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBusinessMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBusinessMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserBusiness numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBusinessMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBusinessMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserBusiness nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBusinessMutation) ResetField(name string) error {
	switch name {
	case userbusiness.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserBusiness field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userbusiness.EdgeUser)
	}
	if m.business != nil {
		edges = append(edges, userbusiness.EdgeBusiness)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBusinessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userbusiness.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userbusiness.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBusinessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userbusiness.EdgeUser)
	}
	if m.clearedbusiness {
		edges = append(edges, userbusiness.EdgeBusiness)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBusinessMutation) EdgeCleared(name string) bool {
	switch name {
	case userbusiness.EdgeUser:
		return m.cleareduser
	case userbusiness.EdgeBusiness:
		return m.clearedbusiness
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBusinessMutation) ClearEdge(name string) error {
	switch name {
	case userbusiness.EdgeUser:
		m.ClearUser()
		return nil
	case userbusiness.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown UserBusiness unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBusinessMutation) ResetEdge(name string) error {
	switch name {
	case userbusiness.EdgeUser:
		m.ResetUser()
		return nil
	case userbusiness.EdgeBusiness:
		m.ResetBusiness()
		return nil
	}
	return fmt.Errorf("unknown UserBusiness edge %s", name)
}

// UserFollowBusinessMutation represents an operation that mutates the UserFollowBusiness nodes in the graph.
type UserFollowBusinessMutation struct {
	config
	op              Op
	typ             string
	id              *string
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	business        *string
	clearedbusiness bool
	done            bool
	oldValue        func(context.Context) (*UserFollowBusiness, error)
	predicates      []predicate.UserFollowBusiness
}

var _ ent.Mutation = (*UserFollowBusinessMutation)(nil)

// userfollowbusinessOption allows management of the mutation configuration using functional options.
type userfollowbusinessOption func(*UserFollowBusinessMutation)

// newUserFollowBusinessMutation creates new mutation for the UserFollowBusiness entity.
func newUserFollowBusinessMutation(c config, op Op, opts ...userfollowbusinessOption) *UserFollowBusinessMutation {
	m := &UserFollowBusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFollowBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFollowBusinessID sets the ID field of the mutation.
func withUserFollowBusinessID(id string) userfollowbusinessOption {
	return func(m *UserFollowBusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFollowBusiness
		)
		m.oldValue = func(ctx context.Context) (*UserFollowBusiness, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFollowBusiness.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFollowBusiness sets the old UserFollowBusiness of the mutation.
func withUserFollowBusiness(node *UserFollowBusiness) userfollowbusinessOption {
	return func(m *UserFollowBusinessMutation) {
		m.oldValue = func(context.Context) (*UserFollowBusiness, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFollowBusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFollowBusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFollowBusinessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFollowBusinessMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFollowBusiness.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserFollowBusinessMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserFollowBusinessMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserFollowBusinessMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserFollowBusinessMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserFollowBusinessMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserFollowBusinessMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *UserFollowBusinessMutation) SetBusinessID(id string) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *UserFollowBusinessMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *UserFollowBusinessMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *UserFollowBusinessMutation) BusinessID() (id string, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *UserFollowBusinessMutation) BusinessIDs() (ids []string) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *UserFollowBusinessMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// Where appends a list predicates to the UserFollowBusinessMutation builder.
func (m *UserFollowBusinessMutation) Where(ps ...predicate.UserFollowBusiness) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFollowBusinessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFollowBusinessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFollowBusiness, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFollowBusinessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFollowBusinessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFollowBusiness).
func (m *UserFollowBusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFollowBusinessMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFollowBusinessMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFollowBusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown UserFollowBusiness field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowBusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserFollowBusiness field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFollowBusinessMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFollowBusinessMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowBusinessMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown UserFollowBusiness numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFollowBusinessMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFollowBusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFollowBusinessMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFollowBusiness nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFollowBusinessMutation) ResetField(name string) error {
	return fmt.Errorf("unknown UserFollowBusiness field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFollowBusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userfollowbusiness.EdgeUser)
	}
	if m.business != nil {
		edges = append(edges, userfollowbusiness.EdgeBusiness)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFollowBusinessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfollowbusiness.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userfollowbusiness.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFollowBusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFollowBusinessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFollowBusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userfollowbusiness.EdgeUser)
	}
	if m.clearedbusiness {
		edges = append(edges, userfollowbusiness.EdgeBusiness)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFollowBusinessMutation) EdgeCleared(name string) bool {
	switch name {
	case userfollowbusiness.EdgeUser:
		return m.cleareduser
	case userfollowbusiness.EdgeBusiness:
		return m.clearedbusiness
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFollowBusinessMutation) ClearEdge(name string) error {
	switch name {
	case userfollowbusiness.EdgeUser:
		m.ClearUser()
		return nil
	case userfollowbusiness.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown UserFollowBusiness unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFollowBusinessMutation) ResetEdge(name string) error {
	switch name {
	case userfollowbusiness.EdgeUser:
		m.ResetUser()
		return nil
	case userfollowbusiness.EdgeBusiness:
		m.ResetBusiness()
		return nil
	}
	return fmt.Errorf("unknown UserFollowBusiness edge %s", name)
}

// UserFollowUserMutation represents an operation that mutates the UserFollowUser nodes in the graph.
type UserFollowUserMutation struct {
	config
	op              Op
	typ             string
	id              *string
	clearedFields   map[string]struct{}
	follower        *string
	clearedfollower bool
	followed        *string
	clearedfollowed bool
	done            bool
	oldValue        func(context.Context) (*UserFollowUser, error)
	predicates      []predicate.UserFollowUser
}

var _ ent.Mutation = (*UserFollowUserMutation)(nil)

// userfollowuserOption allows management of the mutation configuration using functional options.
type userfollowuserOption func(*UserFollowUserMutation)

// newUserFollowUserMutation creates new mutation for the UserFollowUser entity.
func newUserFollowUserMutation(c config, op Op, opts ...userfollowuserOption) *UserFollowUserMutation {
	m := &UserFollowUserMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFollowUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFollowUserID sets the ID field of the mutation.
func withUserFollowUserID(id string) userfollowuserOption {
	return func(m *UserFollowUserMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFollowUser
		)
		m.oldValue = func(ctx context.Context) (*UserFollowUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFollowUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFollowUser sets the old UserFollowUser of the mutation.
func withUserFollowUser(node *UserFollowUser) userfollowuserOption {
	return func(m *UserFollowUserMutation) {
		m.oldValue = func(context.Context) (*UserFollowUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFollowUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFollowUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFollowUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFollowUserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFollowUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFollowerID sets the "follower" edge to the User entity by id.
func (m *UserFollowUserMutation) SetFollowerID(id string) {
	m.follower = &id
}

// ClearFollower clears the "follower" edge to the User entity.
func (m *UserFollowUserMutation) ClearFollower() {
	m.clearedfollower = true
}

// FollowerCleared reports if the "follower" edge to the User entity was cleared.
func (m *UserFollowUserMutation) FollowerCleared() bool {
	return m.clearedfollower
}

// FollowerID returns the "follower" edge ID in the mutation.
func (m *UserFollowUserMutation) FollowerID() (id string, exists bool) {
	if m.follower != nil {
		return *m.follower, true
	}
	return
}

// FollowerIDs returns the "follower" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowerID instead. It exists only for internal usage by the builders.
func (m *UserFollowUserMutation) FollowerIDs() (ids []string) {
	if id := m.follower; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollower resets all changes to the "follower" edge.
func (m *UserFollowUserMutation) ResetFollower() {
	m.follower = nil
	m.clearedfollower = false
}

// SetFollowedID sets the "followed" edge to the User entity by id.
func (m *UserFollowUserMutation) SetFollowedID(id string) {
	m.followed = &id
}

// ClearFollowed clears the "followed" edge to the User entity.
func (m *UserFollowUserMutation) ClearFollowed() {
	m.clearedfollowed = true
}

// FollowedCleared reports if the "followed" edge to the User entity was cleared.
func (m *UserFollowUserMutation) FollowedCleared() bool {
	return m.clearedfollowed
}

// FollowedID returns the "followed" edge ID in the mutation.
func (m *UserFollowUserMutation) FollowedID() (id string, exists bool) {
	if m.followed != nil {
		return *m.followed, true
	}
	return
}

// FollowedIDs returns the "followed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowedID instead. It exists only for internal usage by the builders.
func (m *UserFollowUserMutation) FollowedIDs() (ids []string) {
	if id := m.followed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollowed resets all changes to the "followed" edge.
func (m *UserFollowUserMutation) ResetFollowed() {
	m.followed = nil
	m.clearedfollowed = false
}

// Where appends a list predicates to the UserFollowUserMutation builder.
func (m *UserFollowUserMutation) Where(ps ...predicate.UserFollowUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFollowUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFollowUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFollowUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFollowUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFollowUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFollowUser).
func (m *UserFollowUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFollowUserMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFollowUserMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFollowUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown UserFollowUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserFollowUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFollowUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFollowUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowUserMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown UserFollowUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFollowUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFollowUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFollowUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFollowUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFollowUserMutation) ResetField(name string) error {
	return fmt.Errorf("unknown UserFollowUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFollowUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.follower != nil {
		edges = append(edges, userfollowuser.EdgeFollower)
	}
	if m.followed != nil {
		edges = append(edges, userfollowuser.EdgeFollowed)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFollowUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfollowuser.EdgeFollower:
		if id := m.follower; id != nil {
			return []ent.Value{*id}
		}
	case userfollowuser.EdgeFollowed:
		if id := m.followed; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFollowUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFollowUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFollowUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfollower {
		edges = append(edges, userfollowuser.EdgeFollower)
	}
	if m.clearedfollowed {
		edges = append(edges, userfollowuser.EdgeFollowed)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFollowUserMutation) EdgeCleared(name string) bool {
	switch name {
	case userfollowuser.EdgeFollower:
		return m.clearedfollower
	case userfollowuser.EdgeFollowed:
		return m.clearedfollowed
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFollowUserMutation) ClearEdge(name string) error {
	switch name {
	case userfollowuser.EdgeFollower:
		m.ClearFollower()
		return nil
	case userfollowuser.EdgeFollowed:
		m.ClearFollowed()
		return nil
	}
	return fmt.Errorf("unknown UserFollowUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFollowUserMutation) ResetEdge(name string) error {
	switch name {
	case userfollowuser.EdgeFollower:
		m.ResetFollower()
		return nil
	case userfollowuser.EdgeFollowed:
		m.ResetFollowed()
		return nil
	}
	return fmt.Errorf("unknown UserFollowUser edge %s", name)
}
