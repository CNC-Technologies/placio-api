// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"placio-app/ent/migrate"

	"placio-app/ent/accountsettings"
	"placio-app/ent/amenity"
	"placio-app/ent/booking"
	"placio-app/ent/business"
	"placio-app/ent/businessfollowbusiness"
	"placio-app/ent/businessfollowevent"
	"placio-app/ent/businessfollowuser"
	"placio-app/ent/category"
	"placio-app/ent/categoryassignment"
	"placio-app/ent/chat"
	"placio-app/ent/comment"
	"placio-app/ent/event"
	"placio-app/ent/faq"
	"placio-app/ent/help"
	"placio-app/ent/like"
	"placio-app/ent/media"
	"placio-app/ent/menu"
	"placio-app/ent/order"
	"placio-app/ent/payment"
	"placio-app/ent/place"
	"placio-app/ent/post"
	"placio-app/ent/rating"
	"placio-app/ent/reaction"
	"placio-app/ent/reservation"
	"placio-app/ent/resourse"
	"placio-app/ent/review"
	"placio-app/ent/room"
	"placio-app/ent/ticket"
	"placio-app/ent/ticketoption"
	"placio-app/ent/user"
	"placio-app/ent/userbusiness"
	"placio-app/ent/userfollowbusiness"
	"placio-app/ent/userfollowevent"
	"placio-app/ent/userfollowplace"
	"placio-app/ent/userfollowuser"
	"placio-app/ent/userlikeplace"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AccountSettings is the client for interacting with the AccountSettings builders.
	AccountSettings *AccountSettingsClient
	// Amenity is the client for interacting with the Amenity builders.
	Amenity *AmenityClient
	// Booking is the client for interacting with the Booking builders.
	Booking *BookingClient
	// Business is the client for interacting with the Business builders.
	Business *BusinessClient
	// BusinessFollowBusiness is the client for interacting with the BusinessFollowBusiness builders.
	BusinessFollowBusiness *BusinessFollowBusinessClient
	// BusinessFollowEvent is the client for interacting with the BusinessFollowEvent builders.
	BusinessFollowEvent *BusinessFollowEventClient
	// BusinessFollowUser is the client for interacting with the BusinessFollowUser builders.
	BusinessFollowUser *BusinessFollowUserClient
	// Category is the client for interacting with the Category builders.
	Category *CategoryClient
	// CategoryAssignment is the client for interacting with the CategoryAssignment builders.
	CategoryAssignment *CategoryAssignmentClient
	// Chat is the client for interacting with the Chat builders.
	Chat *ChatClient
	// Comment is the client for interacting with the Comment builders.
	Comment *CommentClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// FAQ is the client for interacting with the FAQ builders.
	FAQ *FAQClient
	// Help is the client for interacting with the Help builders.
	Help *HelpClient
	// Like is the client for interacting with the Like builders.
	Like *LikeClient
	// Media is the client for interacting with the Media builders.
	Media *MediaClient
	// Menu is the client for interacting with the Menu builders.
	Menu *MenuClient
	// Order is the client for interacting with the Order builders.
	Order *OrderClient
	// Payment is the client for interacting with the Payment builders.
	Payment *PaymentClient
	// Place is the client for interacting with the Place builders.
	Place *PlaceClient
	// Post is the client for interacting with the Post builders.
	Post *PostClient
	// Rating is the client for interacting with the Rating builders.
	Rating *RatingClient
	// Reaction is the client for interacting with the Reaction builders.
	Reaction *ReactionClient
	// Reservation is the client for interacting with the Reservation builders.
	Reservation *ReservationClient
	// Resourse is the client for interacting with the Resourse builders.
	Resourse *ResourseClient
	// Review is the client for interacting with the Review builders.
	Review *ReviewClient
	// Room is the client for interacting with the Room builders.
	Room *RoomClient
	// Ticket is the client for interacting with the Ticket builders.
	Ticket *TicketClient
	// TicketOption is the client for interacting with the TicketOption builders.
	TicketOption *TicketOptionClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserBusiness is the client for interacting with the UserBusiness builders.
	UserBusiness *UserBusinessClient
	// UserFollowBusiness is the client for interacting with the UserFollowBusiness builders.
	UserFollowBusiness *UserFollowBusinessClient
	// UserFollowEvent is the client for interacting with the UserFollowEvent builders.
	UserFollowEvent *UserFollowEventClient
	// UserFollowPlace is the client for interacting with the UserFollowPlace builders.
	UserFollowPlace *UserFollowPlaceClient
	// UserFollowUser is the client for interacting with the UserFollowUser builders.
	UserFollowUser *UserFollowUserClient
	// UserLikePlace is the client for interacting with the UserLikePlace builders.
	UserLikePlace *UserLikePlaceClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AccountSettings = NewAccountSettingsClient(c.config)
	c.Amenity = NewAmenityClient(c.config)
	c.Booking = NewBookingClient(c.config)
	c.Business = NewBusinessClient(c.config)
	c.BusinessFollowBusiness = NewBusinessFollowBusinessClient(c.config)
	c.BusinessFollowEvent = NewBusinessFollowEventClient(c.config)
	c.BusinessFollowUser = NewBusinessFollowUserClient(c.config)
	c.Category = NewCategoryClient(c.config)
	c.CategoryAssignment = NewCategoryAssignmentClient(c.config)
	c.Chat = NewChatClient(c.config)
	c.Comment = NewCommentClient(c.config)
	c.Event = NewEventClient(c.config)
	c.FAQ = NewFAQClient(c.config)
	c.Help = NewHelpClient(c.config)
	c.Like = NewLikeClient(c.config)
	c.Media = NewMediaClient(c.config)
	c.Menu = NewMenuClient(c.config)
	c.Order = NewOrderClient(c.config)
	c.Payment = NewPaymentClient(c.config)
	c.Place = NewPlaceClient(c.config)
	c.Post = NewPostClient(c.config)
	c.Rating = NewRatingClient(c.config)
	c.Reaction = NewReactionClient(c.config)
	c.Reservation = NewReservationClient(c.config)
	c.Resourse = NewResourseClient(c.config)
	c.Review = NewReviewClient(c.config)
	c.Room = NewRoomClient(c.config)
	c.Ticket = NewTicketClient(c.config)
	c.TicketOption = NewTicketOptionClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserBusiness = NewUserBusinessClient(c.config)
	c.UserFollowBusiness = NewUserFollowBusinessClient(c.config)
	c.UserFollowEvent = NewUserFollowEventClient(c.config)
	c.UserFollowPlace = NewUserFollowPlaceClient(c.config)
	c.UserFollowUser = NewUserFollowUserClient(c.config)
	c.UserLikePlace = NewUserLikePlaceClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		AccountSettings:        NewAccountSettingsClient(cfg),
		Amenity:                NewAmenityClient(cfg),
		Booking:                NewBookingClient(cfg),
		Business:               NewBusinessClient(cfg),
		BusinessFollowBusiness: NewBusinessFollowBusinessClient(cfg),
		BusinessFollowEvent:    NewBusinessFollowEventClient(cfg),
		BusinessFollowUser:     NewBusinessFollowUserClient(cfg),
		Category:               NewCategoryClient(cfg),
		CategoryAssignment:     NewCategoryAssignmentClient(cfg),
		Chat:                   NewChatClient(cfg),
		Comment:                NewCommentClient(cfg),
		Event:                  NewEventClient(cfg),
		FAQ:                    NewFAQClient(cfg),
		Help:                   NewHelpClient(cfg),
		Like:                   NewLikeClient(cfg),
		Media:                  NewMediaClient(cfg),
		Menu:                   NewMenuClient(cfg),
		Order:                  NewOrderClient(cfg),
		Payment:                NewPaymentClient(cfg),
		Place:                  NewPlaceClient(cfg),
		Post:                   NewPostClient(cfg),
		Rating:                 NewRatingClient(cfg),
		Reaction:               NewReactionClient(cfg),
		Reservation:            NewReservationClient(cfg),
		Resourse:               NewResourseClient(cfg),
		Review:                 NewReviewClient(cfg),
		Room:                   NewRoomClient(cfg),
		Ticket:                 NewTicketClient(cfg),
		TicketOption:           NewTicketOptionClient(cfg),
		User:                   NewUserClient(cfg),
		UserBusiness:           NewUserBusinessClient(cfg),
		UserFollowBusiness:     NewUserFollowBusinessClient(cfg),
		UserFollowEvent:        NewUserFollowEventClient(cfg),
		UserFollowPlace:        NewUserFollowPlaceClient(cfg),
		UserFollowUser:         NewUserFollowUserClient(cfg),
		UserLikePlace:          NewUserLikePlaceClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		AccountSettings:        NewAccountSettingsClient(cfg),
		Amenity:                NewAmenityClient(cfg),
		Booking:                NewBookingClient(cfg),
		Business:               NewBusinessClient(cfg),
		BusinessFollowBusiness: NewBusinessFollowBusinessClient(cfg),
		BusinessFollowEvent:    NewBusinessFollowEventClient(cfg),
		BusinessFollowUser:     NewBusinessFollowUserClient(cfg),
		Category:               NewCategoryClient(cfg),
		CategoryAssignment:     NewCategoryAssignmentClient(cfg),
		Chat:                   NewChatClient(cfg),
		Comment:                NewCommentClient(cfg),
		Event:                  NewEventClient(cfg),
		FAQ:                    NewFAQClient(cfg),
		Help:                   NewHelpClient(cfg),
		Like:                   NewLikeClient(cfg),
		Media:                  NewMediaClient(cfg),
		Menu:                   NewMenuClient(cfg),
		Order:                  NewOrderClient(cfg),
		Payment:                NewPaymentClient(cfg),
		Place:                  NewPlaceClient(cfg),
		Post:                   NewPostClient(cfg),
		Rating:                 NewRatingClient(cfg),
		Reaction:               NewReactionClient(cfg),
		Reservation:            NewReservationClient(cfg),
		Resourse:               NewResourseClient(cfg),
		Review:                 NewReviewClient(cfg),
		Room:                   NewRoomClient(cfg),
		Ticket:                 NewTicketClient(cfg),
		TicketOption:           NewTicketOptionClient(cfg),
		User:                   NewUserClient(cfg),
		UserBusiness:           NewUserBusinessClient(cfg),
		UserFollowBusiness:     NewUserFollowBusinessClient(cfg),
		UserFollowEvent:        NewUserFollowEventClient(cfg),
		UserFollowPlace:        NewUserFollowPlaceClient(cfg),
		UserFollowUser:         NewUserFollowUserClient(cfg),
		UserLikePlace:          NewUserLikePlaceClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AccountSettings.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AccountSettings, c.Amenity, c.Booking, c.Business, c.BusinessFollowBusiness,
		c.BusinessFollowEvent, c.BusinessFollowUser, c.Category, c.CategoryAssignment,
		c.Chat, c.Comment, c.Event, c.FAQ, c.Help, c.Like, c.Media, c.Menu, c.Order,
		c.Payment, c.Place, c.Post, c.Rating, c.Reaction, c.Reservation, c.Resourse,
		c.Review, c.Room, c.Ticket, c.TicketOption, c.User, c.UserBusiness,
		c.UserFollowBusiness, c.UserFollowEvent, c.UserFollowPlace, c.UserFollowUser,
		c.UserLikePlace,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AccountSettings, c.Amenity, c.Booking, c.Business, c.BusinessFollowBusiness,
		c.BusinessFollowEvent, c.BusinessFollowUser, c.Category, c.CategoryAssignment,
		c.Chat, c.Comment, c.Event, c.FAQ, c.Help, c.Like, c.Media, c.Menu, c.Order,
		c.Payment, c.Place, c.Post, c.Rating, c.Reaction, c.Reservation, c.Resourse,
		c.Review, c.Room, c.Ticket, c.TicketOption, c.User, c.UserBusiness,
		c.UserFollowBusiness, c.UserFollowEvent, c.UserFollowPlace, c.UserFollowUser,
		c.UserLikePlace,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccountSettingsMutation:
		return c.AccountSettings.mutate(ctx, m)
	case *AmenityMutation:
		return c.Amenity.mutate(ctx, m)
	case *BookingMutation:
		return c.Booking.mutate(ctx, m)
	case *BusinessMutation:
		return c.Business.mutate(ctx, m)
	case *BusinessFollowBusinessMutation:
		return c.BusinessFollowBusiness.mutate(ctx, m)
	case *BusinessFollowEventMutation:
		return c.BusinessFollowEvent.mutate(ctx, m)
	case *BusinessFollowUserMutation:
		return c.BusinessFollowUser.mutate(ctx, m)
	case *CategoryMutation:
		return c.Category.mutate(ctx, m)
	case *CategoryAssignmentMutation:
		return c.CategoryAssignment.mutate(ctx, m)
	case *ChatMutation:
		return c.Chat.mutate(ctx, m)
	case *CommentMutation:
		return c.Comment.mutate(ctx, m)
	case *EventMutation:
		return c.Event.mutate(ctx, m)
	case *FAQMutation:
		return c.FAQ.mutate(ctx, m)
	case *HelpMutation:
		return c.Help.mutate(ctx, m)
	case *LikeMutation:
		return c.Like.mutate(ctx, m)
	case *MediaMutation:
		return c.Media.mutate(ctx, m)
	case *MenuMutation:
		return c.Menu.mutate(ctx, m)
	case *OrderMutation:
		return c.Order.mutate(ctx, m)
	case *PaymentMutation:
		return c.Payment.mutate(ctx, m)
	case *PlaceMutation:
		return c.Place.mutate(ctx, m)
	case *PostMutation:
		return c.Post.mutate(ctx, m)
	case *RatingMutation:
		return c.Rating.mutate(ctx, m)
	case *ReactionMutation:
		return c.Reaction.mutate(ctx, m)
	case *ReservationMutation:
		return c.Reservation.mutate(ctx, m)
	case *ResourseMutation:
		return c.Resourse.mutate(ctx, m)
	case *ReviewMutation:
		return c.Review.mutate(ctx, m)
	case *RoomMutation:
		return c.Room.mutate(ctx, m)
	case *TicketMutation:
		return c.Ticket.mutate(ctx, m)
	case *TicketOptionMutation:
		return c.TicketOption.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserBusinessMutation:
		return c.UserBusiness.mutate(ctx, m)
	case *UserFollowBusinessMutation:
		return c.UserFollowBusiness.mutate(ctx, m)
	case *UserFollowEventMutation:
		return c.UserFollowEvent.mutate(ctx, m)
	case *UserFollowPlaceMutation:
		return c.UserFollowPlace.mutate(ctx, m)
	case *UserFollowUserMutation:
		return c.UserFollowUser.mutate(ctx, m)
	case *UserLikePlaceMutation:
		return c.UserLikePlace.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AccountSettingsClient is a client for the AccountSettings schema.
type AccountSettingsClient struct {
	config
}

// NewAccountSettingsClient returns a client for the AccountSettings from the given config.
func NewAccountSettingsClient(c config) *AccountSettingsClient {
	return &AccountSettingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accountsettings.Hooks(f(g(h())))`.
func (c *AccountSettingsClient) Use(hooks ...Hook) {
	c.hooks.AccountSettings = append(c.hooks.AccountSettings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accountsettings.Intercept(f(g(h())))`.
func (c *AccountSettingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccountSettings = append(c.inters.AccountSettings, interceptors...)
}

// Create returns a builder for creating a AccountSettings entity.
func (c *AccountSettingsClient) Create() *AccountSettingsCreate {
	mutation := newAccountSettingsMutation(c.config, OpCreate)
	return &AccountSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccountSettings entities.
func (c *AccountSettingsClient) CreateBulk(builders ...*AccountSettingsCreate) *AccountSettingsCreateBulk {
	return &AccountSettingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccountSettings.
func (c *AccountSettingsClient) Update() *AccountSettingsUpdate {
	mutation := newAccountSettingsMutation(c.config, OpUpdate)
	return &AccountSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountSettingsClient) UpdateOne(as *AccountSettings) *AccountSettingsUpdateOne {
	mutation := newAccountSettingsMutation(c.config, OpUpdateOne, withAccountSettings(as))
	return &AccountSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountSettingsClient) UpdateOneID(id string) *AccountSettingsUpdateOne {
	mutation := newAccountSettingsMutation(c.config, OpUpdateOne, withAccountSettingsID(id))
	return &AccountSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccountSettings.
func (c *AccountSettingsClient) Delete() *AccountSettingsDelete {
	mutation := newAccountSettingsMutation(c.config, OpDelete)
	return &AccountSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountSettingsClient) DeleteOne(as *AccountSettings) *AccountSettingsDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountSettingsClient) DeleteOneID(id string) *AccountSettingsDeleteOne {
	builder := c.Delete().Where(accountsettings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountSettingsDeleteOne{builder}
}

// Query returns a query builder for AccountSettings.
func (c *AccountSettingsClient) Query() *AccountSettingsQuery {
	return &AccountSettingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccountSettings},
		inters: c.Interceptors(),
	}
}

// Get returns a AccountSettings entity by its id.
func (c *AccountSettingsClient) Get(ctx context.Context, id string) (*AccountSettings, error) {
	return c.Query().Where(accountsettings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountSettingsClient) GetX(ctx context.Context, id string) *AccountSettings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBusinessAccount queries the business_account edge of a AccountSettings.
func (c *AccountSettingsClient) QueryBusinessAccount(as *AccountSettings) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountsettings.Table, accountsettings.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, accountsettings.BusinessAccountTable, accountsettings.BusinessAccountColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountSettingsClient) Hooks() []Hook {
	return c.hooks.AccountSettings
}

// Interceptors returns the client interceptors.
func (c *AccountSettingsClient) Interceptors() []Interceptor {
	return c.inters.AccountSettings
}

func (c *AccountSettingsClient) mutate(ctx context.Context, m *AccountSettingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AccountSettings mutation op: %q", m.Op())
	}
}

// AmenityClient is a client for the Amenity schema.
type AmenityClient struct {
	config
}

// NewAmenityClient returns a client for the Amenity from the given config.
func NewAmenityClient(c config) *AmenityClient {
	return &AmenityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `amenity.Hooks(f(g(h())))`.
func (c *AmenityClient) Use(hooks ...Hook) {
	c.hooks.Amenity = append(c.hooks.Amenity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `amenity.Intercept(f(g(h())))`.
func (c *AmenityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Amenity = append(c.inters.Amenity, interceptors...)
}

// Create returns a builder for creating a Amenity entity.
func (c *AmenityClient) Create() *AmenityCreate {
	mutation := newAmenityMutation(c.config, OpCreate)
	return &AmenityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Amenity entities.
func (c *AmenityClient) CreateBulk(builders ...*AmenityCreate) *AmenityCreateBulk {
	return &AmenityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Amenity.
func (c *AmenityClient) Update() *AmenityUpdate {
	mutation := newAmenityMutation(c.config, OpUpdate)
	return &AmenityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AmenityClient) UpdateOne(a *Amenity) *AmenityUpdateOne {
	mutation := newAmenityMutation(c.config, OpUpdateOne, withAmenity(a))
	return &AmenityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AmenityClient) UpdateOneID(id string) *AmenityUpdateOne {
	mutation := newAmenityMutation(c.config, OpUpdateOne, withAmenityID(id))
	return &AmenityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Amenity.
func (c *AmenityClient) Delete() *AmenityDelete {
	mutation := newAmenityMutation(c.config, OpDelete)
	return &AmenityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AmenityClient) DeleteOne(a *Amenity) *AmenityDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AmenityClient) DeleteOneID(id string) *AmenityDeleteOne {
	builder := c.Delete().Where(amenity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AmenityDeleteOne{builder}
}

// Query returns a query builder for Amenity.
func (c *AmenityClient) Query() *AmenityQuery {
	return &AmenityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAmenity},
		inters: c.Interceptors(),
	}
}

// Get returns a Amenity entity by its id.
func (c *AmenityClient) Get(ctx context.Context, id string) (*Amenity, error) {
	return c.Query().Where(amenity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AmenityClient) GetX(ctx context.Context, id string) *Amenity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlaces queries the places edge of a Amenity.
func (c *AmenityClient) QueryPlaces(a *Amenity) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(amenity.Table, amenity.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, amenity.PlacesTable, amenity.PlacesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AmenityClient) Hooks() []Hook {
	return c.hooks.Amenity
}

// Interceptors returns the client interceptors.
func (c *AmenityClient) Interceptors() []Interceptor {
	return c.inters.Amenity
}

func (c *AmenityClient) mutate(ctx context.Context, m *AmenityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AmenityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AmenityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AmenityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AmenityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Amenity mutation op: %q", m.Op())
	}
}

// BookingClient is a client for the Booking schema.
type BookingClient struct {
	config
}

// NewBookingClient returns a client for the Booking from the given config.
func NewBookingClient(c config) *BookingClient {
	return &BookingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `booking.Hooks(f(g(h())))`.
func (c *BookingClient) Use(hooks ...Hook) {
	c.hooks.Booking = append(c.hooks.Booking, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `booking.Intercept(f(g(h())))`.
func (c *BookingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Booking = append(c.inters.Booking, interceptors...)
}

// Create returns a builder for creating a Booking entity.
func (c *BookingClient) Create() *BookingCreate {
	mutation := newBookingMutation(c.config, OpCreate)
	return &BookingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Booking entities.
func (c *BookingClient) CreateBulk(builders ...*BookingCreate) *BookingCreateBulk {
	return &BookingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Booking.
func (c *BookingClient) Update() *BookingUpdate {
	mutation := newBookingMutation(c.config, OpUpdate)
	return &BookingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookingClient) UpdateOne(b *Booking) *BookingUpdateOne {
	mutation := newBookingMutation(c.config, OpUpdateOne, withBooking(b))
	return &BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookingClient) UpdateOneID(id string) *BookingUpdateOne {
	mutation := newBookingMutation(c.config, OpUpdateOne, withBookingID(id))
	return &BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Booking.
func (c *BookingClient) Delete() *BookingDelete {
	mutation := newBookingMutation(c.config, OpDelete)
	return &BookingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookingClient) DeleteOne(b *Booking) *BookingDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookingClient) DeleteOneID(id string) *BookingDeleteOne {
	builder := c.Delete().Where(booking.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookingDeleteOne{builder}
}

// Query returns a query builder for Booking.
func (c *BookingClient) Query() *BookingQuery {
	return &BookingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBooking},
		inters: c.Interceptors(),
	}
}

// Get returns a Booking entity by its id.
func (c *BookingClient) Get(ctx context.Context, id string) (*Booking, error) {
	return c.Query().Where(booking.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookingClient) GetX(ctx context.Context, id string) *Booking {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoom queries the room edge of a Booking.
func (c *BookingClient) QueryRoom(b *Booking) *RoomQuery {
	query := (&RoomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(room.Table, room.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, booking.RoomTable, booking.RoomColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Booking.
func (c *BookingClient) QueryUser(b *Booking) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, booking.UserTable, booking.UserColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BookingClient) Hooks() []Hook {
	return c.hooks.Booking
}

// Interceptors returns the client interceptors.
func (c *BookingClient) Interceptors() []Interceptor {
	return c.inters.Booking
}

func (c *BookingClient) mutate(ctx context.Context, m *BookingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Booking mutation op: %q", m.Op())
	}
}

// BusinessClient is a client for the Business schema.
type BusinessClient struct {
	config
}

// NewBusinessClient returns a client for the Business from the given config.
func NewBusinessClient(c config) *BusinessClient {
	return &BusinessClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `business.Hooks(f(g(h())))`.
func (c *BusinessClient) Use(hooks ...Hook) {
	c.hooks.Business = append(c.hooks.Business, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `business.Intercept(f(g(h())))`.
func (c *BusinessClient) Intercept(interceptors ...Interceptor) {
	c.inters.Business = append(c.inters.Business, interceptors...)
}

// Create returns a builder for creating a Business entity.
func (c *BusinessClient) Create() *BusinessCreate {
	mutation := newBusinessMutation(c.config, OpCreate)
	return &BusinessCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Business entities.
func (c *BusinessClient) CreateBulk(builders ...*BusinessCreate) *BusinessCreateBulk {
	return &BusinessCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Business.
func (c *BusinessClient) Update() *BusinessUpdate {
	mutation := newBusinessMutation(c.config, OpUpdate)
	return &BusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BusinessClient) UpdateOne(b *Business) *BusinessUpdateOne {
	mutation := newBusinessMutation(c.config, OpUpdateOne, withBusiness(b))
	return &BusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BusinessClient) UpdateOneID(id string) *BusinessUpdateOne {
	mutation := newBusinessMutation(c.config, OpUpdateOne, withBusinessID(id))
	return &BusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Business.
func (c *BusinessClient) Delete() *BusinessDelete {
	mutation := newBusinessMutation(c.config, OpDelete)
	return &BusinessDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BusinessClient) DeleteOne(b *Business) *BusinessDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BusinessClient) DeleteOneID(id string) *BusinessDeleteOne {
	builder := c.Delete().Where(business.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BusinessDeleteOne{builder}
}

// Query returns a query builder for Business.
func (c *BusinessClient) Query() *BusinessQuery {
	return &BusinessQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBusiness},
		inters: c.Interceptors(),
	}
}

// Get returns a Business entity by its id.
func (c *BusinessClient) Get(ctx context.Context, id string) (*Business, error) {
	return c.Query().Where(business.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BusinessClient) GetX(ctx context.Context, id string) *Business {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserBusinesses queries the userBusinesses edge of a Business.
func (c *BusinessClient) QueryUserBusinesses(b *Business) *UserBusinessQuery {
	query := (&UserBusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(userbusiness.Table, userbusiness.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.UserBusinessesTable, business.UserBusinessesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusinessAccountSettings queries the business_account_settings edge of a Business.
func (c *BusinessClient) QueryBusinessAccountSettings(b *Business) *AccountSettingsQuery {
	query := (&AccountSettingsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(accountsettings.Table, accountsettings.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, business.BusinessAccountSettingsTable, business.BusinessAccountSettingsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPosts queries the posts edge of a Business.
func (c *BusinessClient) QueryPosts(b *Business) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.PostsTable, business.PostsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowedUsers queries the followedUsers edge of a Business.
func (c *BusinessClient) QueryFollowedUsers(b *Business) *BusinessFollowUserQuery {
	query := (&BusinessFollowUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(businessfollowuser.Table, businessfollowuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.FollowedUsersTable, business.FollowedUsersColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowerUsers queries the followerUsers edge of a Business.
func (c *BusinessClient) QueryFollowerUsers(b *Business) *UserFollowBusinessQuery {
	query := (&UserFollowBusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(userfollowbusiness.Table, userfollowbusiness.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.FollowerUsersTable, business.FollowerUsersColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowedBusinesses queries the followedBusinesses edge of a Business.
func (c *BusinessClient) QueryFollowedBusinesses(b *Business) *BusinessFollowBusinessQuery {
	query := (&BusinessFollowBusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(businessfollowbusiness.Table, businessfollowbusiness.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.FollowedBusinessesTable, business.FollowedBusinessesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowerBusinesses queries the followerBusinesses edge of a Business.
func (c *BusinessClient) QueryFollowerBusinesses(b *Business) *BusinessFollowBusinessQuery {
	query := (&BusinessFollowBusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(businessfollowbusiness.Table, businessfollowbusiness.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.FollowerBusinessesTable, business.FollowerBusinessesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaces queries the places edge of a Business.
func (c *BusinessClient) QueryPlaces(b *Business) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.PlacesTable, business.PlacesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a Business.
func (c *BusinessClient) QueryCategories(b *Business) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.CategoriesTable, business.CategoriesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategoryAssignments queries the categoryAssignments edge of a Business.
func (c *BusinessClient) QueryCategoryAssignments(b *Business) *CategoryAssignmentQuery {
	query := (&CategoryAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(categoryassignment.Table, categoryassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.CategoryAssignmentsTable, business.CategoryAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Business.
func (c *BusinessClient) QueryEvents(b *Business) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.EventsTable, business.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusinessFollowEvents queries the businessFollowEvents edge of a Business.
func (c *BusinessClient) QueryBusinessFollowEvents(b *Business) *BusinessFollowEventQuery {
	query := (&BusinessFollowEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(businessfollowevent.Table, businessfollowevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.BusinessFollowEventsTable, business.BusinessFollowEventsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFaqs queries the faqs edge of a Business.
func (c *BusinessClient) QueryFaqs(b *Business) *FAQQuery {
	query := (&FAQClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(faq.Table, faq.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.FaqsTable, business.FaqsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRatings queries the ratings edge of a Business.
func (c *BusinessClient) QueryRatings(b *Business) *RatingQuery {
	query := (&RatingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(business.Table, business.FieldID, id),
			sqlgraph.To(rating.Table, rating.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, business.RatingsTable, business.RatingsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BusinessClient) Hooks() []Hook {
	hooks := c.hooks.Business
	return append(hooks[:len(hooks):len(hooks)], business.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *BusinessClient) Interceptors() []Interceptor {
	return c.inters.Business
}

func (c *BusinessClient) mutate(ctx context.Context, m *BusinessMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BusinessCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BusinessDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Business mutation op: %q", m.Op())
	}
}

// BusinessFollowBusinessClient is a client for the BusinessFollowBusiness schema.
type BusinessFollowBusinessClient struct {
	config
}

// NewBusinessFollowBusinessClient returns a client for the BusinessFollowBusiness from the given config.
func NewBusinessFollowBusinessClient(c config) *BusinessFollowBusinessClient {
	return &BusinessFollowBusinessClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `businessfollowbusiness.Hooks(f(g(h())))`.
func (c *BusinessFollowBusinessClient) Use(hooks ...Hook) {
	c.hooks.BusinessFollowBusiness = append(c.hooks.BusinessFollowBusiness, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `businessfollowbusiness.Intercept(f(g(h())))`.
func (c *BusinessFollowBusinessClient) Intercept(interceptors ...Interceptor) {
	c.inters.BusinessFollowBusiness = append(c.inters.BusinessFollowBusiness, interceptors...)
}

// Create returns a builder for creating a BusinessFollowBusiness entity.
func (c *BusinessFollowBusinessClient) Create() *BusinessFollowBusinessCreate {
	mutation := newBusinessFollowBusinessMutation(c.config, OpCreate)
	return &BusinessFollowBusinessCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BusinessFollowBusiness entities.
func (c *BusinessFollowBusinessClient) CreateBulk(builders ...*BusinessFollowBusinessCreate) *BusinessFollowBusinessCreateBulk {
	return &BusinessFollowBusinessCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BusinessFollowBusiness.
func (c *BusinessFollowBusinessClient) Update() *BusinessFollowBusinessUpdate {
	mutation := newBusinessFollowBusinessMutation(c.config, OpUpdate)
	return &BusinessFollowBusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BusinessFollowBusinessClient) UpdateOne(bfb *BusinessFollowBusiness) *BusinessFollowBusinessUpdateOne {
	mutation := newBusinessFollowBusinessMutation(c.config, OpUpdateOne, withBusinessFollowBusiness(bfb))
	return &BusinessFollowBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BusinessFollowBusinessClient) UpdateOneID(id string) *BusinessFollowBusinessUpdateOne {
	mutation := newBusinessFollowBusinessMutation(c.config, OpUpdateOne, withBusinessFollowBusinessID(id))
	return &BusinessFollowBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BusinessFollowBusiness.
func (c *BusinessFollowBusinessClient) Delete() *BusinessFollowBusinessDelete {
	mutation := newBusinessFollowBusinessMutation(c.config, OpDelete)
	return &BusinessFollowBusinessDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BusinessFollowBusinessClient) DeleteOne(bfb *BusinessFollowBusiness) *BusinessFollowBusinessDeleteOne {
	return c.DeleteOneID(bfb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BusinessFollowBusinessClient) DeleteOneID(id string) *BusinessFollowBusinessDeleteOne {
	builder := c.Delete().Where(businessfollowbusiness.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BusinessFollowBusinessDeleteOne{builder}
}

// Query returns a query builder for BusinessFollowBusiness.
func (c *BusinessFollowBusinessClient) Query() *BusinessFollowBusinessQuery {
	return &BusinessFollowBusinessQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBusinessFollowBusiness},
		inters: c.Interceptors(),
	}
}

// Get returns a BusinessFollowBusiness entity by its id.
func (c *BusinessFollowBusinessClient) Get(ctx context.Context, id string) (*BusinessFollowBusiness, error) {
	return c.Query().Where(businessfollowbusiness.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BusinessFollowBusinessClient) GetX(ctx context.Context, id string) *BusinessFollowBusiness {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFollower queries the follower edge of a BusinessFollowBusiness.
func (c *BusinessFollowBusinessClient) QueryFollower(bfb *BusinessFollowBusiness) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bfb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(businessfollowbusiness.Table, businessfollowbusiness.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, businessfollowbusiness.FollowerTable, businessfollowbusiness.FollowerColumn),
		)
		fromV = sqlgraph.Neighbors(bfb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowed queries the followed edge of a BusinessFollowBusiness.
func (c *BusinessFollowBusinessClient) QueryFollowed(bfb *BusinessFollowBusiness) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bfb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(businessfollowbusiness.Table, businessfollowbusiness.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, businessfollowbusiness.FollowedTable, businessfollowbusiness.FollowedColumn),
		)
		fromV = sqlgraph.Neighbors(bfb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BusinessFollowBusinessClient) Hooks() []Hook {
	return c.hooks.BusinessFollowBusiness
}

// Interceptors returns the client interceptors.
func (c *BusinessFollowBusinessClient) Interceptors() []Interceptor {
	return c.inters.BusinessFollowBusiness
}

func (c *BusinessFollowBusinessClient) mutate(ctx context.Context, m *BusinessFollowBusinessMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BusinessFollowBusinessCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BusinessFollowBusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BusinessFollowBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BusinessFollowBusinessDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BusinessFollowBusiness mutation op: %q", m.Op())
	}
}

// BusinessFollowEventClient is a client for the BusinessFollowEvent schema.
type BusinessFollowEventClient struct {
	config
}

// NewBusinessFollowEventClient returns a client for the BusinessFollowEvent from the given config.
func NewBusinessFollowEventClient(c config) *BusinessFollowEventClient {
	return &BusinessFollowEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `businessfollowevent.Hooks(f(g(h())))`.
func (c *BusinessFollowEventClient) Use(hooks ...Hook) {
	c.hooks.BusinessFollowEvent = append(c.hooks.BusinessFollowEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `businessfollowevent.Intercept(f(g(h())))`.
func (c *BusinessFollowEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.BusinessFollowEvent = append(c.inters.BusinessFollowEvent, interceptors...)
}

// Create returns a builder for creating a BusinessFollowEvent entity.
func (c *BusinessFollowEventClient) Create() *BusinessFollowEventCreate {
	mutation := newBusinessFollowEventMutation(c.config, OpCreate)
	return &BusinessFollowEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BusinessFollowEvent entities.
func (c *BusinessFollowEventClient) CreateBulk(builders ...*BusinessFollowEventCreate) *BusinessFollowEventCreateBulk {
	return &BusinessFollowEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BusinessFollowEvent.
func (c *BusinessFollowEventClient) Update() *BusinessFollowEventUpdate {
	mutation := newBusinessFollowEventMutation(c.config, OpUpdate)
	return &BusinessFollowEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BusinessFollowEventClient) UpdateOne(bfe *BusinessFollowEvent) *BusinessFollowEventUpdateOne {
	mutation := newBusinessFollowEventMutation(c.config, OpUpdateOne, withBusinessFollowEvent(bfe))
	return &BusinessFollowEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BusinessFollowEventClient) UpdateOneID(id string) *BusinessFollowEventUpdateOne {
	mutation := newBusinessFollowEventMutation(c.config, OpUpdateOne, withBusinessFollowEventID(id))
	return &BusinessFollowEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BusinessFollowEvent.
func (c *BusinessFollowEventClient) Delete() *BusinessFollowEventDelete {
	mutation := newBusinessFollowEventMutation(c.config, OpDelete)
	return &BusinessFollowEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BusinessFollowEventClient) DeleteOne(bfe *BusinessFollowEvent) *BusinessFollowEventDeleteOne {
	return c.DeleteOneID(bfe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BusinessFollowEventClient) DeleteOneID(id string) *BusinessFollowEventDeleteOne {
	builder := c.Delete().Where(businessfollowevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BusinessFollowEventDeleteOne{builder}
}

// Query returns a query builder for BusinessFollowEvent.
func (c *BusinessFollowEventClient) Query() *BusinessFollowEventQuery {
	return &BusinessFollowEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBusinessFollowEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a BusinessFollowEvent entity by its id.
func (c *BusinessFollowEventClient) Get(ctx context.Context, id string) (*BusinessFollowEvent, error) {
	return c.Query().Where(businessfollowevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BusinessFollowEventClient) GetX(ctx context.Context, id string) *BusinessFollowEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBusiness queries the business edge of a BusinessFollowEvent.
func (c *BusinessFollowEventClient) QueryBusiness(bfe *BusinessFollowEvent) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bfe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(businessfollowevent.Table, businessfollowevent.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, businessfollowevent.BusinessTable, businessfollowevent.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(bfe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a BusinessFollowEvent.
func (c *BusinessFollowEventClient) QueryEvent(bfe *BusinessFollowEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bfe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(businessfollowevent.Table, businessfollowevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, businessfollowevent.EventTable, businessfollowevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(bfe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BusinessFollowEventClient) Hooks() []Hook {
	return c.hooks.BusinessFollowEvent
}

// Interceptors returns the client interceptors.
func (c *BusinessFollowEventClient) Interceptors() []Interceptor {
	return c.inters.BusinessFollowEvent
}

func (c *BusinessFollowEventClient) mutate(ctx context.Context, m *BusinessFollowEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BusinessFollowEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BusinessFollowEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BusinessFollowEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BusinessFollowEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BusinessFollowEvent mutation op: %q", m.Op())
	}
}

// BusinessFollowUserClient is a client for the BusinessFollowUser schema.
type BusinessFollowUserClient struct {
	config
}

// NewBusinessFollowUserClient returns a client for the BusinessFollowUser from the given config.
func NewBusinessFollowUserClient(c config) *BusinessFollowUserClient {
	return &BusinessFollowUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `businessfollowuser.Hooks(f(g(h())))`.
func (c *BusinessFollowUserClient) Use(hooks ...Hook) {
	c.hooks.BusinessFollowUser = append(c.hooks.BusinessFollowUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `businessfollowuser.Intercept(f(g(h())))`.
func (c *BusinessFollowUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.BusinessFollowUser = append(c.inters.BusinessFollowUser, interceptors...)
}

// Create returns a builder for creating a BusinessFollowUser entity.
func (c *BusinessFollowUserClient) Create() *BusinessFollowUserCreate {
	mutation := newBusinessFollowUserMutation(c.config, OpCreate)
	return &BusinessFollowUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BusinessFollowUser entities.
func (c *BusinessFollowUserClient) CreateBulk(builders ...*BusinessFollowUserCreate) *BusinessFollowUserCreateBulk {
	return &BusinessFollowUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BusinessFollowUser.
func (c *BusinessFollowUserClient) Update() *BusinessFollowUserUpdate {
	mutation := newBusinessFollowUserMutation(c.config, OpUpdate)
	return &BusinessFollowUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BusinessFollowUserClient) UpdateOne(bfu *BusinessFollowUser) *BusinessFollowUserUpdateOne {
	mutation := newBusinessFollowUserMutation(c.config, OpUpdateOne, withBusinessFollowUser(bfu))
	return &BusinessFollowUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BusinessFollowUserClient) UpdateOneID(id string) *BusinessFollowUserUpdateOne {
	mutation := newBusinessFollowUserMutation(c.config, OpUpdateOne, withBusinessFollowUserID(id))
	return &BusinessFollowUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BusinessFollowUser.
func (c *BusinessFollowUserClient) Delete() *BusinessFollowUserDelete {
	mutation := newBusinessFollowUserMutation(c.config, OpDelete)
	return &BusinessFollowUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BusinessFollowUserClient) DeleteOne(bfu *BusinessFollowUser) *BusinessFollowUserDeleteOne {
	return c.DeleteOneID(bfu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BusinessFollowUserClient) DeleteOneID(id string) *BusinessFollowUserDeleteOne {
	builder := c.Delete().Where(businessfollowuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BusinessFollowUserDeleteOne{builder}
}

// Query returns a query builder for BusinessFollowUser.
func (c *BusinessFollowUserClient) Query() *BusinessFollowUserQuery {
	return &BusinessFollowUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBusinessFollowUser},
		inters: c.Interceptors(),
	}
}

// Get returns a BusinessFollowUser entity by its id.
func (c *BusinessFollowUserClient) Get(ctx context.Context, id string) (*BusinessFollowUser, error) {
	return c.Query().Where(businessfollowuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BusinessFollowUserClient) GetX(ctx context.Context, id string) *BusinessFollowUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBusiness queries the business edge of a BusinessFollowUser.
func (c *BusinessFollowUserClient) QueryBusiness(bfu *BusinessFollowUser) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bfu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(businessfollowuser.Table, businessfollowuser.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, businessfollowuser.BusinessTable, businessfollowuser.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(bfu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a BusinessFollowUser.
func (c *BusinessFollowUserClient) QueryUser(bfu *BusinessFollowUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bfu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(businessfollowuser.Table, businessfollowuser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, businessfollowuser.UserTable, businessfollowuser.UserColumn),
		)
		fromV = sqlgraph.Neighbors(bfu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BusinessFollowUserClient) Hooks() []Hook {
	return c.hooks.BusinessFollowUser
}

// Interceptors returns the client interceptors.
func (c *BusinessFollowUserClient) Interceptors() []Interceptor {
	return c.inters.BusinessFollowUser
}

func (c *BusinessFollowUserClient) mutate(ctx context.Context, m *BusinessFollowUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BusinessFollowUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BusinessFollowUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BusinessFollowUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BusinessFollowUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BusinessFollowUser mutation op: %q", m.Op())
	}
}

// CategoryClient is a client for the Category schema.
type CategoryClient struct {
	config
}

// NewCategoryClient returns a client for the Category from the given config.
func NewCategoryClient(c config) *CategoryClient {
	return &CategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `category.Hooks(f(g(h())))`.
func (c *CategoryClient) Use(hooks ...Hook) {
	c.hooks.Category = append(c.hooks.Category, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `category.Intercept(f(g(h())))`.
func (c *CategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Category = append(c.inters.Category, interceptors...)
}

// Create returns a builder for creating a Category entity.
func (c *CategoryClient) Create() *CategoryCreate {
	mutation := newCategoryMutation(c.config, OpCreate)
	return &CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Category entities.
func (c *CategoryClient) CreateBulk(builders ...*CategoryCreate) *CategoryCreateBulk {
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Category.
func (c *CategoryClient) Update() *CategoryUpdate {
	mutation := newCategoryMutation(c.config, OpUpdate)
	return &CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryClient) UpdateOne(ca *Category) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategory(ca))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryClient) UpdateOneID(id string) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategoryID(id))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Category.
func (c *CategoryClient) Delete() *CategoryDelete {
	mutation := newCategoryMutation(c.config, OpDelete)
	return &CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CategoryClient) DeleteOne(ca *Category) *CategoryDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CategoryClient) DeleteOneID(id string) *CategoryDeleteOne {
	builder := c.Delete().Where(category.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryDeleteOne{builder}
}

// Query returns a query builder for Category.
func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a Category entity by its id.
func (c *CategoryClient) Get(ctx context.Context, id string) (*Category, error) {
	return c.Query().Where(category.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryClient) GetX(ctx context.Context, id string) *Category {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCategoryAssignments queries the categoryAssignments edge of a Category.
func (c *CategoryClient) QueryCategoryAssignments(ca *Category) *CategoryAssignmentQuery {
	query := (&CategoryAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(categoryassignment.Table, categoryassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, category.CategoryAssignmentsTable, category.CategoryAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CategoryClient) Hooks() []Hook {
	return c.hooks.Category
}

// Interceptors returns the client interceptors.
func (c *CategoryClient) Interceptors() []Interceptor {
	return c.inters.Category
}

func (c *CategoryClient) mutate(ctx context.Context, m *CategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Category mutation op: %q", m.Op())
	}
}

// CategoryAssignmentClient is a client for the CategoryAssignment schema.
type CategoryAssignmentClient struct {
	config
}

// NewCategoryAssignmentClient returns a client for the CategoryAssignment from the given config.
func NewCategoryAssignmentClient(c config) *CategoryAssignmentClient {
	return &CategoryAssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `categoryassignment.Hooks(f(g(h())))`.
func (c *CategoryAssignmentClient) Use(hooks ...Hook) {
	c.hooks.CategoryAssignment = append(c.hooks.CategoryAssignment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `categoryassignment.Intercept(f(g(h())))`.
func (c *CategoryAssignmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.CategoryAssignment = append(c.inters.CategoryAssignment, interceptors...)
}

// Create returns a builder for creating a CategoryAssignment entity.
func (c *CategoryAssignmentClient) Create() *CategoryAssignmentCreate {
	mutation := newCategoryAssignmentMutation(c.config, OpCreate)
	return &CategoryAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CategoryAssignment entities.
func (c *CategoryAssignmentClient) CreateBulk(builders ...*CategoryAssignmentCreate) *CategoryAssignmentCreateBulk {
	return &CategoryAssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CategoryAssignment.
func (c *CategoryAssignmentClient) Update() *CategoryAssignmentUpdate {
	mutation := newCategoryAssignmentMutation(c.config, OpUpdate)
	return &CategoryAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryAssignmentClient) UpdateOne(ca *CategoryAssignment) *CategoryAssignmentUpdateOne {
	mutation := newCategoryAssignmentMutation(c.config, OpUpdateOne, withCategoryAssignment(ca))
	return &CategoryAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryAssignmentClient) UpdateOneID(id string) *CategoryAssignmentUpdateOne {
	mutation := newCategoryAssignmentMutation(c.config, OpUpdateOne, withCategoryAssignmentID(id))
	return &CategoryAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CategoryAssignment.
func (c *CategoryAssignmentClient) Delete() *CategoryAssignmentDelete {
	mutation := newCategoryAssignmentMutation(c.config, OpDelete)
	return &CategoryAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CategoryAssignmentClient) DeleteOne(ca *CategoryAssignment) *CategoryAssignmentDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CategoryAssignmentClient) DeleteOneID(id string) *CategoryAssignmentDeleteOne {
	builder := c.Delete().Where(categoryassignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryAssignmentDeleteOne{builder}
}

// Query returns a query builder for CategoryAssignment.
func (c *CategoryAssignmentClient) Query() *CategoryAssignmentQuery {
	return &CategoryAssignmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCategoryAssignment},
		inters: c.Interceptors(),
	}
}

// Get returns a CategoryAssignment entity by its id.
func (c *CategoryAssignmentClient) Get(ctx context.Context, id string) (*CategoryAssignment, error) {
	return c.Query().Where(categoryassignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryAssignmentClient) GetX(ctx context.Context, id string) *CategoryAssignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CategoryAssignment.
func (c *CategoryAssignmentClient) QueryUser(ca *CategoryAssignment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(categoryassignment.Table, categoryassignment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, categoryassignment.UserTable, categoryassignment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a CategoryAssignment.
func (c *CategoryAssignmentClient) QueryBusiness(ca *CategoryAssignment) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(categoryassignment.Table, categoryassignment.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, categoryassignment.BusinessTable, categoryassignment.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a CategoryAssignment.
func (c *CategoryAssignmentClient) QueryPlace(ca *CategoryAssignment) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(categoryassignment.Table, categoryassignment.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, categoryassignment.PlaceTable, categoryassignment.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategory queries the category edge of a CategoryAssignment.
func (c *CategoryAssignmentClient) QueryCategory(ca *CategoryAssignment) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(categoryassignment.Table, categoryassignment.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, categoryassignment.CategoryTable, categoryassignment.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CategoryAssignmentClient) Hooks() []Hook {
	return c.hooks.CategoryAssignment
}

// Interceptors returns the client interceptors.
func (c *CategoryAssignmentClient) Interceptors() []Interceptor {
	return c.inters.CategoryAssignment
}

func (c *CategoryAssignmentClient) mutate(ctx context.Context, m *CategoryAssignmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CategoryAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CategoryAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CategoryAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CategoryAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CategoryAssignment mutation op: %q", m.Op())
	}
}

// ChatClient is a client for the Chat schema.
type ChatClient struct {
	config
}

// NewChatClient returns a client for the Chat from the given config.
func NewChatClient(c config) *ChatClient {
	return &ChatClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `chat.Hooks(f(g(h())))`.
func (c *ChatClient) Use(hooks ...Hook) {
	c.hooks.Chat = append(c.hooks.Chat, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `chat.Intercept(f(g(h())))`.
func (c *ChatClient) Intercept(interceptors ...Interceptor) {
	c.inters.Chat = append(c.inters.Chat, interceptors...)
}

// Create returns a builder for creating a Chat entity.
func (c *ChatClient) Create() *ChatCreate {
	mutation := newChatMutation(c.config, OpCreate)
	return &ChatCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Chat entities.
func (c *ChatClient) CreateBulk(builders ...*ChatCreate) *ChatCreateBulk {
	return &ChatCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Chat.
func (c *ChatClient) Update() *ChatUpdate {
	mutation := newChatMutation(c.config, OpUpdate)
	return &ChatUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChatClient) UpdateOne(ch *Chat) *ChatUpdateOne {
	mutation := newChatMutation(c.config, OpUpdateOne, withChat(ch))
	return &ChatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChatClient) UpdateOneID(id string) *ChatUpdateOne {
	mutation := newChatMutation(c.config, OpUpdateOne, withChatID(id))
	return &ChatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Chat.
func (c *ChatClient) Delete() *ChatDelete {
	mutation := newChatMutation(c.config, OpDelete)
	return &ChatDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChatClient) DeleteOne(ch *Chat) *ChatDeleteOne {
	return c.DeleteOneID(ch.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChatClient) DeleteOneID(id string) *ChatDeleteOne {
	builder := c.Delete().Where(chat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChatDeleteOne{builder}
}

// Query returns a query builder for Chat.
func (c *ChatClient) Query() *ChatQuery {
	return &ChatQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChat},
		inters: c.Interceptors(),
	}
}

// Get returns a Chat entity by its id.
func (c *ChatClient) Get(ctx context.Context, id string) (*Chat, error) {
	return c.Query().Where(chat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChatClient) GetX(ctx context.Context, id string) *Chat {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ChatClient) Hooks() []Hook {
	return c.hooks.Chat
}

// Interceptors returns the client interceptors.
func (c *ChatClient) Interceptors() []Interceptor {
	return c.inters.Chat
}

func (c *ChatClient) mutate(ctx context.Context, m *ChatMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChatCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChatUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChatDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Chat mutation op: %q", m.Op())
	}
}

// CommentClient is a client for the Comment schema.
type CommentClient struct {
	config
}

// NewCommentClient returns a client for the Comment from the given config.
func NewCommentClient(c config) *CommentClient {
	return &CommentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `comment.Hooks(f(g(h())))`.
func (c *CommentClient) Use(hooks ...Hook) {
	c.hooks.Comment = append(c.hooks.Comment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `comment.Intercept(f(g(h())))`.
func (c *CommentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Comment = append(c.inters.Comment, interceptors...)
}

// Create returns a builder for creating a Comment entity.
func (c *CommentClient) Create() *CommentCreate {
	mutation := newCommentMutation(c.config, OpCreate)
	return &CommentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Comment entities.
func (c *CommentClient) CreateBulk(builders ...*CommentCreate) *CommentCreateBulk {
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Comment.
func (c *CommentClient) Update() *CommentUpdate {
	mutation := newCommentMutation(c.config, OpUpdate)
	return &CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommentClient) UpdateOne(co *Comment) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withComment(co))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommentClient) UpdateOneID(id string) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withCommentID(id))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Comment.
func (c *CommentClient) Delete() *CommentDelete {
	mutation := newCommentMutation(c.config, OpDelete)
	return &CommentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommentClient) DeleteOne(co *Comment) *CommentDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommentClient) DeleteOneID(id string) *CommentDeleteOne {
	builder := c.Delete().Where(comment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommentDeleteOne{builder}
}

// Query returns a query builder for Comment.
func (c *CommentClient) Query() *CommentQuery {
	return &CommentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComment},
		inters: c.Interceptors(),
	}
}

// Get returns a Comment entity by its id.
func (c *CommentClient) Get(ctx context.Context, id string) (*Comment, error) {
	return c.Query().Where(comment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommentClient) GetX(ctx context.Context, id string) *Comment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Comment.
func (c *CommentClient) QueryUser(co *Comment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.UserTable, comment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPost queries the post edge of a Comment.
func (c *CommentClient) QueryPost(co *Comment) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.PostTable, comment.PostColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CommentClient) Hooks() []Hook {
	return c.hooks.Comment
}

// Interceptors returns the client interceptors.
func (c *CommentClient) Interceptors() []Interceptor {
	return c.inters.Comment
}

func (c *CommentClient) mutate(ctx context.Context, m *CommentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Comment mutation op: %q", m.Op())
	}
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `event.Intercept(f(g(h())))`.
func (c *EventClient) Intercept(interceptors ...Interceptor) {
	c.inters.Event = append(c.inters.Event, interceptors...)
}

// Create returns a builder for creating a Event entity.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(e *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(e))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id string) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventClient) DeleteOne(e *Event) *EventDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventClient) DeleteOneID(id string) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id string) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id string) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTickets queries the tickets edge of a Event.
func (c *EventClient) QueryTickets(e *Event) *TicketQuery {
	query := (&TicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.TicketsTable, event.TicketsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTicketOptions queries the ticket_options edge of a Event.
func (c *EventClient) QueryTicketOptions(e *Event) *TicketOptionQuery {
	query := (&TicketOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(ticketoption.Table, ticketoption.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.TicketOptionsTable, event.TicketOptionsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a Event.
func (c *EventClient) QueryPlace(e *Event) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.PlaceTable, event.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventCategories queries the event_categories edge of a Event.
func (c *EventClient) QueryEventCategories(e *Event) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.EventCategoriesTable, event.EventCategoriesColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventCategoryAssignments queries the event_category_assignments edge of a Event.
func (c *EventClient) QueryEventCategoryAssignments(e *Event) *CategoryAssignmentQuery {
	query := (&CategoryAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(categoryassignment.Table, categoryassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.EventCategoryAssignmentsTable, event.EventCategoryAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnerUser queries the ownerUser edge of a Event.
func (c *EventClient) QueryOwnerUser(e *Event) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, event.OwnerUserTable, event.OwnerUserColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnerBusiness queries the ownerBusiness edge of a Event.
func (c *EventClient) QueryOwnerBusiness(e *Event) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, event.OwnerBusinessTable, event.OwnerBusinessColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserFollowers queries the userFollowers edge of a Event.
func (c *EventClient) QueryUserFollowers(e *Event) *UserFollowEventQuery {
	query := (&UserFollowEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(userfollowevent.Table, userfollowevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, event.UserFollowersTable, event.UserFollowersColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusinessFollowers queries the businessFollowers edge of a Event.
func (c *EventClient) QueryBusinessFollowers(e *Event) *BusinessFollowEventQuery {
	query := (&BusinessFollowEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(businessfollowevent.Table, businessfollowevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, event.BusinessFollowersTable, event.BusinessFollowersColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFaqs queries the faqs edge of a Event.
func (c *EventClient) QueryFaqs(e *Event) *FAQQuery {
	query := (&FAQClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(faq.Table, faq.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.FaqsTable, event.FaqsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRatings queries the ratings edge of a Event.
func (c *EventClient) QueryRatings(e *Event) *RatingQuery {
	query := (&RatingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(rating.Table, rating.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.RatingsTable, event.RatingsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	hooks := c.hooks.Event
	return append(hooks[:len(hooks):len(hooks)], event.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EventClient) Interceptors() []Interceptor {
	return c.inters.Event
}

func (c *EventClient) mutate(ctx context.Context, m *EventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Event mutation op: %q", m.Op())
	}
}

// FAQClient is a client for the FAQ schema.
type FAQClient struct {
	config
}

// NewFAQClient returns a client for the FAQ from the given config.
func NewFAQClient(c config) *FAQClient {
	return &FAQClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `faq.Hooks(f(g(h())))`.
func (c *FAQClient) Use(hooks ...Hook) {
	c.hooks.FAQ = append(c.hooks.FAQ, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `faq.Intercept(f(g(h())))`.
func (c *FAQClient) Intercept(interceptors ...Interceptor) {
	c.inters.FAQ = append(c.inters.FAQ, interceptors...)
}

// Create returns a builder for creating a FAQ entity.
func (c *FAQClient) Create() *FAQCreate {
	mutation := newFAQMutation(c.config, OpCreate)
	return &FAQCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FAQ entities.
func (c *FAQClient) CreateBulk(builders ...*FAQCreate) *FAQCreateBulk {
	return &FAQCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FAQ.
func (c *FAQClient) Update() *FAQUpdate {
	mutation := newFAQMutation(c.config, OpUpdate)
	return &FAQUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FAQClient) UpdateOne(f *FAQ) *FAQUpdateOne {
	mutation := newFAQMutation(c.config, OpUpdateOne, withFAQ(f))
	return &FAQUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FAQClient) UpdateOneID(id string) *FAQUpdateOne {
	mutation := newFAQMutation(c.config, OpUpdateOne, withFAQID(id))
	return &FAQUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FAQ.
func (c *FAQClient) Delete() *FAQDelete {
	mutation := newFAQMutation(c.config, OpDelete)
	return &FAQDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FAQClient) DeleteOne(f *FAQ) *FAQDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FAQClient) DeleteOneID(id string) *FAQDeleteOne {
	builder := c.Delete().Where(faq.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FAQDeleteOne{builder}
}

// Query returns a query builder for FAQ.
func (c *FAQClient) Query() *FAQQuery {
	return &FAQQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFAQ},
		inters: c.Interceptors(),
	}
}

// Get returns a FAQ entity by its id.
func (c *FAQClient) Get(ctx context.Context, id string) (*FAQ, error) {
	return c.Query().Where(faq.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FAQClient) GetX(ctx context.Context, id string) *FAQ {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBusiness queries the business edge of a FAQ.
func (c *FAQClient) QueryBusiness(f *FAQ) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(faq.Table, faq.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, faq.BusinessTable, faq.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a FAQ.
func (c *FAQClient) QueryPlace(f *FAQ) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(faq.Table, faq.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, faq.PlaceTable, faq.PlacePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a FAQ.
func (c *FAQClient) QueryEvent(f *FAQ) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(faq.Table, faq.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, faq.EventTable, faq.EventPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FAQClient) Hooks() []Hook {
	return c.hooks.FAQ
}

// Interceptors returns the client interceptors.
func (c *FAQClient) Interceptors() []Interceptor {
	return c.inters.FAQ
}

func (c *FAQClient) mutate(ctx context.Context, m *FAQMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FAQCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FAQUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FAQUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FAQDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FAQ mutation op: %q", m.Op())
	}
}

// HelpClient is a client for the Help schema.
type HelpClient struct {
	config
}

// NewHelpClient returns a client for the Help from the given config.
func NewHelpClient(c config) *HelpClient {
	return &HelpClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `help.Hooks(f(g(h())))`.
func (c *HelpClient) Use(hooks ...Hook) {
	c.hooks.Help = append(c.hooks.Help, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `help.Intercept(f(g(h())))`.
func (c *HelpClient) Intercept(interceptors ...Interceptor) {
	c.inters.Help = append(c.inters.Help, interceptors...)
}

// Create returns a builder for creating a Help entity.
func (c *HelpClient) Create() *HelpCreate {
	mutation := newHelpMutation(c.config, OpCreate)
	return &HelpCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Help entities.
func (c *HelpClient) CreateBulk(builders ...*HelpCreate) *HelpCreateBulk {
	return &HelpCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Help.
func (c *HelpClient) Update() *HelpUpdate {
	mutation := newHelpMutation(c.config, OpUpdate)
	return &HelpUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HelpClient) UpdateOne(h *Help) *HelpUpdateOne {
	mutation := newHelpMutation(c.config, OpUpdateOne, withHelp(h))
	return &HelpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HelpClient) UpdateOneID(id string) *HelpUpdateOne {
	mutation := newHelpMutation(c.config, OpUpdateOne, withHelpID(id))
	return &HelpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Help.
func (c *HelpClient) Delete() *HelpDelete {
	mutation := newHelpMutation(c.config, OpDelete)
	return &HelpDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HelpClient) DeleteOne(h *Help) *HelpDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HelpClient) DeleteOneID(id string) *HelpDeleteOne {
	builder := c.Delete().Where(help.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HelpDeleteOne{builder}
}

// Query returns a query builder for Help.
func (c *HelpClient) Query() *HelpQuery {
	return &HelpQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHelp},
		inters: c.Interceptors(),
	}
}

// Get returns a Help entity by its id.
func (c *HelpClient) Get(ctx context.Context, id string) (*Help, error) {
	return c.Query().Where(help.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HelpClient) GetX(ctx context.Context, id string) *Help {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Help.
func (c *HelpClient) QueryUser(h *Help) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(help.Table, help.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, help.UserTable, help.UserColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HelpClient) Hooks() []Hook {
	return c.hooks.Help
}

// Interceptors returns the client interceptors.
func (c *HelpClient) Interceptors() []Interceptor {
	return c.inters.Help
}

func (c *HelpClient) mutate(ctx context.Context, m *HelpMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HelpCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HelpUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HelpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HelpDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Help mutation op: %q", m.Op())
	}
}

// LikeClient is a client for the Like schema.
type LikeClient struct {
	config
}

// NewLikeClient returns a client for the Like from the given config.
func NewLikeClient(c config) *LikeClient {
	return &LikeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `like.Hooks(f(g(h())))`.
func (c *LikeClient) Use(hooks ...Hook) {
	c.hooks.Like = append(c.hooks.Like, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `like.Intercept(f(g(h())))`.
func (c *LikeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Like = append(c.inters.Like, interceptors...)
}

// Create returns a builder for creating a Like entity.
func (c *LikeClient) Create() *LikeCreate {
	mutation := newLikeMutation(c.config, OpCreate)
	return &LikeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Like entities.
func (c *LikeClient) CreateBulk(builders ...*LikeCreate) *LikeCreateBulk {
	return &LikeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Like.
func (c *LikeClient) Update() *LikeUpdate {
	mutation := newLikeMutation(c.config, OpUpdate)
	return &LikeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LikeClient) UpdateOne(l *Like) *LikeUpdateOne {
	mutation := newLikeMutation(c.config, OpUpdateOne, withLike(l))
	return &LikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LikeClient) UpdateOneID(id string) *LikeUpdateOne {
	mutation := newLikeMutation(c.config, OpUpdateOne, withLikeID(id))
	return &LikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Like.
func (c *LikeClient) Delete() *LikeDelete {
	mutation := newLikeMutation(c.config, OpDelete)
	return &LikeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LikeClient) DeleteOne(l *Like) *LikeDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LikeClient) DeleteOneID(id string) *LikeDeleteOne {
	builder := c.Delete().Where(like.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LikeDeleteOne{builder}
}

// Query returns a query builder for Like.
func (c *LikeClient) Query() *LikeQuery {
	return &LikeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLike},
		inters: c.Interceptors(),
	}
}

// Get returns a Like entity by its id.
func (c *LikeClient) Get(ctx context.Context, id string) (*Like, error) {
	return c.Query().Where(like.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LikeClient) GetX(ctx context.Context, id string) *Like {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Like.
func (c *LikeClient) QueryUser(l *Like) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(like.Table, like.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, like.UserTable, like.UserColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReview queries the review edge of a Like.
func (c *LikeClient) QueryReview(l *Like) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(like.Table, like.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, like.ReviewTable, like.ReviewColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a Like.
func (c *LikeClient) QueryMedia(l *Like) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(like.Table, like.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, like.MediaTable, like.MediaColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPost queries the post edge of a Like.
func (c *LikeClient) QueryPost(l *Like) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(like.Table, like.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, like.PostTable, like.PostColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LikeClient) Hooks() []Hook {
	return c.hooks.Like
}

// Interceptors returns the client interceptors.
func (c *LikeClient) Interceptors() []Interceptor {
	return c.inters.Like
}

func (c *LikeClient) mutate(ctx context.Context, m *LikeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LikeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LikeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LikeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Like mutation op: %q", m.Op())
	}
}

// MediaClient is a client for the Media schema.
type MediaClient struct {
	config
}

// NewMediaClient returns a client for the Media from the given config.
func NewMediaClient(c config) *MediaClient {
	return &MediaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `media.Hooks(f(g(h())))`.
func (c *MediaClient) Use(hooks ...Hook) {
	c.hooks.Media = append(c.hooks.Media, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `media.Intercept(f(g(h())))`.
func (c *MediaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Media = append(c.inters.Media, interceptors...)
}

// Create returns a builder for creating a Media entity.
func (c *MediaClient) Create() *MediaCreate {
	mutation := newMediaMutation(c.config, OpCreate)
	return &MediaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Media entities.
func (c *MediaClient) CreateBulk(builders ...*MediaCreate) *MediaCreateBulk {
	return &MediaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Media.
func (c *MediaClient) Update() *MediaUpdate {
	mutation := newMediaMutation(c.config, OpUpdate)
	return &MediaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MediaClient) UpdateOne(m *Media) *MediaUpdateOne {
	mutation := newMediaMutation(c.config, OpUpdateOne, withMedia(m))
	return &MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MediaClient) UpdateOneID(id string) *MediaUpdateOne {
	mutation := newMediaMutation(c.config, OpUpdateOne, withMediaID(id))
	return &MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Media.
func (c *MediaClient) Delete() *MediaDelete {
	mutation := newMediaMutation(c.config, OpDelete)
	return &MediaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MediaClient) DeleteOne(m *Media) *MediaDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MediaClient) DeleteOneID(id string) *MediaDeleteOne {
	builder := c.Delete().Where(media.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MediaDeleteOne{builder}
}

// Query returns a query builder for Media.
func (c *MediaClient) Query() *MediaQuery {
	return &MediaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedia},
		inters: c.Interceptors(),
	}
}

// Get returns a Media entity by its id.
func (c *MediaClient) Get(ctx context.Context, id string) (*Media, error) {
	return c.Query().Where(media.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MediaClient) GetX(ctx context.Context, id string) *Media {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPost queries the post edge of a Media.
func (c *MediaClient) QueryPost(m *Media) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, media.PostTable, media.PostColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReview queries the review edge of a Media.
func (c *MediaClient) QueryReview(m *Media) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, media.ReviewTable, media.ReviewColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a Media.
func (c *MediaClient) QueryCategories(m *Media) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, media.CategoriesTable, media.CategoriesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MediaClient) Hooks() []Hook {
	return c.hooks.Media
}

// Interceptors returns the client interceptors.
func (c *MediaClient) Interceptors() []Interceptor {
	return c.inters.Media
}

func (c *MediaClient) mutate(ctx context.Context, m *MediaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MediaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MediaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MediaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Media mutation op: %q", m.Op())
	}
}

// MenuClient is a client for the Menu schema.
type MenuClient struct {
	config
}

// NewMenuClient returns a client for the Menu from the given config.
func NewMenuClient(c config) *MenuClient {
	return &MenuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menu.Hooks(f(g(h())))`.
func (c *MenuClient) Use(hooks ...Hook) {
	c.hooks.Menu = append(c.hooks.Menu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menu.Intercept(f(g(h())))`.
func (c *MenuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Menu = append(c.inters.Menu, interceptors...)
}

// Create returns a builder for creating a Menu entity.
func (c *MenuClient) Create() *MenuCreate {
	mutation := newMenuMutation(c.config, OpCreate)
	return &MenuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Menu entities.
func (c *MenuClient) CreateBulk(builders ...*MenuCreate) *MenuCreateBulk {
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Menu.
func (c *MenuClient) Update() *MenuUpdate {
	mutation := newMenuMutation(c.config, OpUpdate)
	return &MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuClient) UpdateOne(m *Menu) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenu(m))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuClient) UpdateOneID(id string) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenuID(id))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Menu.
func (c *MenuClient) Delete() *MenuDelete {
	mutation := newMenuMutation(c.config, OpDelete)
	return &MenuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuClient) DeleteOne(m *Menu) *MenuDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuClient) DeleteOneID(id string) *MenuDeleteOne {
	builder := c.Delete().Where(menu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuDeleteOne{builder}
}

// Query returns a query builder for Menu.
func (c *MenuClient) Query() *MenuQuery {
	return &MenuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenu},
		inters: c.Interceptors(),
	}
}

// Get returns a Menu entity by its id.
func (c *MenuClient) Get(ctx context.Context, id string) (*Menu, error) {
	return c.Query().Where(menu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuClient) GetX(ctx context.Context, id string) *Menu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlace queries the place edge of a Menu.
func (c *MenuClient) QueryPlace(m *Menu) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, menu.PlaceTable, menu.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a Menu.
func (c *MenuClient) QueryCategories(m *Menu) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menu.CategoriesTable, menu.CategoriesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuClient) Hooks() []Hook {
	return c.hooks.Menu
}

// Interceptors returns the client interceptors.
func (c *MenuClient) Interceptors() []Interceptor {
	return c.inters.Menu
}

func (c *MenuClient) mutate(ctx context.Context, m *MenuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Menu mutation op: %q", m.Op())
	}
}

// OrderClient is a client for the Order schema.
type OrderClient struct {
	config
}

// NewOrderClient returns a client for the Order from the given config.
func NewOrderClient(c config) *OrderClient {
	return &OrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `order.Hooks(f(g(h())))`.
func (c *OrderClient) Use(hooks ...Hook) {
	c.hooks.Order = append(c.hooks.Order, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `order.Intercept(f(g(h())))`.
func (c *OrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Order = append(c.inters.Order, interceptors...)
}

// Create returns a builder for creating a Order entity.
func (c *OrderClient) Create() *OrderCreate {
	mutation := newOrderMutation(c.config, OpCreate)
	return &OrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Order entities.
func (c *OrderClient) CreateBulk(builders ...*OrderCreate) *OrderCreateBulk {
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Order.
func (c *OrderClient) Update() *OrderUpdate {
	mutation := newOrderMutation(c.config, OpUpdate)
	return &OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderClient) UpdateOne(o *Order) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrder(o))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderClient) UpdateOneID(id string) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrderID(id))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Order.
func (c *OrderClient) Delete() *OrderDelete {
	mutation := newOrderMutation(c.config, OpDelete)
	return &OrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderClient) DeleteOne(o *Order) *OrderDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderClient) DeleteOneID(id string) *OrderDeleteOne {
	builder := c.Delete().Where(order.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderDeleteOne{builder}
}

// Query returns a query builder for Order.
func (c *OrderClient) Query() *OrderQuery {
	return &OrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a Order entity by its id.
func (c *OrderClient) Get(ctx context.Context, id string) (*Order, error) {
	return c.Query().Where(order.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderClient) GetX(ctx context.Context, id string) *Order {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrderClient) Hooks() []Hook {
	return c.hooks.Order
}

// Interceptors returns the client interceptors.
func (c *OrderClient) Interceptors() []Interceptor {
	return c.inters.Order
}

func (c *OrderClient) mutate(ctx context.Context, m *OrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Order mutation op: %q", m.Op())
	}
}

// PaymentClient is a client for the Payment schema.
type PaymentClient struct {
	config
}

// NewPaymentClient returns a client for the Payment from the given config.
func NewPaymentClient(c config) *PaymentClient {
	return &PaymentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `payment.Hooks(f(g(h())))`.
func (c *PaymentClient) Use(hooks ...Hook) {
	c.hooks.Payment = append(c.hooks.Payment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `payment.Intercept(f(g(h())))`.
func (c *PaymentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Payment = append(c.inters.Payment, interceptors...)
}

// Create returns a builder for creating a Payment entity.
func (c *PaymentClient) Create() *PaymentCreate {
	mutation := newPaymentMutation(c.config, OpCreate)
	return &PaymentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Payment entities.
func (c *PaymentClient) CreateBulk(builders ...*PaymentCreate) *PaymentCreateBulk {
	return &PaymentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Payment.
func (c *PaymentClient) Update() *PaymentUpdate {
	mutation := newPaymentMutation(c.config, OpUpdate)
	return &PaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentClient) UpdateOne(pa *Payment) *PaymentUpdateOne {
	mutation := newPaymentMutation(c.config, OpUpdateOne, withPayment(pa))
	return &PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentClient) UpdateOneID(id string) *PaymentUpdateOne {
	mutation := newPaymentMutation(c.config, OpUpdateOne, withPaymentID(id))
	return &PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Payment.
func (c *PaymentClient) Delete() *PaymentDelete {
	mutation := newPaymentMutation(c.config, OpDelete)
	return &PaymentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PaymentClient) DeleteOne(pa *Payment) *PaymentDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PaymentClient) DeleteOneID(id string) *PaymentDeleteOne {
	builder := c.Delete().Where(payment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentDeleteOne{builder}
}

// Query returns a query builder for Payment.
func (c *PaymentClient) Query() *PaymentQuery {
	return &PaymentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePayment},
		inters: c.Interceptors(),
	}
}

// Get returns a Payment entity by its id.
func (c *PaymentClient) Get(ctx context.Context, id string) (*Payment, error) {
	return c.Query().Where(payment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentClient) GetX(ctx context.Context, id string) *Payment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PaymentClient) Hooks() []Hook {
	return c.hooks.Payment
}

// Interceptors returns the client interceptors.
func (c *PaymentClient) Interceptors() []Interceptor {
	return c.inters.Payment
}

func (c *PaymentClient) mutate(ctx context.Context, m *PaymentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PaymentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PaymentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Payment mutation op: %q", m.Op())
	}
}

// PlaceClient is a client for the Place schema.
type PlaceClient struct {
	config
}

// NewPlaceClient returns a client for the Place from the given config.
func NewPlaceClient(c config) *PlaceClient {
	return &PlaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `place.Hooks(f(g(h())))`.
func (c *PlaceClient) Use(hooks ...Hook) {
	c.hooks.Place = append(c.hooks.Place, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `place.Intercept(f(g(h())))`.
func (c *PlaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Place = append(c.inters.Place, interceptors...)
}

// Create returns a builder for creating a Place entity.
func (c *PlaceClient) Create() *PlaceCreate {
	mutation := newPlaceMutation(c.config, OpCreate)
	return &PlaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Place entities.
func (c *PlaceClient) CreateBulk(builders ...*PlaceCreate) *PlaceCreateBulk {
	return &PlaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Place.
func (c *PlaceClient) Update() *PlaceUpdate {
	mutation := newPlaceMutation(c.config, OpUpdate)
	return &PlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlaceClient) UpdateOne(pl *Place) *PlaceUpdateOne {
	mutation := newPlaceMutation(c.config, OpUpdateOne, withPlace(pl))
	return &PlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlaceClient) UpdateOneID(id string) *PlaceUpdateOne {
	mutation := newPlaceMutation(c.config, OpUpdateOne, withPlaceID(id))
	return &PlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Place.
func (c *PlaceClient) Delete() *PlaceDelete {
	mutation := newPlaceMutation(c.config, OpDelete)
	return &PlaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlaceClient) DeleteOne(pl *Place) *PlaceDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlaceClient) DeleteOneID(id string) *PlaceDeleteOne {
	builder := c.Delete().Where(place.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlaceDeleteOne{builder}
}

// Query returns a query builder for Place.
func (c *PlaceClient) Query() *PlaceQuery {
	return &PlaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlace},
		inters: c.Interceptors(),
	}
}

// Get returns a Place entity by its id.
func (c *PlaceClient) Get(ctx context.Context, id string) (*Place, error) {
	return c.Query().Where(place.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlaceClient) GetX(ctx context.Context, id string) *Place {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBusiness queries the business edge of a Place.
func (c *PlaceClient) QueryBusiness(pl *Place) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, place.BusinessTable, place.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Place.
func (c *PlaceClient) QueryUsers(pl *Place) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, place.UsersTable, place.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a Place.
func (c *PlaceClient) QueryReviews(pl *Place) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.ReviewsTable, place.ReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Place.
func (c *PlaceClient) QueryEvents(pl *Place) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.EventsTable, place.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAmenities queries the amenities edge of a Place.
func (c *PlaceClient) QueryAmenities(pl *Place) *AmenityQuery {
	query := (&AmenityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(amenity.Table, amenity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, place.AmenitiesTable, place.AmenitiesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenus queries the menus edge of a Place.
func (c *PlaceClient) QueryMenus(pl *Place) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.MenusTable, place.MenusColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRooms queries the rooms edge of a Place.
func (c *PlaceClient) QueryRooms(pl *Place) *RoomQuery {
	query := (&RoomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(room.Table, room.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.RoomsTable, place.RoomsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReservations queries the reservations edge of a Place.
func (c *PlaceClient) QueryReservations(pl *Place) *ReservationQuery {
	query := (&ReservationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(reservation.Table, reservation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.ReservationsTable, place.ReservationsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookings queries the bookings edge of a Place.
func (c *PlaceClient) QueryBookings(pl *Place) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.BookingsTable, place.BookingsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a Place.
func (c *PlaceClient) QueryCategories(pl *Place) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.CategoriesTable, place.CategoriesColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategoryAssignments queries the categoryAssignments edge of a Place.
func (c *PlaceClient) QueryCategoryAssignments(pl *Place) *CategoryAssignmentQuery {
	query := (&CategoryAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(categoryassignment.Table, categoryassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.CategoryAssignmentsTable, place.CategoryAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFaqs queries the faqs edge of a Place.
func (c *PlaceClient) QueryFaqs(pl *Place) *FAQQuery {
	query := (&FAQClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(faq.Table, faq.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, place.FaqsTable, place.FaqsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedByUsers queries the likedByUsers edge of a Place.
func (c *PlaceClient) QueryLikedByUsers(pl *Place) *UserLikePlaceQuery {
	query := (&UserLikePlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(userlikeplace.Table, userlikeplace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, place.LikedByUsersTable, place.LikedByUsersColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowerUsers queries the followerUsers edge of a Place.
func (c *PlaceClient) QueryFollowerUsers(pl *Place) *UserFollowPlaceQuery {
	query := (&UserFollowPlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(userfollowplace.Table, userfollowplace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.FollowerUsersTable, place.FollowerUsersColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRatings queries the ratings edge of a Place.
func (c *PlaceClient) QueryRatings(pl *Place) *RatingQuery {
	query := (&RatingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(rating.Table, rating.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.RatingsTable, place.RatingsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlaceClient) Hooks() []Hook {
	hooks := c.hooks.Place
	return append(hooks[:len(hooks):len(hooks)], place.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PlaceClient) Interceptors() []Interceptor {
	return c.inters.Place
}

func (c *PlaceClient) mutate(ctx context.Context, m *PlaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Place mutation op: %q", m.Op())
	}
}

// PostClient is a client for the Post schema.
type PostClient struct {
	config
}

// NewPostClient returns a client for the Post from the given config.
func NewPostClient(c config) *PostClient {
	return &PostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `post.Hooks(f(g(h())))`.
func (c *PostClient) Use(hooks ...Hook) {
	c.hooks.Post = append(c.hooks.Post, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `post.Intercept(f(g(h())))`.
func (c *PostClient) Intercept(interceptors ...Interceptor) {
	c.inters.Post = append(c.inters.Post, interceptors...)
}

// Create returns a builder for creating a Post entity.
func (c *PostClient) Create() *PostCreate {
	mutation := newPostMutation(c.config, OpCreate)
	return &PostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Post entities.
func (c *PostClient) CreateBulk(builders ...*PostCreate) *PostCreateBulk {
	return &PostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Post.
func (c *PostClient) Update() *PostUpdate {
	mutation := newPostMutation(c.config, OpUpdate)
	return &PostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostClient) UpdateOne(po *Post) *PostUpdateOne {
	mutation := newPostMutation(c.config, OpUpdateOne, withPost(po))
	return &PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostClient) UpdateOneID(id string) *PostUpdateOne {
	mutation := newPostMutation(c.config, OpUpdateOne, withPostID(id))
	return &PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Post.
func (c *PostClient) Delete() *PostDelete {
	mutation := newPostMutation(c.config, OpDelete)
	return &PostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostClient) DeleteOne(po *Post) *PostDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostClient) DeleteOneID(id string) *PostDeleteOne {
	builder := c.Delete().Where(post.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostDeleteOne{builder}
}

// Query returns a query builder for Post.
func (c *PostClient) Query() *PostQuery {
	return &PostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePost},
		inters: c.Interceptors(),
	}
}

// Get returns a Post entity by its id.
func (c *PostClient) Get(ctx context.Context, id string) (*Post, error) {
	return c.Query().Where(post.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostClient) GetX(ctx context.Context, id string) *Post {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Post.
func (c *PostClient) QueryUser(po *Post) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.UserTable, post.UserColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusinessAccount queries the business_account edge of a Post.
func (c *PostClient) QueryBusinessAccount(po *Post) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.BusinessAccountTable, post.BusinessAccountColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedias queries the medias edge of a Post.
func (c *PostClient) QueryMedias(po *Post) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.MediasTable, post.MediasColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Post.
func (c *PostClient) QueryComments(po *Post) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.CommentsTable, post.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikes queries the likes edge of a Post.
func (c *PostClient) QueryLikes(po *Post) *LikeQuery {
	query := (&LikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(like.Table, like.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.LikesTable, post.LikesColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a Post.
func (c *PostClient) QueryCategories(po *Post) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.CategoriesTable, post.CategoriesColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostClient) Hooks() []Hook {
	return c.hooks.Post
}

// Interceptors returns the client interceptors.
func (c *PostClient) Interceptors() []Interceptor {
	return c.inters.Post
}

func (c *PostClient) mutate(ctx context.Context, m *PostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Post mutation op: %q", m.Op())
	}
}

// RatingClient is a client for the Rating schema.
type RatingClient struct {
	config
}

// NewRatingClient returns a client for the Rating from the given config.
func NewRatingClient(c config) *RatingClient {
	return &RatingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rating.Hooks(f(g(h())))`.
func (c *RatingClient) Use(hooks ...Hook) {
	c.hooks.Rating = append(c.hooks.Rating, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rating.Intercept(f(g(h())))`.
func (c *RatingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Rating = append(c.inters.Rating, interceptors...)
}

// Create returns a builder for creating a Rating entity.
func (c *RatingClient) Create() *RatingCreate {
	mutation := newRatingMutation(c.config, OpCreate)
	return &RatingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Rating entities.
func (c *RatingClient) CreateBulk(builders ...*RatingCreate) *RatingCreateBulk {
	return &RatingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Rating.
func (c *RatingClient) Update() *RatingUpdate {
	mutation := newRatingMutation(c.config, OpUpdate)
	return &RatingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RatingClient) UpdateOne(r *Rating) *RatingUpdateOne {
	mutation := newRatingMutation(c.config, OpUpdateOne, withRating(r))
	return &RatingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RatingClient) UpdateOneID(id string) *RatingUpdateOne {
	mutation := newRatingMutation(c.config, OpUpdateOne, withRatingID(id))
	return &RatingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Rating.
func (c *RatingClient) Delete() *RatingDelete {
	mutation := newRatingMutation(c.config, OpDelete)
	return &RatingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RatingClient) DeleteOne(r *Rating) *RatingDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RatingClient) DeleteOneID(id string) *RatingDeleteOne {
	builder := c.Delete().Where(rating.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RatingDeleteOne{builder}
}

// Query returns a query builder for Rating.
func (c *RatingClient) Query() *RatingQuery {
	return &RatingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRating},
		inters: c.Interceptors(),
	}
}

// Get returns a Rating entity by its id.
func (c *RatingClient) Get(ctx context.Context, id string) (*Rating, error) {
	return c.Query().Where(rating.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RatingClient) GetX(ctx context.Context, id string) *Rating {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Rating.
func (c *RatingClient) QueryUser(r *Rating) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rating.Table, rating.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rating.UserTable, rating.UserColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a Rating.
func (c *RatingClient) QueryBusiness(r *Rating) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rating.Table, rating.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, rating.BusinessTable, rating.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a Rating.
func (c *RatingClient) QueryPlace(r *Rating) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rating.Table, rating.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, rating.PlaceTable, rating.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a Rating.
func (c *RatingClient) QueryEvent(r *Rating) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rating.Table, rating.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, rating.EventTable, rating.EventColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RatingClient) Hooks() []Hook {
	hooks := c.hooks.Rating
	return append(hooks[:len(hooks):len(hooks)], rating.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RatingClient) Interceptors() []Interceptor {
	return c.inters.Rating
}

func (c *RatingClient) mutate(ctx context.Context, m *RatingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RatingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RatingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RatingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RatingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Rating mutation op: %q", m.Op())
	}
}

// ReactionClient is a client for the Reaction schema.
type ReactionClient struct {
	config
}

// NewReactionClient returns a client for the Reaction from the given config.
func NewReactionClient(c config) *ReactionClient {
	return &ReactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reaction.Hooks(f(g(h())))`.
func (c *ReactionClient) Use(hooks ...Hook) {
	c.hooks.Reaction = append(c.hooks.Reaction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reaction.Intercept(f(g(h())))`.
func (c *ReactionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Reaction = append(c.inters.Reaction, interceptors...)
}

// Create returns a builder for creating a Reaction entity.
func (c *ReactionClient) Create() *ReactionCreate {
	mutation := newReactionMutation(c.config, OpCreate)
	return &ReactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reaction entities.
func (c *ReactionClient) CreateBulk(builders ...*ReactionCreate) *ReactionCreateBulk {
	return &ReactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reaction.
func (c *ReactionClient) Update() *ReactionUpdate {
	mutation := newReactionMutation(c.config, OpUpdate)
	return &ReactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReactionClient) UpdateOne(r *Reaction) *ReactionUpdateOne {
	mutation := newReactionMutation(c.config, OpUpdateOne, withReaction(r))
	return &ReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReactionClient) UpdateOneID(id string) *ReactionUpdateOne {
	mutation := newReactionMutation(c.config, OpUpdateOne, withReactionID(id))
	return &ReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reaction.
func (c *ReactionClient) Delete() *ReactionDelete {
	mutation := newReactionMutation(c.config, OpDelete)
	return &ReactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReactionClient) DeleteOne(r *Reaction) *ReactionDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReactionClient) DeleteOneID(id string) *ReactionDeleteOne {
	builder := c.Delete().Where(reaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReactionDeleteOne{builder}
}

// Query returns a query builder for Reaction.
func (c *ReactionClient) Query() *ReactionQuery {
	return &ReactionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReaction},
		inters: c.Interceptors(),
	}
}

// Get returns a Reaction entity by its id.
func (c *ReactionClient) Get(ctx context.Context, id string) (*Reaction, error) {
	return c.Query().Where(reaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReactionClient) GetX(ctx context.Context, id string) *Reaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ReactionClient) Hooks() []Hook {
	return c.hooks.Reaction
}

// Interceptors returns the client interceptors.
func (c *ReactionClient) Interceptors() []Interceptor {
	return c.inters.Reaction
}

func (c *ReactionClient) mutate(ctx context.Context, m *ReactionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReactionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReactionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReactionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Reaction mutation op: %q", m.Op())
	}
}

// ReservationClient is a client for the Reservation schema.
type ReservationClient struct {
	config
}

// NewReservationClient returns a client for the Reservation from the given config.
func NewReservationClient(c config) *ReservationClient {
	return &ReservationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reservation.Hooks(f(g(h())))`.
func (c *ReservationClient) Use(hooks ...Hook) {
	c.hooks.Reservation = append(c.hooks.Reservation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reservation.Intercept(f(g(h())))`.
func (c *ReservationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Reservation = append(c.inters.Reservation, interceptors...)
}

// Create returns a builder for creating a Reservation entity.
func (c *ReservationClient) Create() *ReservationCreate {
	mutation := newReservationMutation(c.config, OpCreate)
	return &ReservationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reservation entities.
func (c *ReservationClient) CreateBulk(builders ...*ReservationCreate) *ReservationCreateBulk {
	return &ReservationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reservation.
func (c *ReservationClient) Update() *ReservationUpdate {
	mutation := newReservationMutation(c.config, OpUpdate)
	return &ReservationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReservationClient) UpdateOne(r *Reservation) *ReservationUpdateOne {
	mutation := newReservationMutation(c.config, OpUpdateOne, withReservation(r))
	return &ReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReservationClient) UpdateOneID(id string) *ReservationUpdateOne {
	mutation := newReservationMutation(c.config, OpUpdateOne, withReservationID(id))
	return &ReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reservation.
func (c *ReservationClient) Delete() *ReservationDelete {
	mutation := newReservationMutation(c.config, OpDelete)
	return &ReservationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReservationClient) DeleteOne(r *Reservation) *ReservationDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReservationClient) DeleteOneID(id string) *ReservationDeleteOne {
	builder := c.Delete().Where(reservation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReservationDeleteOne{builder}
}

// Query returns a query builder for Reservation.
func (c *ReservationClient) Query() *ReservationQuery {
	return &ReservationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReservation},
		inters: c.Interceptors(),
	}
}

// Get returns a Reservation entity by its id.
func (c *ReservationClient) Get(ctx context.Context, id string) (*Reservation, error) {
	return c.Query().Where(reservation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReservationClient) GetX(ctx context.Context, id string) *Reservation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlace queries the place edge of a Reservation.
func (c *ReservationClient) QueryPlace(r *Reservation) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reservation.Table, reservation.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reservation.PlaceTable, reservation.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Reservation.
func (c *ReservationClient) QueryUser(r *Reservation) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reservation.Table, reservation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reservation.UserTable, reservation.UserColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReservationClient) Hooks() []Hook {
	return c.hooks.Reservation
}

// Interceptors returns the client interceptors.
func (c *ReservationClient) Interceptors() []Interceptor {
	return c.inters.Reservation
}

func (c *ReservationClient) mutate(ctx context.Context, m *ReservationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReservationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReservationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReservationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Reservation mutation op: %q", m.Op())
	}
}

// ResourseClient is a client for the Resourse schema.
type ResourseClient struct {
	config
}

// NewResourseClient returns a client for the Resourse from the given config.
func NewResourseClient(c config) *ResourseClient {
	return &ResourseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resourse.Hooks(f(g(h())))`.
func (c *ResourseClient) Use(hooks ...Hook) {
	c.hooks.Resourse = append(c.hooks.Resourse, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resourse.Intercept(f(g(h())))`.
func (c *ResourseClient) Intercept(interceptors ...Interceptor) {
	c.inters.Resourse = append(c.inters.Resourse, interceptors...)
}

// Create returns a builder for creating a Resourse entity.
func (c *ResourseClient) Create() *ResourseCreate {
	mutation := newResourseMutation(c.config, OpCreate)
	return &ResourseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Resourse entities.
func (c *ResourseClient) CreateBulk(builders ...*ResourseCreate) *ResourseCreateBulk {
	return &ResourseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Resourse.
func (c *ResourseClient) Update() *ResourseUpdate {
	mutation := newResourseMutation(c.config, OpUpdate)
	return &ResourseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourseClient) UpdateOne(r *Resourse) *ResourseUpdateOne {
	mutation := newResourseMutation(c.config, OpUpdateOne, withResourse(r))
	return &ResourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourseClient) UpdateOneID(id string) *ResourseUpdateOne {
	mutation := newResourseMutation(c.config, OpUpdateOne, withResourseID(id))
	return &ResourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Resourse.
func (c *ResourseClient) Delete() *ResourseDelete {
	mutation := newResourseMutation(c.config, OpDelete)
	return &ResourseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourseClient) DeleteOne(r *Resourse) *ResourseDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourseClient) DeleteOneID(id string) *ResourseDeleteOne {
	builder := c.Delete().Where(resourse.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourseDeleteOne{builder}
}

// Query returns a query builder for Resourse.
func (c *ResourseClient) Query() *ResourseQuery {
	return &ResourseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResourse},
		inters: c.Interceptors(),
	}
}

// Get returns a Resourse entity by its id.
func (c *ResourseClient) Get(ctx context.Context, id string) (*Resourse, error) {
	return c.Query().Where(resourse.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourseClient) GetX(ctx context.Context, id string) *Resourse {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ResourseClient) Hooks() []Hook {
	return c.hooks.Resourse
}

// Interceptors returns the client interceptors.
func (c *ResourseClient) Interceptors() []Interceptor {
	return c.inters.Resourse
}

func (c *ResourseClient) mutate(ctx context.Context, m *ResourseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Resourse mutation op: %q", m.Op())
	}
}

// ReviewClient is a client for the Review schema.
type ReviewClient struct {
	config
}

// NewReviewClient returns a client for the Review from the given config.
func NewReviewClient(c config) *ReviewClient {
	return &ReviewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `review.Hooks(f(g(h())))`.
func (c *ReviewClient) Use(hooks ...Hook) {
	c.hooks.Review = append(c.hooks.Review, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `review.Intercept(f(g(h())))`.
func (c *ReviewClient) Intercept(interceptors ...Interceptor) {
	c.inters.Review = append(c.inters.Review, interceptors...)
}

// Create returns a builder for creating a Review entity.
func (c *ReviewClient) Create() *ReviewCreate {
	mutation := newReviewMutation(c.config, OpCreate)
	return &ReviewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Review entities.
func (c *ReviewClient) CreateBulk(builders ...*ReviewCreate) *ReviewCreateBulk {
	return &ReviewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Review.
func (c *ReviewClient) Update() *ReviewUpdate {
	mutation := newReviewMutation(c.config, OpUpdate)
	return &ReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReviewClient) UpdateOne(r *Review) *ReviewUpdateOne {
	mutation := newReviewMutation(c.config, OpUpdateOne, withReview(r))
	return &ReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReviewClient) UpdateOneID(id string) *ReviewUpdateOne {
	mutation := newReviewMutation(c.config, OpUpdateOne, withReviewID(id))
	return &ReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Review.
func (c *ReviewClient) Delete() *ReviewDelete {
	mutation := newReviewMutation(c.config, OpDelete)
	return &ReviewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReviewClient) DeleteOne(r *Review) *ReviewDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReviewClient) DeleteOneID(id string) *ReviewDeleteOne {
	builder := c.Delete().Where(review.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReviewDeleteOne{builder}
}

// Query returns a query builder for Review.
func (c *ReviewClient) Query() *ReviewQuery {
	return &ReviewQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReview},
		inters: c.Interceptors(),
	}
}

// Get returns a Review entity by its id.
func (c *ReviewClient) Get(ctx context.Context, id string) (*Review, error) {
	return c.Query().Where(review.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReviewClient) GetX(ctx context.Context, id string) *Review {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Review.
func (c *ReviewClient) QueryUser(r *Review) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, review.UserTable, review.UserColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a Review.
func (c *ReviewClient) QueryBusiness(r *Review) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, review.BusinessTable, review.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a Review.
func (c *ReviewClient) QueryPlace(r *Review) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, review.PlaceTable, review.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a Review.
func (c *ReviewClient) QueryEvent(r *Review) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, review.EventTable, review.EventColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedias queries the medias edge of a Review.
func (c *ReviewClient) QueryMedias(r *Review) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.MediasTable, review.MediasColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Review.
func (c *ReviewClient) QueryComments(r *Review) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.CommentsTable, review.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikes queries the likes edge of a Review.
func (c *ReviewClient) QueryLikes(r *Review) *LikeQuery {
	query := (&LikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(like.Table, like.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.LikesTable, review.LikesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReviewClient) Hooks() []Hook {
	hooks := c.hooks.Review
	return append(hooks[:len(hooks):len(hooks)], review.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ReviewClient) Interceptors() []Interceptor {
	return c.inters.Review
}

func (c *ReviewClient) mutate(ctx context.Context, m *ReviewMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReviewCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReviewDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Review mutation op: %q", m.Op())
	}
}

// RoomClient is a client for the Room schema.
type RoomClient struct {
	config
}

// NewRoomClient returns a client for the Room from the given config.
func NewRoomClient(c config) *RoomClient {
	return &RoomClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `room.Hooks(f(g(h())))`.
func (c *RoomClient) Use(hooks ...Hook) {
	c.hooks.Room = append(c.hooks.Room, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `room.Intercept(f(g(h())))`.
func (c *RoomClient) Intercept(interceptors ...Interceptor) {
	c.inters.Room = append(c.inters.Room, interceptors...)
}

// Create returns a builder for creating a Room entity.
func (c *RoomClient) Create() *RoomCreate {
	mutation := newRoomMutation(c.config, OpCreate)
	return &RoomCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Room entities.
func (c *RoomClient) CreateBulk(builders ...*RoomCreate) *RoomCreateBulk {
	return &RoomCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Room.
func (c *RoomClient) Update() *RoomUpdate {
	mutation := newRoomMutation(c.config, OpUpdate)
	return &RoomUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoomClient) UpdateOne(r *Room) *RoomUpdateOne {
	mutation := newRoomMutation(c.config, OpUpdateOne, withRoom(r))
	return &RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoomClient) UpdateOneID(id string) *RoomUpdateOne {
	mutation := newRoomMutation(c.config, OpUpdateOne, withRoomID(id))
	return &RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Room.
func (c *RoomClient) Delete() *RoomDelete {
	mutation := newRoomMutation(c.config, OpDelete)
	return &RoomDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoomClient) DeleteOne(r *Room) *RoomDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoomClient) DeleteOneID(id string) *RoomDeleteOne {
	builder := c.Delete().Where(room.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoomDeleteOne{builder}
}

// Query returns a query builder for Room.
func (c *RoomClient) Query() *RoomQuery {
	return &RoomQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRoom},
		inters: c.Interceptors(),
	}
}

// Get returns a Room entity by its id.
func (c *RoomClient) Get(ctx context.Context, id string) (*Room, error) {
	return c.Query().Where(room.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoomClient) GetX(ctx context.Context, id string) *Room {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlace queries the place edge of a Room.
func (c *RoomClient) QueryPlace(r *Room) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(room.Table, room.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, room.PlaceTable, room.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookings queries the bookings edge of a Room.
func (c *RoomClient) QueryBookings(r *Room) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(room.Table, room.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, room.BookingsTable, room.BookingsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoomClient) Hooks() []Hook {
	return c.hooks.Room
}

// Interceptors returns the client interceptors.
func (c *RoomClient) Interceptors() []Interceptor {
	return c.inters.Room
}

func (c *RoomClient) mutate(ctx context.Context, m *RoomMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoomCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoomUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoomDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Room mutation op: %q", m.Op())
	}
}

// TicketClient is a client for the Ticket schema.
type TicketClient struct {
	config
}

// NewTicketClient returns a client for the Ticket from the given config.
func NewTicketClient(c config) *TicketClient {
	return &TicketClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ticket.Hooks(f(g(h())))`.
func (c *TicketClient) Use(hooks ...Hook) {
	c.hooks.Ticket = append(c.hooks.Ticket, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ticket.Intercept(f(g(h())))`.
func (c *TicketClient) Intercept(interceptors ...Interceptor) {
	c.inters.Ticket = append(c.inters.Ticket, interceptors...)
}

// Create returns a builder for creating a Ticket entity.
func (c *TicketClient) Create() *TicketCreate {
	mutation := newTicketMutation(c.config, OpCreate)
	return &TicketCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ticket entities.
func (c *TicketClient) CreateBulk(builders ...*TicketCreate) *TicketCreateBulk {
	return &TicketCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ticket.
func (c *TicketClient) Update() *TicketUpdate {
	mutation := newTicketMutation(c.config, OpUpdate)
	return &TicketUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TicketClient) UpdateOne(t *Ticket) *TicketUpdateOne {
	mutation := newTicketMutation(c.config, OpUpdateOne, withTicket(t))
	return &TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TicketClient) UpdateOneID(id string) *TicketUpdateOne {
	mutation := newTicketMutation(c.config, OpUpdateOne, withTicketID(id))
	return &TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ticket.
func (c *TicketClient) Delete() *TicketDelete {
	mutation := newTicketMutation(c.config, OpDelete)
	return &TicketDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TicketClient) DeleteOne(t *Ticket) *TicketDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TicketClient) DeleteOneID(id string) *TicketDeleteOne {
	builder := c.Delete().Where(ticket.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TicketDeleteOne{builder}
}

// Query returns a query builder for Ticket.
func (c *TicketClient) Query() *TicketQuery {
	return &TicketQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTicket},
		inters: c.Interceptors(),
	}
}

// Get returns a Ticket entity by its id.
func (c *TicketClient) Get(ctx context.Context, id string) (*Ticket, error) {
	return c.Query().Where(ticket.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TicketClient) GetX(ctx context.Context, id string) *Ticket {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a Ticket.
func (c *TicketClient) QueryEvent(t *Ticket) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticket.EventTable, ticket.EventColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTicketOptions queries the ticket_options edge of a Ticket.
func (c *TicketClient) QueryTicketOptions(t *Ticket) *TicketOptionQuery {
	query := (&TicketOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(ticketoption.Table, ticketoption.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ticket.TicketOptionsTable, ticket.TicketOptionsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TicketClient) Hooks() []Hook {
	return c.hooks.Ticket
}

// Interceptors returns the client interceptors.
func (c *TicketClient) Interceptors() []Interceptor {
	return c.inters.Ticket
}

func (c *TicketClient) mutate(ctx context.Context, m *TicketMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TicketCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TicketUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TicketDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Ticket mutation op: %q", m.Op())
	}
}

// TicketOptionClient is a client for the TicketOption schema.
type TicketOptionClient struct {
	config
}

// NewTicketOptionClient returns a client for the TicketOption from the given config.
func NewTicketOptionClient(c config) *TicketOptionClient {
	return &TicketOptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ticketoption.Hooks(f(g(h())))`.
func (c *TicketOptionClient) Use(hooks ...Hook) {
	c.hooks.TicketOption = append(c.hooks.TicketOption, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ticketoption.Intercept(f(g(h())))`.
func (c *TicketOptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.TicketOption = append(c.inters.TicketOption, interceptors...)
}

// Create returns a builder for creating a TicketOption entity.
func (c *TicketOptionClient) Create() *TicketOptionCreate {
	mutation := newTicketOptionMutation(c.config, OpCreate)
	return &TicketOptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TicketOption entities.
func (c *TicketOptionClient) CreateBulk(builders ...*TicketOptionCreate) *TicketOptionCreateBulk {
	return &TicketOptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TicketOption.
func (c *TicketOptionClient) Update() *TicketOptionUpdate {
	mutation := newTicketOptionMutation(c.config, OpUpdate)
	return &TicketOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TicketOptionClient) UpdateOne(to *TicketOption) *TicketOptionUpdateOne {
	mutation := newTicketOptionMutation(c.config, OpUpdateOne, withTicketOption(to))
	return &TicketOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TicketOptionClient) UpdateOneID(id string) *TicketOptionUpdateOne {
	mutation := newTicketOptionMutation(c.config, OpUpdateOne, withTicketOptionID(id))
	return &TicketOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TicketOption.
func (c *TicketOptionClient) Delete() *TicketOptionDelete {
	mutation := newTicketOptionMutation(c.config, OpDelete)
	return &TicketOptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TicketOptionClient) DeleteOne(to *TicketOption) *TicketOptionDeleteOne {
	return c.DeleteOneID(to.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TicketOptionClient) DeleteOneID(id string) *TicketOptionDeleteOne {
	builder := c.Delete().Where(ticketoption.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TicketOptionDeleteOne{builder}
}

// Query returns a query builder for TicketOption.
func (c *TicketOptionClient) Query() *TicketOptionQuery {
	return &TicketOptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTicketOption},
		inters: c.Interceptors(),
	}
}

// Get returns a TicketOption entity by its id.
func (c *TicketOptionClient) Get(ctx context.Context, id string) (*TicketOption, error) {
	return c.Query().Where(ticketoption.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TicketOptionClient) GetX(ctx context.Context, id string) *TicketOption {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a TicketOption.
func (c *TicketOptionClient) QueryEvent(to *TicketOption) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := to.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticketoption.Table, ticketoption.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticketoption.EventTable, ticketoption.EventColumn),
		)
		fromV = sqlgraph.Neighbors(to.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TicketOptionClient) Hooks() []Hook {
	return c.hooks.TicketOption
}

// Interceptors returns the client interceptors.
func (c *TicketOptionClient) Interceptors() []Interceptor {
	return c.inters.TicketOption
}

func (c *TicketOptionClient) mutate(ctx context.Context, m *TicketOptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TicketOptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TicketOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TicketOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TicketOptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TicketOption mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserBusinesses queries the userBusinesses edge of a User.
func (c *UserClient) QueryUserBusinesses(u *User) *UserBusinessQuery {
	query := (&UserBusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userbusiness.Table, userbusiness.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserBusinessesTable, user.UserBusinessesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a User.
func (c *UserClient) QueryComments(u *User) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CommentsTable, user.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikes queries the likes edge of a User.
func (c *UserClient) QueryLikes(u *User) *LikeQuery {
	query := (&LikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(like.Table, like.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LikesTable, user.LikesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPosts queries the posts edge of a User.
func (c *UserClient) QueryPosts(u *User) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PostsTable, user.PostsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowedUsers queries the followedUsers edge of a User.
func (c *UserClient) QueryFollowedUsers(u *User) *UserFollowUserQuery {
	query := (&UserFollowUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userfollowuser.Table, userfollowuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FollowedUsersTable, user.FollowedUsersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowerUsers queries the followerUsers edge of a User.
func (c *UserClient) QueryFollowerUsers(u *User) *UserFollowUserQuery {
	query := (&UserFollowUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userfollowuser.Table, userfollowuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FollowerUsersTable, user.FollowerUsersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowedBusinesses queries the followedBusinesses edge of a User.
func (c *UserClient) QueryFollowedBusinesses(u *User) *UserFollowBusinessQuery {
	query := (&UserFollowBusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userfollowbusiness.Table, userfollowbusiness.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FollowedBusinessesTable, user.FollowedBusinessesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowerBusinesses queries the followerBusinesses edge of a User.
func (c *UserClient) QueryFollowerBusinesses(u *User) *BusinessFollowUserQuery {
	query := (&BusinessFollowUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(businessfollowuser.Table, businessfollowuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FollowerBusinessesTable, user.FollowerBusinessesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a User.
func (c *UserClient) QueryReviews(u *User) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReviewsTable, user.ReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookings queries the bookings edge of a User.
func (c *UserClient) QueryBookings(u *User) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BookingsTable, user.BookingsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReservations queries the reservations edge of a User.
func (c *UserClient) QueryReservations(u *User) *ReservationQuery {
	query := (&ReservationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(reservation.Table, reservation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReservationsTable, user.ReservationsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHelps queries the helps edge of a User.
func (c *UserClient) QueryHelps(u *User) *HelpQuery {
	query := (&HelpClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(help.Table, help.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.HelpsTable, user.HelpsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a User.
func (c *UserClient) QueryCategories(u *User) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CategoriesTable, user.CategoriesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaces queries the places edge of a User.
func (c *UserClient) QueryPlaces(u *User) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.PlacesTable, user.PlacesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategoryAssignments queries the categoryAssignments edge of a User.
func (c *UserClient) QueryCategoryAssignments(u *User) *CategoryAssignmentQuery {
	query := (&CategoryAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(categoryassignment.Table, categoryassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CategoryAssignmentsTable, user.CategoryAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnedEvents queries the ownedEvents edge of a User.
func (c *UserClient) QueryOwnedEvents(u *User) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.OwnedEventsTable, user.OwnedEventsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserFollowEvents queries the userFollowEvents edge of a User.
func (c *UserClient) QueryUserFollowEvents(u *User) *UserFollowEventQuery {
	query := (&UserFollowEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userfollowevent.Table, userfollowevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserFollowEventsTable, user.UserFollowEventsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowedPlaces queries the followedPlaces edge of a User.
func (c *UserClient) QueryFollowedPlaces(u *User) *UserFollowPlaceQuery {
	query := (&UserFollowPlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userfollowplace.Table, userfollowplace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FollowedPlacesTable, user.FollowedPlacesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedPlaces queries the likedPlaces edge of a User.
func (c *UserClient) QueryLikedPlaces(u *User) *UserLikePlaceQuery {
	query := (&UserLikePlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userlikeplace.Table, userlikeplace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LikedPlacesTable, user.LikedPlacesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRatings queries the ratings edge of a User.
func (c *UserClient) QueryRatings(u *User) *RatingQuery {
	query := (&RatingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(rating.Table, rating.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.RatingsTable, user.RatingsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserBusinessClient is a client for the UserBusiness schema.
type UserBusinessClient struct {
	config
}

// NewUserBusinessClient returns a client for the UserBusiness from the given config.
func NewUserBusinessClient(c config) *UserBusinessClient {
	return &UserBusinessClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userbusiness.Hooks(f(g(h())))`.
func (c *UserBusinessClient) Use(hooks ...Hook) {
	c.hooks.UserBusiness = append(c.hooks.UserBusiness, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userbusiness.Intercept(f(g(h())))`.
func (c *UserBusinessClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserBusiness = append(c.inters.UserBusiness, interceptors...)
}

// Create returns a builder for creating a UserBusiness entity.
func (c *UserBusinessClient) Create() *UserBusinessCreate {
	mutation := newUserBusinessMutation(c.config, OpCreate)
	return &UserBusinessCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserBusiness entities.
func (c *UserBusinessClient) CreateBulk(builders ...*UserBusinessCreate) *UserBusinessCreateBulk {
	return &UserBusinessCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserBusiness.
func (c *UserBusinessClient) Update() *UserBusinessUpdate {
	mutation := newUserBusinessMutation(c.config, OpUpdate)
	return &UserBusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserBusinessClient) UpdateOne(ub *UserBusiness) *UserBusinessUpdateOne {
	mutation := newUserBusinessMutation(c.config, OpUpdateOne, withUserBusiness(ub))
	return &UserBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserBusinessClient) UpdateOneID(id string) *UserBusinessUpdateOne {
	mutation := newUserBusinessMutation(c.config, OpUpdateOne, withUserBusinessID(id))
	return &UserBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserBusiness.
func (c *UserBusinessClient) Delete() *UserBusinessDelete {
	mutation := newUserBusinessMutation(c.config, OpDelete)
	return &UserBusinessDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserBusinessClient) DeleteOne(ub *UserBusiness) *UserBusinessDeleteOne {
	return c.DeleteOneID(ub.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserBusinessClient) DeleteOneID(id string) *UserBusinessDeleteOne {
	builder := c.Delete().Where(userbusiness.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserBusinessDeleteOne{builder}
}

// Query returns a query builder for UserBusiness.
func (c *UserBusinessClient) Query() *UserBusinessQuery {
	return &UserBusinessQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserBusiness},
		inters: c.Interceptors(),
	}
}

// Get returns a UserBusiness entity by its id.
func (c *UserBusinessClient) Get(ctx context.Context, id string) (*UserBusiness, error) {
	return c.Query().Where(userbusiness.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserBusinessClient) GetX(ctx context.Context, id string) *UserBusiness {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserBusiness.
func (c *UserBusinessClient) QueryUser(ub *UserBusiness) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ub.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userbusiness.Table, userbusiness.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userbusiness.UserTable, userbusiness.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ub.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a UserBusiness.
func (c *UserBusinessClient) QueryBusiness(ub *UserBusiness) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ub.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userbusiness.Table, userbusiness.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userbusiness.BusinessTable, userbusiness.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(ub.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserBusinessClient) Hooks() []Hook {
	return c.hooks.UserBusiness
}

// Interceptors returns the client interceptors.
func (c *UserBusinessClient) Interceptors() []Interceptor {
	return c.inters.UserBusiness
}

func (c *UserBusinessClient) mutate(ctx context.Context, m *UserBusinessMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserBusinessCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserBusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserBusinessDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserBusiness mutation op: %q", m.Op())
	}
}

// UserFollowBusinessClient is a client for the UserFollowBusiness schema.
type UserFollowBusinessClient struct {
	config
}

// NewUserFollowBusinessClient returns a client for the UserFollowBusiness from the given config.
func NewUserFollowBusinessClient(c config) *UserFollowBusinessClient {
	return &UserFollowBusinessClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userfollowbusiness.Hooks(f(g(h())))`.
func (c *UserFollowBusinessClient) Use(hooks ...Hook) {
	c.hooks.UserFollowBusiness = append(c.hooks.UserFollowBusiness, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userfollowbusiness.Intercept(f(g(h())))`.
func (c *UserFollowBusinessClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserFollowBusiness = append(c.inters.UserFollowBusiness, interceptors...)
}

// Create returns a builder for creating a UserFollowBusiness entity.
func (c *UserFollowBusinessClient) Create() *UserFollowBusinessCreate {
	mutation := newUserFollowBusinessMutation(c.config, OpCreate)
	return &UserFollowBusinessCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserFollowBusiness entities.
func (c *UserFollowBusinessClient) CreateBulk(builders ...*UserFollowBusinessCreate) *UserFollowBusinessCreateBulk {
	return &UserFollowBusinessCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserFollowBusiness.
func (c *UserFollowBusinessClient) Update() *UserFollowBusinessUpdate {
	mutation := newUserFollowBusinessMutation(c.config, OpUpdate)
	return &UserFollowBusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserFollowBusinessClient) UpdateOne(ufb *UserFollowBusiness) *UserFollowBusinessUpdateOne {
	mutation := newUserFollowBusinessMutation(c.config, OpUpdateOne, withUserFollowBusiness(ufb))
	return &UserFollowBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserFollowBusinessClient) UpdateOneID(id string) *UserFollowBusinessUpdateOne {
	mutation := newUserFollowBusinessMutation(c.config, OpUpdateOne, withUserFollowBusinessID(id))
	return &UserFollowBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserFollowBusiness.
func (c *UserFollowBusinessClient) Delete() *UserFollowBusinessDelete {
	mutation := newUserFollowBusinessMutation(c.config, OpDelete)
	return &UserFollowBusinessDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserFollowBusinessClient) DeleteOne(ufb *UserFollowBusiness) *UserFollowBusinessDeleteOne {
	return c.DeleteOneID(ufb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserFollowBusinessClient) DeleteOneID(id string) *UserFollowBusinessDeleteOne {
	builder := c.Delete().Where(userfollowbusiness.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserFollowBusinessDeleteOne{builder}
}

// Query returns a query builder for UserFollowBusiness.
func (c *UserFollowBusinessClient) Query() *UserFollowBusinessQuery {
	return &UserFollowBusinessQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserFollowBusiness},
		inters: c.Interceptors(),
	}
}

// Get returns a UserFollowBusiness entity by its id.
func (c *UserFollowBusinessClient) Get(ctx context.Context, id string) (*UserFollowBusiness, error) {
	return c.Query().Where(userfollowbusiness.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserFollowBusinessClient) GetX(ctx context.Context, id string) *UserFollowBusiness {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserFollowBusiness.
func (c *UserFollowBusinessClient) QueryUser(ufb *UserFollowBusiness) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowbusiness.Table, userfollowbusiness.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userfollowbusiness.UserTable, userfollowbusiness.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ufb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBusiness queries the business edge of a UserFollowBusiness.
func (c *UserFollowBusinessClient) QueryBusiness(ufb *UserFollowBusiness) *BusinessQuery {
	query := (&BusinessClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowbusiness.Table, userfollowbusiness.FieldID, id),
			sqlgraph.To(business.Table, business.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userfollowbusiness.BusinessTable, userfollowbusiness.BusinessColumn),
		)
		fromV = sqlgraph.Neighbors(ufb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserFollowBusinessClient) Hooks() []Hook {
	return c.hooks.UserFollowBusiness
}

// Interceptors returns the client interceptors.
func (c *UserFollowBusinessClient) Interceptors() []Interceptor {
	return c.inters.UserFollowBusiness
}

func (c *UserFollowBusinessClient) mutate(ctx context.Context, m *UserFollowBusinessMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserFollowBusinessCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserFollowBusinessUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserFollowBusinessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserFollowBusinessDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserFollowBusiness mutation op: %q", m.Op())
	}
}

// UserFollowEventClient is a client for the UserFollowEvent schema.
type UserFollowEventClient struct {
	config
}

// NewUserFollowEventClient returns a client for the UserFollowEvent from the given config.
func NewUserFollowEventClient(c config) *UserFollowEventClient {
	return &UserFollowEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userfollowevent.Hooks(f(g(h())))`.
func (c *UserFollowEventClient) Use(hooks ...Hook) {
	c.hooks.UserFollowEvent = append(c.hooks.UserFollowEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userfollowevent.Intercept(f(g(h())))`.
func (c *UserFollowEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserFollowEvent = append(c.inters.UserFollowEvent, interceptors...)
}

// Create returns a builder for creating a UserFollowEvent entity.
func (c *UserFollowEventClient) Create() *UserFollowEventCreate {
	mutation := newUserFollowEventMutation(c.config, OpCreate)
	return &UserFollowEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserFollowEvent entities.
func (c *UserFollowEventClient) CreateBulk(builders ...*UserFollowEventCreate) *UserFollowEventCreateBulk {
	return &UserFollowEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserFollowEvent.
func (c *UserFollowEventClient) Update() *UserFollowEventUpdate {
	mutation := newUserFollowEventMutation(c.config, OpUpdate)
	return &UserFollowEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserFollowEventClient) UpdateOne(ufe *UserFollowEvent) *UserFollowEventUpdateOne {
	mutation := newUserFollowEventMutation(c.config, OpUpdateOne, withUserFollowEvent(ufe))
	return &UserFollowEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserFollowEventClient) UpdateOneID(id string) *UserFollowEventUpdateOne {
	mutation := newUserFollowEventMutation(c.config, OpUpdateOne, withUserFollowEventID(id))
	return &UserFollowEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserFollowEvent.
func (c *UserFollowEventClient) Delete() *UserFollowEventDelete {
	mutation := newUserFollowEventMutation(c.config, OpDelete)
	return &UserFollowEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserFollowEventClient) DeleteOne(ufe *UserFollowEvent) *UserFollowEventDeleteOne {
	return c.DeleteOneID(ufe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserFollowEventClient) DeleteOneID(id string) *UserFollowEventDeleteOne {
	builder := c.Delete().Where(userfollowevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserFollowEventDeleteOne{builder}
}

// Query returns a query builder for UserFollowEvent.
func (c *UserFollowEventClient) Query() *UserFollowEventQuery {
	return &UserFollowEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserFollowEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a UserFollowEvent entity by its id.
func (c *UserFollowEventClient) Get(ctx context.Context, id string) (*UserFollowEvent, error) {
	return c.Query().Where(userfollowevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserFollowEventClient) GetX(ctx context.Context, id string) *UserFollowEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserFollowEvent.
func (c *UserFollowEventClient) QueryUser(ufe *UserFollowEvent) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowevent.Table, userfollowevent.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userfollowevent.UserTable, userfollowevent.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ufe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a UserFollowEvent.
func (c *UserFollowEventClient) QueryEvent(ufe *UserFollowEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowevent.Table, userfollowevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userfollowevent.EventTable, userfollowevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(ufe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserFollowEventClient) Hooks() []Hook {
	return c.hooks.UserFollowEvent
}

// Interceptors returns the client interceptors.
func (c *UserFollowEventClient) Interceptors() []Interceptor {
	return c.inters.UserFollowEvent
}

func (c *UserFollowEventClient) mutate(ctx context.Context, m *UserFollowEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserFollowEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserFollowEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserFollowEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserFollowEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserFollowEvent mutation op: %q", m.Op())
	}
}

// UserFollowPlaceClient is a client for the UserFollowPlace schema.
type UserFollowPlaceClient struct {
	config
}

// NewUserFollowPlaceClient returns a client for the UserFollowPlace from the given config.
func NewUserFollowPlaceClient(c config) *UserFollowPlaceClient {
	return &UserFollowPlaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userfollowplace.Hooks(f(g(h())))`.
func (c *UserFollowPlaceClient) Use(hooks ...Hook) {
	c.hooks.UserFollowPlace = append(c.hooks.UserFollowPlace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userfollowplace.Intercept(f(g(h())))`.
func (c *UserFollowPlaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserFollowPlace = append(c.inters.UserFollowPlace, interceptors...)
}

// Create returns a builder for creating a UserFollowPlace entity.
func (c *UserFollowPlaceClient) Create() *UserFollowPlaceCreate {
	mutation := newUserFollowPlaceMutation(c.config, OpCreate)
	return &UserFollowPlaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserFollowPlace entities.
func (c *UserFollowPlaceClient) CreateBulk(builders ...*UserFollowPlaceCreate) *UserFollowPlaceCreateBulk {
	return &UserFollowPlaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserFollowPlace.
func (c *UserFollowPlaceClient) Update() *UserFollowPlaceUpdate {
	mutation := newUserFollowPlaceMutation(c.config, OpUpdate)
	return &UserFollowPlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserFollowPlaceClient) UpdateOne(ufp *UserFollowPlace) *UserFollowPlaceUpdateOne {
	mutation := newUserFollowPlaceMutation(c.config, OpUpdateOne, withUserFollowPlace(ufp))
	return &UserFollowPlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserFollowPlaceClient) UpdateOneID(id string) *UserFollowPlaceUpdateOne {
	mutation := newUserFollowPlaceMutation(c.config, OpUpdateOne, withUserFollowPlaceID(id))
	return &UserFollowPlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserFollowPlace.
func (c *UserFollowPlaceClient) Delete() *UserFollowPlaceDelete {
	mutation := newUserFollowPlaceMutation(c.config, OpDelete)
	return &UserFollowPlaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserFollowPlaceClient) DeleteOne(ufp *UserFollowPlace) *UserFollowPlaceDeleteOne {
	return c.DeleteOneID(ufp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserFollowPlaceClient) DeleteOneID(id string) *UserFollowPlaceDeleteOne {
	builder := c.Delete().Where(userfollowplace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserFollowPlaceDeleteOne{builder}
}

// Query returns a query builder for UserFollowPlace.
func (c *UserFollowPlaceClient) Query() *UserFollowPlaceQuery {
	return &UserFollowPlaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserFollowPlace},
		inters: c.Interceptors(),
	}
}

// Get returns a UserFollowPlace entity by its id.
func (c *UserFollowPlaceClient) Get(ctx context.Context, id string) (*UserFollowPlace, error) {
	return c.Query().Where(userfollowplace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserFollowPlaceClient) GetX(ctx context.Context, id string) *UserFollowPlace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserFollowPlace.
func (c *UserFollowPlaceClient) QueryUser(ufp *UserFollowPlace) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowplace.Table, userfollowplace.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userfollowplace.UserTable, userfollowplace.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ufp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a UserFollowPlace.
func (c *UserFollowPlaceClient) QueryPlace(ufp *UserFollowPlace) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowplace.Table, userfollowplace.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userfollowplace.PlaceTable, userfollowplace.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(ufp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserFollowPlaceClient) Hooks() []Hook {
	return c.hooks.UserFollowPlace
}

// Interceptors returns the client interceptors.
func (c *UserFollowPlaceClient) Interceptors() []Interceptor {
	return c.inters.UserFollowPlace
}

func (c *UserFollowPlaceClient) mutate(ctx context.Context, m *UserFollowPlaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserFollowPlaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserFollowPlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserFollowPlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserFollowPlaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserFollowPlace mutation op: %q", m.Op())
	}
}

// UserFollowUserClient is a client for the UserFollowUser schema.
type UserFollowUserClient struct {
	config
}

// NewUserFollowUserClient returns a client for the UserFollowUser from the given config.
func NewUserFollowUserClient(c config) *UserFollowUserClient {
	return &UserFollowUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userfollowuser.Hooks(f(g(h())))`.
func (c *UserFollowUserClient) Use(hooks ...Hook) {
	c.hooks.UserFollowUser = append(c.hooks.UserFollowUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userfollowuser.Intercept(f(g(h())))`.
func (c *UserFollowUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserFollowUser = append(c.inters.UserFollowUser, interceptors...)
}

// Create returns a builder for creating a UserFollowUser entity.
func (c *UserFollowUserClient) Create() *UserFollowUserCreate {
	mutation := newUserFollowUserMutation(c.config, OpCreate)
	return &UserFollowUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserFollowUser entities.
func (c *UserFollowUserClient) CreateBulk(builders ...*UserFollowUserCreate) *UserFollowUserCreateBulk {
	return &UserFollowUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserFollowUser.
func (c *UserFollowUserClient) Update() *UserFollowUserUpdate {
	mutation := newUserFollowUserMutation(c.config, OpUpdate)
	return &UserFollowUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserFollowUserClient) UpdateOne(ufu *UserFollowUser) *UserFollowUserUpdateOne {
	mutation := newUserFollowUserMutation(c.config, OpUpdateOne, withUserFollowUser(ufu))
	return &UserFollowUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserFollowUserClient) UpdateOneID(id string) *UserFollowUserUpdateOne {
	mutation := newUserFollowUserMutation(c.config, OpUpdateOne, withUserFollowUserID(id))
	return &UserFollowUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserFollowUser.
func (c *UserFollowUserClient) Delete() *UserFollowUserDelete {
	mutation := newUserFollowUserMutation(c.config, OpDelete)
	return &UserFollowUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserFollowUserClient) DeleteOne(ufu *UserFollowUser) *UserFollowUserDeleteOne {
	return c.DeleteOneID(ufu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserFollowUserClient) DeleteOneID(id string) *UserFollowUserDeleteOne {
	builder := c.Delete().Where(userfollowuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserFollowUserDeleteOne{builder}
}

// Query returns a query builder for UserFollowUser.
func (c *UserFollowUserClient) Query() *UserFollowUserQuery {
	return &UserFollowUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserFollowUser},
		inters: c.Interceptors(),
	}
}

// Get returns a UserFollowUser entity by its id.
func (c *UserFollowUserClient) Get(ctx context.Context, id string) (*UserFollowUser, error) {
	return c.Query().Where(userfollowuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserFollowUserClient) GetX(ctx context.Context, id string) *UserFollowUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFollower queries the follower edge of a UserFollowUser.
func (c *UserFollowUserClient) QueryFollower(ufu *UserFollowUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowuser.Table, userfollowuser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userfollowuser.FollowerTable, userfollowuser.FollowerColumn),
		)
		fromV = sqlgraph.Neighbors(ufu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowed queries the followed edge of a UserFollowUser.
func (c *UserFollowUserClient) QueryFollowed(ufu *UserFollowUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userfollowuser.Table, userfollowuser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userfollowuser.FollowedTable, userfollowuser.FollowedColumn),
		)
		fromV = sqlgraph.Neighbors(ufu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserFollowUserClient) Hooks() []Hook {
	return c.hooks.UserFollowUser
}

// Interceptors returns the client interceptors.
func (c *UserFollowUserClient) Interceptors() []Interceptor {
	return c.inters.UserFollowUser
}

func (c *UserFollowUserClient) mutate(ctx context.Context, m *UserFollowUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserFollowUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserFollowUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserFollowUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserFollowUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserFollowUser mutation op: %q", m.Op())
	}
}

// UserLikePlaceClient is a client for the UserLikePlace schema.
type UserLikePlaceClient struct {
	config
}

// NewUserLikePlaceClient returns a client for the UserLikePlace from the given config.
func NewUserLikePlaceClient(c config) *UserLikePlaceClient {
	return &UserLikePlaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userlikeplace.Hooks(f(g(h())))`.
func (c *UserLikePlaceClient) Use(hooks ...Hook) {
	c.hooks.UserLikePlace = append(c.hooks.UserLikePlace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userlikeplace.Intercept(f(g(h())))`.
func (c *UserLikePlaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserLikePlace = append(c.inters.UserLikePlace, interceptors...)
}

// Create returns a builder for creating a UserLikePlace entity.
func (c *UserLikePlaceClient) Create() *UserLikePlaceCreate {
	mutation := newUserLikePlaceMutation(c.config, OpCreate)
	return &UserLikePlaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserLikePlace entities.
func (c *UserLikePlaceClient) CreateBulk(builders ...*UserLikePlaceCreate) *UserLikePlaceCreateBulk {
	return &UserLikePlaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserLikePlace.
func (c *UserLikePlaceClient) Update() *UserLikePlaceUpdate {
	mutation := newUserLikePlaceMutation(c.config, OpUpdate)
	return &UserLikePlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserLikePlaceClient) UpdateOne(ulp *UserLikePlace) *UserLikePlaceUpdateOne {
	mutation := newUserLikePlaceMutation(c.config, OpUpdateOne, withUserLikePlace(ulp))
	return &UserLikePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserLikePlaceClient) UpdateOneID(id string) *UserLikePlaceUpdateOne {
	mutation := newUserLikePlaceMutation(c.config, OpUpdateOne, withUserLikePlaceID(id))
	return &UserLikePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserLikePlace.
func (c *UserLikePlaceClient) Delete() *UserLikePlaceDelete {
	mutation := newUserLikePlaceMutation(c.config, OpDelete)
	return &UserLikePlaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserLikePlaceClient) DeleteOne(ulp *UserLikePlace) *UserLikePlaceDeleteOne {
	return c.DeleteOneID(ulp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserLikePlaceClient) DeleteOneID(id string) *UserLikePlaceDeleteOne {
	builder := c.Delete().Where(userlikeplace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserLikePlaceDeleteOne{builder}
}

// Query returns a query builder for UserLikePlace.
func (c *UserLikePlaceClient) Query() *UserLikePlaceQuery {
	return &UserLikePlaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserLikePlace},
		inters: c.Interceptors(),
	}
}

// Get returns a UserLikePlace entity by its id.
func (c *UserLikePlaceClient) Get(ctx context.Context, id string) (*UserLikePlace, error) {
	return c.Query().Where(userlikeplace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserLikePlaceClient) GetX(ctx context.Context, id string) *UserLikePlace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserLikePlace.
func (c *UserLikePlaceClient) QueryUser(ulp *UserLikePlace) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ulp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userlikeplace.Table, userlikeplace.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userlikeplace.UserTable, userlikeplace.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ulp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlace queries the place edge of a UserLikePlace.
func (c *UserLikePlaceClient) QueryPlace(ulp *UserLikePlace) *PlaceQuery {
	query := (&PlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ulp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userlikeplace.Table, userlikeplace.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userlikeplace.PlaceTable, userlikeplace.PlaceColumn),
		)
		fromV = sqlgraph.Neighbors(ulp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserLikePlaceClient) Hooks() []Hook {
	return c.hooks.UserLikePlace
}

// Interceptors returns the client interceptors.
func (c *UserLikePlaceClient) Interceptors() []Interceptor {
	return c.inters.UserLikePlace
}

func (c *UserLikePlaceClient) mutate(ctx context.Context, m *UserLikePlaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserLikePlaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserLikePlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserLikePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserLikePlaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserLikePlace mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AccountSettings, Amenity, Booking, Business, BusinessFollowBusiness,
		BusinessFollowEvent, BusinessFollowUser, Category, CategoryAssignment, Chat,
		Comment, Event, FAQ, Help, Like, Media, Menu, Order, Payment, Place, Post,
		Rating, Reaction, Reservation, Resourse, Review, Room, Ticket, TicketOption,
		User, UserBusiness, UserFollowBusiness, UserFollowEvent, UserFollowPlace,
		UserFollowUser, UserLikePlace []ent.Hook
	}
	inters struct {
		AccountSettings, Amenity, Booking, Business, BusinessFollowBusiness,
		BusinessFollowEvent, BusinessFollowUser, Category, CategoryAssignment, Chat,
		Comment, Event, FAQ, Help, Like, Media, Menu, Order, Payment, Place, Post,
		Rating, Reaction, Reservation, Resourse, Review, Room, Ticket, TicketOption,
		User, UserBusiness, UserFollowBusiness, UserFollowEvent, UserFollowPlace,
		UserFollowUser, UserLikePlace []ent.Interceptor
	}
)
